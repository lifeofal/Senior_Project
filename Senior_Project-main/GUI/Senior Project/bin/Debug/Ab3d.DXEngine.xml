<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Ab3d.DXEngine</name>
    </assembly>
    <members>
        <member name="T:Ab3d.Licensing.DXEngine.LicenseHelper">
            <summary>
            LicenseHelper class defines the <see cref="M:Ab3d.Licensing.DXEngine.LicenseHelper.SetLicense(System.String,System.String,System.String)" /> method that can be called to set the license data.
            </summary>
        </member>
        <member name="M:Ab3d.Licensing.DXEngine.LicenseHelper.SetLicense(System.String,System.String,System.String)">
            <summary>
            SetLicense method can be called to activate the commercial license or extend the evaluation.
            The parameter values for the commercial value can be get from the User Account web page.
            </summary>
            <param name="licenseOwner">license owner</param>
            <param name="licenseType">type of the license</param>
            <param name="license">license text</param>
        </member>
        <member name="T:Ab3d.DirectX.ICamera">
            <summary>
            ICamera is base interface that defines a 3D camera in DXEngine
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ICamera.ParentDXScene">
            <summary>
            Gets or sets the DXScene that this camera belong to.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ICamera.ParentSceneNode">
            <summary>
            Gets or sets a parent SceneNode that can be used to adjust the camera's View matrix with the SceneNode's world matrix.
            This can be used to animate the camera with SceneNode.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ICamera.View">
            <summary>
            Gets the camera's view matrix.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ICamera.Projection">
            <summary>
            Gets the camera's projection matrix.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ICamera.ProjectionType">
            <summary>
            Gets type of projection (Perspective or Orthographic)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ICamera.AspectRatio">
            <summary>
            Gets or sets the camera's aspect ratio - calculated as viewport's width / height.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ICamera.NearPlaneDistance">
            <summary>
            Gets or sets a value that specifies the distance from the camera of the camera's near clip plane.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ICamera.FarPlaneDistance">
            <summary>
            Gets or sets a value that specifies the distance from the camera of the camera's far clip plane.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.ICamera.CameraChanged">
            <summary>
            CameraChanged event occurs after the camera was changed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ICamera.GetCameraPosition">
            <summary>
            Returns the current position of the camera.
            </summary>
            <returns>the current position of the camera as Vector3</returns>
        </member>
        <member name="M:Ab3d.DirectX.ICamera.GetViewProjection">
            <summary>
            Gets a precalculated View * Projection matrix.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ICamera.GetWorldViewProjection(SharpDX.Matrix@)">
            <summary>
            Returns WorldViewProjection matrix.
            Calculating this matrix is faster inside Camera because here we can access matrixes by reference.
            </summary>
            <param name="world">World matrix</param>
            <returns>WorldViewProjection matrix</returns>
        </member>
        <member name="M:Ab3d.DirectX.ICamera.Update(System.Boolean)">
            <summary>
            Update method updates the camera matrices when needed (when there were any change in the camera properties) or when forceMatrixUpdate is set to true.
            </summary>
            <param name="forceMatrixUpdate">when true, than camera matrices are recalculated regardless if there were any changes in camera properties or not</param>
        </member>
        <member name="T:Ab3d.DirectX.Cameras.IDistanceCamera">
            <summary>
            IDistanceCamera interface defines the Distance property
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.IDistanceCamera.Distance">
            <summary>
            Gets or sets a distance from the camera to the target position
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Cameras.ILeftRightHandedCoordinateSystem">
            <summary>
            When ILeftRightHandedCamera interface is used it specifies if left or right handed coordinate system is used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.ILeftRightHandedCoordinateSystem.IsRightHandedCoordinateSystem">
            <summary>
            When true than right handed coordinate system is used (as in WPF 3D, XNA and OpenGL), if false than left handed coordinate system are used (as in DirectX).
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Cameras.ILookDirectionCamera">
            <summary>
            ILookDirectionCamera is camera that implements GetCameraLookDirection method.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.ILookDirectionCamera.GetCameraLookDirection">
            <summary>
            Returns the camera look direction.
            </summary>
            <returns>camera look direction as Vector3</returns>
        </member>
        <member name="T:Ab3d.DirectX.Cameras.IPerspectiveCamera">
            <summary>
            IPerspectiveCamera interface defines the perspective camera with FieldOfView property
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.IPerspectiveCamera.FieldOfView">
            <summary>
            Gets or sets camera's field of view in degres
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Cameras.IRotatingCamera">
            <summary>
            IRotatingCamera interface defines a camera that provides rotation animation
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.IRotatingCamera.IsRotating">
            <summary>
            Gets or sets a boolean that specifies if the camera is currently being animated.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.IRotatingCamera.StartRotation(System.Double,System.Double)">
            <summary>
            StartRotation method starts Heading and Attitude animation for this camera.
            </summary>
            <param name="headingChangeInSecond">How many degrees the heading will be changed in one second</param>
            <param name="attitudeChangeInSecond">How many degrees the attitude will be changed in one second</param>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.IRotatingCamera.StopRotation">
            <summary>
            StopRotation stops the animation of the camera.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Cameras.ISphericalCamera">
            <summary>
            ISphericalCamera interface defines a camera where the look direction is defined by Heading, Attitude and Bank angles.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.ISphericalCamera.Heading">
            <summary>
            Heading angle (rotation around up axis) in degrees.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.ISphericalCamera.Attitude">
            <summary>
            Attitude angle (rotation around horizontal axis) in degrees.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.ISphericalCamera.Bank">
            <summary>
            Bank angle (rotation around look direction vector) in degrees.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Cameras.ITargetPositionCamera">
            <summary>
            ILookDirectionCamera is camera that implements GetCameraTargetPosition method.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.ITargetPositionCamera.GetCameraTargetPosition">
            <summary>
            Returns the camera look position.
            </summary>
            <returns>camera look position as Vector3</returns>
        </member>
        <member name="T:Ab3d.DirectX.Cameras.MatrixCamera">
            <summary>
            MatrixCamera is a simple camera that provides the View and Projection matrices.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.MatrixCamera.ParentDXScene">
            <summary>
            Gets or sets the DXScene that this camera belong to.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.MatrixCamera.ParentSceneNode">
            <summary>
            Gets or sets a parent SceneNode that can be used to adjust the camera's View matrix with the SceneNode's world matrix.
            This can be used to animate the camera with SceneNode.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.MatrixCamera.View">
            <summary>
            Gets the camera's view matrix.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.MatrixCamera.Projection">
            <summary>
            Gets the camera's projection matrix.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.MatrixCamera.AspectRatio">
            <summary>
            Gets or sets the camera's aspect ration - calculated as viewport's width / height.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.MatrixCamera.ProjectionType">
            <summary>
            Gets type of projection (Perspective or Orthographic)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.MatrixCamera.NearPlaneDistance">
            <summary>
            Gets or sets a value that specifies the distance from the camera of the camera's near clip plane.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.MatrixCamera.FarPlaneDistance">
            <summary>
            Gets or sets a value that specifies the distance from the camera of the camera's far clip plane.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.Cameras.MatrixCamera.CameraChanged">
            <summary>
            CameraChanged event occurs after the camera was changed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.MatrixCamera.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.MatrixCamera.#ctor(SharpDX.Matrix,SharpDX.Matrix)">
            <summary>
            Constructor
            </summary>
            <param name="view">view matrix</param>
            <param name="projection">projection matrix</param>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.MatrixCamera.Update(System.Boolean)">
            <summary>
            Update method updates the camera matrices when needed (when there were any change in the camera properties) or when forceMatrixUpdate is set to true.
            </summary>
            <param name="forceMatrixUpdate">when true, than camera matrices are recalculated regardless if there were any changes in camera properties or not</param>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.MatrixCamera.GetCameraPosition">
            <summary>
            Gets the camera's position. 
            The position is calculating with inverting the view matrix and extracting the values from 4th row.
            The invert operation can be skipped with calling <see cref="M:Ab3d.DirectX.Cameras.MatrixCamera.SetCameraPosition(SharpDX.Vector3)" /> method.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.MatrixCamera.SetCameraPosition(SharpDX.Vector3)">
            <summary>
            Sets camera's position. This prevents calling invert on view matrix when the <see cref="M:Ab3d.DirectX.Cameras.MatrixCamera.GetCameraPosition" /> is called.
            This method should be called after setting View matrix.
            </summary>
            <param name="cameraPosition">Vector3 as camera position</param>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.MatrixCamera.GetViewProjection">
            <summary>
            Gets a pre-calculated View * Projection matrix.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.MatrixCamera.GetWorldViewProjection(SharpDX.Matrix@)">
            <summary>
            Returns WorldViewProjection matrix.
            Calculating this matrix is faster inside Camera because here we can access matrixes by reference.
            </summary>
            <param name="world">World matrix</param>
            <returns>WorldViewProjection matrix</returns>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.MatrixCamera.SetViewMatrix(SharpDX.Matrix@)">
            <summary>
            SetViewMatrix can be called by the derived class to change the view matrix.
            </summary>
            <param name="viewMatrix">view matrix</param>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.MatrixCamera.SetProjectionMatrix(SharpDX.Matrix@)">
            <summary>
            SetProjectionMatrix can be called by the derived class to change the projection matrix.
            </summary>
            <param name="projectionMatrix">projection matrix</param>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.MatrixCamera.OnCameraChanged">
            <summary>
            OnCameraChanged is called when the camera is changed and triggers the CameraChanged event.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Cameras.ProjectionType">
            <summary>
            ProjectionType defines possible types of camera projection.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Cameras.ProjectionType.Perspective">
            <summary>
            Perspective projection
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Cameras.ProjectionType.Orthographic">
            <summary>
            Orthographic projection
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Cameras.StereoscopicCamera">
            <summary>
            StereoscopicCamera is a camera that warps another camera (<see cref="P:Ab3d.DirectX.Cameras.StereoscopicCamera.OriginalCamera" />) and provides properties that allow using
            the camera for stereoscopic rendering with different camera for left and for right eye.
            The current eye is defined by <see cref="P:Ab3d.DirectX.Cameras.StereoscopicCamera.CurrentEye" /> property. 
            The differences of the left and right cameras are defined by <see cref="P:Ab3d.DirectX.Cameras.StereoscopicCamera.EyeSeparation" />, <see cref="P:Ab3d.DirectX.Cameras.StereoscopicCamera.Parallax" /> and <see cref="P:Ab3d.DirectX.Cameras.StereoscopicCamera.InvertLeftRightView" /> properties.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.OriginalCamera">
            <summary>
            Gets the camera that is used to create the StereoscopicCamera.
            The original camera is located in the middle between left and right eye.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.ParentDXScene">
            <summary>
            Gets or sets a ParentDXScene property of the OriginalCamera.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.ParentSceneNode">
            <summary>
            Gets a ParentSceneNode property of the OriginalCamera.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.ProjectionType">
            <summary>
            Gets a ProjectionType property of the OriginalCamera.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.AspectRatio">
            <summary>
            Gets or sets an AspectRatio property of the OriginalCamera.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.NearPlaneDistance">
            <summary>
            Gets or sets a NearPlaneDistance property of the OriginalCamera.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.FarPlaneDistance">
            <summary>
            Gets or sets a FarPlaneDistance property of the OriginalCamera.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.View">
            <summary>
            Gets a View matrix for the current eye.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.Projection">
            <summary>
            Gets a Projection matrix for the current eye.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.CurrentEye">
            <summary>
            Gets or sets the current eye for the camera.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.EyeSeparation">
            <summary>
            Gets or sets a distance between left and right eye. The distance is specified in the same coordinate system as the camera.
            When rendering, the camera is first shifter to the left for the half of the EyeSeparation distance. Then the whole scene is rendered.
            The the camera is shifter to the right for half of the EyeSeparation distance.
            The best value for EyeSeparation is based on the size of objects in the scene, the size of the Viewport3D, monitor DPI settings and the actual distance between eyes of the user.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.Parallax">
            <summary>
            Parallax defines a value in degrees that specifies an angle of the left and right eye look direction.
            If the parallax is zero, then the look directions of left and right cameras are parallel.
            If parallax is bigger then zero, then the left and right look directions are pointed to each other and they cross at some position in front of the camera (the bigger the angle the closer the crossing point).
            Usually the best 3D effect is producted when the parallax is set so that the look directions cross at the center of the scene - look directions of human eyes cross at the point of focus.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Cameras.StereoscopicCamera.InvertLeftRightView">
            <summary>
            Gets or sets a Boolean that specifies if positions of the eyes are inverted.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.Cameras.StereoscopicCamera.CameraChanged">
            <summary>
            CameraChanged event of the OriginalCamera.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.StereoscopicCamera.#ctor(Ab3d.DirectX.ICamera)">
            <summary>
            Constructor
            </summary>
            <param name="originalCamera">camera that is wrapped by this StereoscopicCamera</param>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.StereoscopicCamera.GetCameraPosition">
            <summary>
            Returns eye position for the current eye.
            </summary>
            <returns>eye position</returns>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.StereoscopicCamera.GetViewProjection">
            <summary>
            Gets a precalculated View * Projection matrix.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.StereoscopicCamera.GetWorldViewProjection(SharpDX.Matrix@)">
            <summary>
            Returns WorldViewProjection matrix.
            Calculating this matrix is faster inside Camera because here we can access matrixes by reference.
            </summary>
            <param name="world">World matrix</param>
            <returns>WorldViewProjection matrix</returns>
        </member>
        <member name="M:Ab3d.DirectX.Cameras.StereoscopicCamera.Update(System.Boolean)">
            <summary>
            Update method updates the camera matrices when needed (when there were any change in the camera properties) or when forceMatrixUpdate is set to true.
            </summary>
            <param name="forceMatrixUpdate">when true, than camera matrices are recalculated regardless if there were any changes in camera properties or not</param>
        </member>
        <member name="T:Ab3d.DirectX.Bounds">
            <summary>
            Bounds defines a BoundingBox and also provides IsEmpty property.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Bounds.IsEmpty">
            <summary>
            Gets a Boolean that specifies if BoundingBox is empty.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Bounds.BoundingBox">
            <summary>
            Gets a BoundingBox. To set the BoundingBox call the SetBoundingBox method.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.#ctor">
            <summary>
            Constructor that creates an empty Bounds
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Bounds.Empty">
            <summary>
            Returns an new instance of Bounds object with an empty bounds
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.#ctor(SharpDX.BoundingBox)">
            <summary>
            Constructor with specified BoundingBox
            </summary>
            <param name="boundingBox">BoundingBox</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.#ctor(SharpDX.Vector3,SharpDX.Vector3)">
            <summary>
            Constructor that is created from specified minimum and maximum positions.
            </summary>
            <param name="minimum">The minimum vertex of the bounding box.</param>
            <param name="maximum">The maximum vertex of the bounding box.</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.#ctor(SharpDX.Vector3,System.Single)">
            <summary>
            Constructor that is created from specified sphere's center and sphere's radius.
            </summary>
            <param name="boundingSphereCenter">sphere's center</param>
            <param name="boundingSphereRadius">sphere's radius</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.SetBoundingBox(SharpDX.BoundingBox,System.Boolean)">
            <summary>
            Sets the BoundingBox property value. 
            When checkForEmpty parameter is true, it also checks if the new BoundingBox is empty and sets the <see cref="P:Ab3d.DirectX.Bounds.IsEmpty" /> property accordingly.
            If checkForEmpty parameter is false, then the <see cref="P:Ab3d.DirectX.Bounds.IsEmpty" /> property is set to false.
            To set the BoundingBox to empty value call the <see cref="M:Ab3d.DirectX.Bounds.Clear" /> method.
            </summary>
            <param name="boundingBox">BoundingBox</param>
            <param name="checkForEmpty">true to check if the BoundingBox is empty.</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.SetBoundingBox(SharpDX.BoundingBox@,System.Boolean)">
            <summary>
            Sets the BoundingBox property value. 
            When checkForEmpty parameter is true, it also checks if the new BoundingBox is empty and sets the <see cref="P:Ab3d.DirectX.Bounds.IsEmpty" /> property accordingly.
            If checkForEmpty parameter is false, then the <see cref="P:Ab3d.DirectX.Bounds.IsEmpty" /> property is set to false.
            To set the BoundingBox to empty value call the <see cref="M:Ab3d.DirectX.Bounds.Clear" /> method.
            </summary>
            <param name="boundingBox">BoundingBox</param>
            <param name="checkForEmpty">true to check if the BoundingBox is empty.</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.CopyFrom(Ab3d.DirectX.Bounds)">
            <summary>
            Copies the specified bounds to this Bounds object.
            </summary>
            <param name="bounds">Bounds to copy from</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.Clear">
            <summary>
            Clears the Bounds
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.Add(Ab3d.DirectX.Bounds)">
            <summary>
            Adds another bounds to this bounds
            </summary>
            <param name="boundsToAdd">Bounds</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.Add(SharpDX.Vector3)">
            <summary>
            Adds one Vector3 to this bounds
            </summary>
            <param name="positionToAdd">Vector3</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.Transform(Ab3d.DirectX.Transformation)">
            <summary>
            Transforms the current Bounds with the specified transformation
            </summary>
            <param name="transformation">transformation</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.Translate(SharpDX.Vector3@,SharpDX.Vector3@,SharpDX.Vector3@)">
            <summary>
            Sets the out minimum and maximum Vector3D with translating the current bounds with the specified translateVector (the current Bounds value is not changed).
            </summary>
            <param name="translateVector">translateVector</param>
            <param name="minimum">translated minimum</param>
            <param name="maximum">translated maximum</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.ScaleAndTranslate(SharpDX.Matrix@,SharpDX.Vector3@,SharpDX.Vector3@)">
            <summary>
            Sets the out minimum and maximum Vector3D with transforming the current BoundingBox's minimum and maximum value with the specified matrix (the current Bounds value is not changed).
            </summary>
            <param name="matrix">matrix</param>
            <param name="minimum">transformed minimum</param>
            <param name="maximum">transformed maximum</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.TransformAllCorners(SharpDX.Matrix@,SharpDX.Vector3@,SharpDX.Vector3@)">
            <summary>
            Sets the out minimum and maximum Vector3D with transforming the current bounds with the specified matrix (the current Bounds value is not changed).
            </summary>
            <param name="matrix">matrix</param>
            <param name="minimum">transformed minimum</param>
            <param name="maximum">transformed maximum</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.Transform(SharpDX.Matrix@)">
            <summary>
            Transforms the current BoundingBox with the specified matrix
            </summary>
            <param name="matrix">matrix</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.Transform(SharpDX.Matrix@,SharpDX.Vector3@,SharpDX.Vector3@)">
            <summary>
            Transforms the current BoundingBox with the specified matrix and writes the transformed minimum and maximum positions to the specified parameters.
            </summary>
            <param name="matrix">matrix</param>
            <param name="transformedMin">transformed minimum as Vector3</param>
            <param name="transformedMax">transformed maximum as Vector3</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.Transform(Ab3d.DirectX.Transformation,SharpDX.Vector3@,SharpDX.Vector3@)">
            <summary>
            Transforms the current BoundingBox with the specified matrix and writes the transformed minimum and maximum positions to the specified parameters.
            </summary>
            <param name="transformation">Transformation</param>
            <param name="transformedMin">transformed minimum as Vector3</param>
            <param name="transformedMax">transformed maximum as Vector3</param>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.GetCenterPosition">
            <summary>
            Returns center position of this Bounds.
            </summary>
            <returns>center position of this Bounds</returns>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.GetSize">
            <summary>
            Returns Vector3 that represents size of the  BoundingBox
            </summary>
            <returns>Vector3 that represents size of the  BoundingBox</returns>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.GetDiagonalLength">
            <summary>
            Returns the length of the BoundingBox diagonal that is the same as distance from Minimum to Maximum positions.
            </summary>
            <returns>length of the BoundingBox diagonal</returns>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.IsSame(Ab3d.DirectX.Bounds)">
            <summary>
            Returns true if this Bounds is same as specified Bounds (using MathUtil.NearEqual to compare the values)
            </summary>
            <param name="bounds">Bounds to compare</param>
            <returns>true if same, otherwise false</returns>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.IsSame(SharpDX.BoundingBox@)">
            <summary>
            Returns true if this Bounds is same as specified BoundingBox (using MathUtil.NearEqual to compare the values)
            </summary>
            <param name="boundingBox">BoundingBox to compare</param>
            <returns>true if same, otherwise false</returns>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.IsEqual(Ab3d.DirectX.Bounds)">
            <summary>
            Returns true if this Bounds is equal as specified Bounds
            </summary>
            <param name="bounds">Bounds to compare</param>
            <returns>true if equal, otherwise false</returns>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.IsEqual(SharpDX.BoundingBox@)">
            <summary>
            Returns true if this Bounds is equal as specified BoundingBox
            </summary>
            <param name="boundingBox">BoundingBox to compare</param>
            <returns>true if equal, otherwise false</returns>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.IsBoundingBoxEmpty(SharpDX.BoundingBox@)">
            <summary>
            Returns true if BoundingBox is empty (any component is NaN or if all components are equal)
            </summary>
            <param name="boundingBox">BoundingBox</param>
            <returns>true if BoundingBox is empty</returns>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.CalculateBoundingBox(Ab3d.DirectX.PositionNormalTexture[])">
            <summary>
            Returns a BoundingBox that is calculated from the specified vertexBufferArray.
            </summary>
            <param name="vertexBufferArray">array of PositionNormalTexture</param>
            <returns>BoundingBox that is calculated from the specified vertexBufferArray</returns>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.CalculateBoundingBox(Ab3d.DirectX.PositionNormal[])">
            <summary>
            Returns a BoundingBox that is calculated from the specified vertexBufferArray.
            </summary>
            <param name="vertexBufferArray">array of PositionNormal</param>
            <returns>BoundingBox that is calculated from the specified vertexBufferArray</returns>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.CalculateBoundingBox(SharpDX.Vector3[])">
            <summary>
            Returns a BoundingBox that is calculated from the specified positionsArray.
            </summary>
            <param name="positionsArray">array of Vector3</param>
            <returns>BoundingBox that is calculated from the specified positionsArray</returns>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.Clone">
            <summary>
            Creates a new Bounds objects that is the same as this Bounds.
            </summary>
            <returns>cloned Bounds</returns>
        </member>
        <member name="M:Ab3d.DirectX.Bounds.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.Bounds.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.Bounds.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Ab3d.DirectX.Common.DeviceRemovedEventHandler">
            <summary>
            DeviceRemovedEventHandler is an event handler with DeviceRemovedEventArgs as event arguments
            </summary>
            <param name="sender">sender</param>
            <param name="e">RenderingEventArgs</param>
        </member>
        <member name="T:Ab3d.DirectX.Common.DeviceRemovedEventArgs">
            <summary>
            DeviceRemovedEventArgs is used when the DirectX device is removed or reset.
            The event handler can handle this case with saving the current state of the 3D scene, dispose the current DirectX objects and recreate the 3D scene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Common.DeviceRemovedEventArgs.Message">
            <summary>
            Message describes where the device removal happened
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Common.DeviceRemovedEventArgs.SharpDxException">
            <summary>
            SharpDXException that was thrown when DirectX call was made on a removed device.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Common.DeviceRemovedEventArgs.DeviceRemovedReason">
            <summary>
            Reason why the device was removed that is get from calling GetDeviceRemovedReason method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Common.DeviceRemovedEventArgs.IsHandled">
            <summary>
            When IsHandled is set by the event handler, then the DXScene does not throw an exception as it is considered that the event handler will dispose and recreate the DXScene.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Common.DeviceRemovedEventArgs.#ctor(System.String,SharpDX.SharpDXException,SharpDX.ResultDescriptor)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.DeviceCapabilities">
            <summary>
            DeviceCapabilities class describes the capabilities of a DirectX device.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DeviceCapabilities.AllFeatureLevels">
            <summary>
            AllFeatureLevels defines all possible feature leveles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DeviceCapabilities.IsDirectX11Supported">
            <summary>
            Gets a Boolean that specifies if the tested device support DirectX 11. If false the DirectX 11 device cannot be created.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DeviceCapabilities.FeatureLevel">
            <summary>
            Gets the FeatureLevel of the created device. 
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DeviceCapabilities.MaxSupportedMultisamplingCount">
            <summary>
            Gets an integer that specifies the maximum multisampling count that is supported by the tested device.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DeviceCapabilities.Is32BitIndexBufferSupported">
            <summary>
            Gets a Boolean that specifies if 32 bit index buffer is supported.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DeviceCapabilities.LastError">
            <summary>
            Gets the last exception that happened when testing the device capabilities.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DeviceCapabilities.SoftwareDeviceCapabilities">
            <summary>
            Gets DeviceCapabilities for DirectX 11 Software (WARP) renderer.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DeviceCapabilities.QueryDefaultDevice">
            <summary>
            Returns DeviceCapabilities for the default device
            </summary>
            <returns>DeviceCapabilities</returns>
        </member>
        <member name="M:Ab3d.DirectX.DeviceCapabilities.QueryDevice(SharpDX.Direct3D11.Device)">
            <summary>
            Returns DeviceCapabilities for the specified device.
            </summary>
            <param name="device">device</param>
            <returns>DeviceCapabilities</returns>
        </member>
        <member name="M:Ab3d.DirectX.DeviceCapabilities.QueryAdapter(SharpDX.DXGI.Adapter)">
            <summary>
            Returns DeviceCapabilities for the specified adapter.
            </summary>
            <param name="adapter">adapter</param>
            <returns>DeviceCapabilities</returns>
        </member>
        <member name="M:Ab3d.DirectX.DeviceCapabilities.#ctor(SharpDX.Direct3D11.Device)">
            <summary>
            Constructor
            </summary>
            <param name="device">device</param>
        </member>
        <member name="M:Ab3d.DirectX.DeviceCapabilities.#ctor(SharpDX.DXGI.Adapter)">
            <summary>
            Constructor
            </summary>
            <param name="adapter">adapter</param>
        </member>
        <member name="T:Ab3d.DirectX.DisposeHelper">
            <summary>
            DisposeHelper class provides DisposeAndNullify methods that can help dispose and nullify a disposable object.
             </summary>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(System.IDisposable@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(SharpDX.Direct3D11.Texture2D@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(Ab3d.DirectX.Effect@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(SharpDX.Direct3D11.RenderTargetView@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(SharpDX.Direct3D11.ShaderResourceView@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(SharpDX.Direct3D11.BlendState@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(SharpDX.Direct3D11.DepthStencilState@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(SharpDX.Direct3D11.RasterizerState@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(SharpDX.Direct3D11.SamplerState@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(SharpDX.Direct3D11.Buffer@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(SharpDX.Direct3D11.DepthStencilView@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(Ab3d.DirectX.SimpleMesh{Ab3d.DirectX.PositionNormalTexture}@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(Ab3d.DirectX.MeshObjectNode@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(Ab3d.DirectX.SharedDXResourceWrapper{SharpDX.Direct3D11.VertexShader}@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(Ab3d.DirectX.SharedDXResourceWrapper{SharpDX.Direct3D11.PixelShader}@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(Ab3d.DirectX.SharedDXResourceWrapper{SharpDX.Direct3D11.GeometryShader}@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeHelper.DisposeAndNullify(Ab3d.DirectX.SharedDXResourceWrapper{SharpDX.Direct3D11.InputLayout}@)">
            <summary>
            DisposeAndNullify first checks if disposableObject is not null and in that case disposed the object and sets it to null.
            </summary>
            <param name="disposableObject"></param>
        </member>
        <member name="T:Ab3d.DirectX.DisposeList">
            <summary>
            DisposeList contains a list of IDisposable objects that are automatically disposed when DisposeList is disposed.
            The order of disposal is reversed from the order in which the objects were added to the list (first object is disposed last).
            </summary>
            <remarks>
                <para>
            NOTE:<br />
            We do not check if the objectToDispose is already in the _disposables list
            This check is quite expensive - we need to go throug the whole list each time.
            Therefore the objects that are added to DisposeList must check if they are already disposed and should not dispose themself more than once. 
            </para>
            </remarks>
        </member>
        <member name="M:Ab3d.DirectX.DisposeList.Add(System.IDisposable)">
            <summary>
            Adds object to this DisposeList
            </summary>
            <param name="objectToDispose">objectToDispose</param>
        </member>
        <member name="M:Ab3d.DirectX.DisposeList.Remove(System.IDisposable)">
            <summary>
            Removes object from this DisposeList
            </summary>
            <param name="objectToRemove">objectToRemove</param>
            <returns>true if removed, false if not found in this DisposeList</returns>
        </member>
        <member name="M:Ab3d.DirectX.DisposeList.Dispose">
            <summary>
            Disposes all objects in this DisposeList
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.DeviceCreationException">
            <summary>
            DeviceCreationException occurs when the DirectX device cannot be created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DeviceCreationException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">message</param>
        </member>
        <member name="M:Ab3d.DirectX.DeviceCreationException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">message</param>
            <param name="innerException">innerException</param>
        </member>
        <member name="M:Ab3d.DirectX.DeviceCreationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info">info</param>
            <param name="context">context</param>
        </member>
        <member name="T:Ab3d.DirectX.DXEngineComException">
            <summary>
            DXEngineException exception thrown is thrown when an error occured when calling DirectX COM methods.
            The exception class contains details information about the error in the Descriptor property.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXEngineComException.Descriptor">
            <summary>
            Gets the SharpDX.Result with error code.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXEngineComException.#ctor(SharpDX.ResultDescriptor)">
            <summary>
            Constructor
            </summary>
            <param name="resultDescriptor">SharpDX.ResultDescriptor</param>
        </member>
        <member name="M:Ab3d.DirectX.DXEngineComException.#ctor(SharpDX.Result)">
            <summary>
            Constructor
            </summary>
            <param name="result">SharpDX.Result from COM error code</param>
        </member>
        <member name="M:Ab3d.DirectX.DXEngineComException.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="errorCode">COM error code</param>
        </member>
        <member name="M:Ab3d.DirectX.DXEngineComException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info">SerializationInfo</param>
            <param name="context">StreamingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.DXEngineComException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.DXEngineException">
            <summary>
            DXEngineException is base class for all exception thrown in Ab3d.DXEngine.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXEngineException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXEngineException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">message</param>
        </member>
        <member name="M:Ab3d.DirectX.DXEngineException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">message</param>
            <param name="innerException">innerException</param>
        </member>
        <member name="M:Ab3d.DirectX.DXEngineException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info">SerializationInfo</param>
            <param name="context">StreamingContext</param>
        </member>
        <member name="T:Ab3d.DirectX.FeatureLevelsNotSupportedException">
            <summary>
            FeatureLevelsNotSupportedException occurs when the DirectX 11 device cannot be created because the the adapter (graphics card) does not support the required feature levels.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.FeatureLevelsNotSupportedException.RequiredFeatureLevels">
            <summary>
            FeatureLevels that were required when creating the device.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.FeatureLevelsNotSupportedException.#ctor(System.String,SharpDX.Direct3D.FeatureLevel[],System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">message</param>
            <param name="requiredFeatureLevels">array of FeatureLevels that were required when creating the device</param>
            <param name="innerException">innerException</param>
        </member>
        <member name="M:Ab3d.DirectX.FeatureLevelsNotSupportedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info">info</param>
            <param name="context">context</param>
        </member>
        <member name="M:Ab3d.DirectX.FeatureLevelsNotSupportedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown. </param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination. </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is a null reference (Nothing in Visual Basic). </exception>
            <PermissionSet>
                <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*" />
                <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter" />
            </PermissionSet>
        </member>
        <member name="T:Ab3d.DirectX.InvalidDxEngineResourceException">
            <summary>
            InvalidDxEngineResourceException exception is thrown when a Texture2D, Buffer, View or some other resource is not in the expected format or was not created with the expected flags.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.InvalidDxEngineResourceException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.InvalidDxEngineResourceException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">message</param>
        </member>
        <member name="M:Ab3d.DirectX.InvalidDxEngineResourceException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">message</param>
            <param name="innerException">innerException</param>
        </member>
        <member name="M:Ab3d.DirectX.InvalidDxEngineResourceException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info">SerializationInfo</param>
            <param name="context">StreamingContext</param>
        </member>
        <member name="T:Ab3d.DirectX.ResourceCreationException">
            <summary>
            ResourceCreationException exception is thrown when DXEngine's resources cannot be found or are not defined correctly.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ResourceCreationException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ResourceCreationException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">message</param>
        </member>
        <member name="M:Ab3d.DirectX.ResourceCreationException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">message</param>
            <param name="innerException">innerException</param>
        </member>
        <member name="M:Ab3d.DirectX.ResourceCreationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info">SerializationInfo</param>
            <param name="context">StreamingContext</param>
        </member>
        <member name="T:Ab3d.DirectX.Extensions">
            <summary>
            Extension methods that help work with SharpDX objects.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Extensions.Saturate(SharpDX.Color4)">
            <summary>
            Ensures that the color components are within 0 and 1 - if smaller than 0 than the value is set to 0; if bigger than 1 the value is set to 1. This is the same as saturate function in HLSL.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Extensions.ToColor4(SharpDX.Color3)">
            <summary>
            Converts Color3 to Color4
            </summary>
            <param name="color">Color3</param>
            <returns>Color4</returns>
        </member>
        <member name="M:Ab3d.DirectX.Extensions.ToColor4(SharpDX.Color3,System.Single)">
            <summary>
            Converts Color3 with alpha to Color4
            </summary>
            <param name="color">Color3</param>
            <param name="alpha">alpha</param>
            <returns>Color4</returns>
        </member>
        <member name="M:Ab3d.DirectX.Extensions.ToColor3(SharpDX.Color4)">
            <summary>
            Converts Color4 to Color3
            </summary>
            <param name="color">Color4</param>
            <returns>Color3</returns>
        </member>
        <member name="M:Ab3d.DirectX.Extensions.FastEquals(SharpDX.Matrix,SharpDX.Matrix@)">
            <summary>
            FastEquals compares two matrixes and returns true if they are exactly equal.
            To find results faster the FastEquals checks the fields that are usually different first (Offset, then scale, the others).
            </summary>
            <remarks>
                <para>
                    <b>FastEquals</b> compares two matrixes and returns true if they are exactly equal.
            </para>
                <para>
            This method is much faster then the standard SharpDX.Matrix.Equals method.
            </para>
                <para>
            The first problem with harpDX.Matrix.Equals is that it uses IsSimilar (Abs(m1 - m2) &lt; epsilon) that require many operations and casting to double.
            </para>
                <para>
            The second thing is that the FastEquals fist compares the fields that are most likely to be different:  first Offset, than scale and the other fields.
            Also M14, M24 and M34 are not compared because they do not play any role in standard matrix.
            </para>
            </remarks>
            <param name="m1">first Matrix</param>
            <param name="m2">second Matrix</param>
            <returns>true if the matrixes are exactly equal</returns>
        </member>
        <member name="T:Ab3d.DirectX.InputElementFactory">
            <summary>
            InputElementFactory is a helper class that can help with creation of InputElement arrays.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.InputElementFactory.IsSupportedInputLayout(Ab3d.DirectX.InputLayoutType,Ab3d.DirectX.InputLayoutType)">
            <summary>
            Returns boolean that specifies if the requiredInputLayout can be used with the availableInputLayout.
            </summary>
            <remarks>
                <para>
                    <b>IsSupportedInputLayout</b> returns boolean that specifies if the requiredInputLayout can be used with the availableInputLayout.
            </para>
                <para>
            For example Position_Normal_TextureCoordinate input layout can be used for effects that require Position_Normal input layout.
            </para>
            </remarks>
            <param name="availableInputLayout">available InputLayout</param>
            <param name="requiredInputLayout">required InputLayout</param>
            <returns>boolean that specifies if the requiredInputLayout can be used with the availableInputLayout</returns>
        </member>
        <member name="M:Ab3d.DirectX.InputElementFactory.GetInputElementsArray(Ab3d.DirectX.InputLayoutType)">
            <summary>
            Returns array of InputElement structs that describes the supplied inputLayoutType.
            This method is thread safe and can be called from any thread.
            </summary>
            <param name="inputLayoutType">inputLayoutType</param>
            <returns>array of InputElement structs</returns>
        </member>
        <member name="M:Ab3d.DirectX.InputElementFactory.CreateInputElement(System.String,System.Int32,SharpDX.DXGI.Format,System.Int32,System.Int32,SharpDX.Direct3D11.InputClassification,System.Int32)">
            <summary>
            Create one InputElement based on the supplied parameters
            </summary>
            <param name="semanticName">semanticName</param>
            <param name="alignedByteOffset">alignedByteOffset</param>
            <param name="format">format</param>
            <param name="semanticIndex">semanticIndex</param>
            <param name="inputSlot">inputSlot</param>
            <param name="inputSlotClass">inputSlotClass</param>
            <param name="instanceDataStepRate">instanceDataStepRate</param>
            <returns>InputElement</returns>
        </member>
        <member name="T:Ab3d.DirectX.InputLayoutType">
            <summary>
            InputLayoutType defines the possible components of InputLayout. Note that it is possible to define data for first and second input slot.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Position">
            <summary>
            Positions that are bound to the first input slot (slot index = 0)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Normal">
            <summary>
            Normals that are bound to the first input slot (slot index = 0)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.TextureCoordinate">
            <summary>
            TextureCoordinates that are bound to the first input slot (slot index = 0)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Color3">
            <summary>
            Color with RGB values that are bound to the first input slot (slot index = 0)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Color">
            <summary>
            Color with RGBA values that are bound to the first input slot (slot index = 0)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Color4">
            <summary>
            Color with RGBA values that are bound to the first input slot (slot index = 0)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Tangent">
            <summary>
            Tangents that are bound to the first input slot (slot index = 0)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Bitangent">
            <summary>
            Bitangents that are bound to the first input slot (slot index = 0)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Position_Slot1">
            <summary>
            Positions that are bound to second input slot (slot index = 1)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Normal_Slot1">
            <summary>
            Normals that are bound to second input slot (slot index = 1)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.TextureCoordinate_Slot1">
            <summary>
            TextureCoordinates that are bound to second input slot (slot index = 1)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Color3_Slot1">
            <summary>
            Color with RGB values that are bound to second input slot (slot index = 1)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Color_Slot1">
            <summary>
            Color with RGBA values that are bound to second input slot (slot index = 1)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Color4_Slot1">
            <summary>
            Color with RGBA values that are bound to second input slot (slot index = 1)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Tangent_Slot1">
            <summary>
            Tangents that are bound to second input slot (slot index = 1)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.InputLayoutType.Bitangent_Slot1">
            <summary>
            Bitangents that are bound to second input slot (slot index = 1)
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.OnePixelTexture">
            <summary>
            OnePixelTexture class creates a ShaderResourceView with a 1x1 texture (one pixel) with the specified color.
            The class also provides easy updating of the color.
            When you do not need to update the color of the texture, then you can also use a static <see cref="M:Ab3d.DirectX.OnePixelTexture.CreateOnePixelTexture(SharpDX.Direct3D11.Device,SharpDX.Color4,SharpDX.DXGI.Format)" /> method.
            User needs to dispose the created OnePixelTexture to prevent resources leaking.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.OnePixelTexture.PixelColor">
            <summary>
            Gets or sets the Color4 of the pixel.
            When setting the color, it is converted into BGRA byte values and written to texture memory.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.OnePixelTexture.ShaderResourceView">
            <summary>
            Gets the ShaderResourceView that represents a CubeMap and can be used in DirectX.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.OnePixelTexture.#ctor(SharpDX.Color4,Ab3d.DirectX.DXDevice,System.String)">
            <summary>
            Constructor with default texture format (B8G8R8A8_UNorm)
            </summary>
            <param name="pixelColor">initial Color4 of the pixel</param>
            <param name="dxDevice">DXDevice</param>
            <param name="name">optional name of the created resources</param>
        </member>
        <member name="M:Ab3d.DirectX.OnePixelTexture.#ctor(SharpDX.Color4,SharpDX.DXGI.Format,Ab3d.DirectX.DXDevice,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="pixelColor">initial Color4 of the pixel</param>
            <param name="dxgiFormat">DXGI format (only formats that are not bigger then 4 bytes are supported)</param>
            <param name="dxDevice">DXDevice</param>
            <param name="name">optional name of the created resources</param>
        </member>
        <member name="M:Ab3d.DirectX.OnePixelTexture.CreateOnePixelTexture(SharpDX.Direct3D11.Device,SharpDX.Color4,SharpDX.DXGI.Format)">
            <summary>
            CreateOnePixelTexture creates a 1 x 1 texture with the specified color (color is converted into BGRA byte values) and returns the texture as ShaderResourceView.
            </summary>
            <param name="device">DirectX 11 device</param>
            <param name="color">color as Color4</param>
            <param name="dxgiFormat">optional texture format (B8G8R8A8_UNorm by default)</param>
            <returns>ShaderResourceView for a 1x1 texture with specified color</returns>
        </member>
        <member name="M:Ab3d.DirectX.OnePixelTexture.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.OnePixelTexture.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.PositionNormal">
            <summary>
            PositionNormal is a struct used for vertex buffer that defines Position and Normal
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PositionNormal.#ctor(SharpDX.Vector3,SharpDX.Vector3)">
            <summary>
            Constructor
            </summary>
            <param name="position">position</param>
            <param name="normal">normal</param>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormal.Position">
            <summary>
            Position
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormal.Normal">
            <summary>
            Normal
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormal.SizeInFloats">
            <summary>
            Size in floats
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormal.SizeInBytes">
            <summary>
            Size in bytes
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PositionNormal.ToString">
            <summary>
            ToString
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Ab3d.DirectX.PositionNormalColor">
            <summary>
            PositionNormalTexture is a struct used for vertex buffer that defines Position, Normal and Color (as Color3).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PositionNormalColor.#ctor(SharpDX.Vector3,SharpDX.Vector3,SharpDX.Color3)">
            <summary>
            Constructor
            </summary>
            <param name="position">position</param>
            <param name="normal">normal</param>
            <param name="color">color</param>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormalColor.Position">
            <summary>
            Position
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormalColor.Normal">
            <summary>
            Normal
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormalColor.Color">
            <summary>
            Color as Color3
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormalColor.SizeInFloats">
            <summary>
            Size in floats
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormalColor.SizeInBytes">
            <summary>
            Size in bytes
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PositionNormalColor.ToString">
            <summary>
            ToString
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Ab3d.DirectX.PositionNormalTexture">
            <summary>
            PositionNormalTexture is a struct used for vertex buffer that defines Position, Normal and TextureCoordinate
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PositionNormalTexture.#ctor(SharpDX.Vector3,SharpDX.Vector3,SharpDX.Vector2)">
            <summary>
            Constructor
            </summary>
            <param name="position">position</param>
            <param name="normal">normal</param>
            <param name="textureCoordinate">textureCoordinate</param>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormalTexture.Position">
            <summary>
            Position
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormalTexture.Normal">
            <summary>
            Normal
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormalTexture.TextureCoordinate">
            <summary>
            TextureCoordinate
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormalTexture.SizeInFloats">
            <summary>
            Size in floats
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionNormalTexture.SizeInBytes">
            <summary>
            Size in bytes
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PositionNormalTexture.ToString">
            <summary>
            ToString
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Ab3d.DirectX.PositionTexture">
            <summary>
            PositionTexture is a struct used for vertex buffer that defines Position, TextureCoordinate
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PositionTexture.#ctor(SharpDX.Vector3,SharpDX.Vector2)">
            <summary>
            Constructor
            </summary>
            <param name="position">Position</param>
            <param name="textureCoordinate">TextureCoordinate</param>
        </member>
        <member name="M:Ab3d.DirectX.PositionTexture.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="x">x</param>
            <param name="y">y</param>
            <param name="z">z</param>
            <param name="u">u</param>
            <param name="v">v</param>
        </member>
        <member name="F:Ab3d.DirectX.PositionTexture.Position">
            <summary>
            Position
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionTexture.TextureCoordinate">
            <summary>
            TextureCoordinate
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionTexture.SizeInFloats">
            <summary>
            SizeInFloats
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionTexture.SizeInBytes">
            <summary>
            SizeInBytes
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PositionTexture.ToString">
            <summary>
            ToString
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Ab3d.DirectX.PositionTextureColor">
            <summary>
            PositionTextureColor is struct used for vertex buffer that defines Position, TextureCoordinate and Color
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PositionTextureColor.#ctor(SharpDX.Vector3,SharpDX.Vector2,SharpDX.Color4)">
            <summary>
            Constructor
            </summary>
            <param name="position">position</param>
            <param name="textureCoordinate">textureCoordinate</param>
            <param name="color">color</param>
        </member>
        <member name="M:Ab3d.DirectX.PositionTextureColor.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,SharpDX.Color4)">
            <summary>
            Constructor
            </summary>
            <param name="x">x</param>
            <param name="y">y</param>
            <param name="z">z</param>
            <param name="u">u</param>
            <param name="v">v</param>
            <param name="color">color</param>
        </member>
        <member name="F:Ab3d.DirectX.PositionTextureColor.Position">
            <summary>
            Position
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionTextureColor.TextureCoordinate">
            <summary>
            TextureCoordinate
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionTextureColor.Color">
            <summary>
            Color
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionTextureColor.SizeInFloats">
            <summary>
            Size in floats
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PositionTextureColor.SizeInBytes">
            <summary>
            Size in bytes
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PositionTextureColor.ToString">
            <summary>
            ToString
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Ab3d.DirectX.RenderingQueueSortingCompletedEventHandler">
            <summary>
            RenderingQueueSortingCompletedEventHandler is an event handler with <see cref="E:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.SortingCompleted" /> event.
            </summary>
            <param name="sender">sender</param>
            <param name="e">RenderingQueueSortingCompletedEventArgs</param>
        </member>
        <member name="T:Ab3d.DirectX.RenderingQueueSortingCompletedEventArgs">
            <summary>
            RenderingQueueSortingCompletedEventArgs is used for the <see cref="E:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.SortingCompleted" /> event.
            The event is called after the RenderingQueue is sorted.
            It allows the code in the event handler to change the order in which objects are rendered by changing the values in the <see cref="P:Ab3d.DirectX.RenderingQueueSortingCompletedEventArgs.SortedIndexes" /> array
            (note: use RenderablePrimitives.Count to get number of items because SortedIndexes.Length may be to big).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingQueueSortingCompletedEventArgs.RenderablePrimitives">
            <summary>
            Gets a list of RenderablePrimitive objects that are defined in the sorted RenderingQueue.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingQueueSortingCompletedEventArgs.SortedIndexes">
            <summary>
            Gets an array of indexes that define the sorted order of the RenderablePrimitives.
            To provide custom sort order the event handler may change the indexes in this array.
            IMPORTANT: Never use SortedIndexes.Length - this array may be bigger then required. To get count of items always use RenderablePrimitives.Count.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingQueueSortingCompletedEventArgs.#ctor(System.Collections.Generic.List{Ab3d.DirectX.RenderablePrimitive},System.Int32[])">
            <summary>
            Constructor
            </summary>
            <param name="renderablePrimitives">list of RenderablePrimitive objects</param>
            <param name="sortedIndexes">array of indexes that define the sorted order</param>
        </member>
        <member name="T:Ab3d.DirectX.RenderingStatistics">
            <summary>
            RenderingStatistics collects various rendering statistics for one rendered frame.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.FrameNumber">
            <summary>
            Gets the frame number for this RenderingStatistics.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.RenderingQueuesRecreateCount">
            <summary>
            Gets the number of times <see cref="P:Ab3d.DirectX.DXScene.RenderingQueues" /> were recreated.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.DrawCallsCount">
            <summary>
            Gets number of draw calls in this frame.
            This value can be incremented by calling <see cref="M:Ab3d.DirectX.RenderingStatistics.ReportDrawCall(System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.DrawnIndicesCount">
            <summary>
            Gets number of drawn triangle indices in this frame.
            This value can be incremented by calling <see cref="M:Ab3d.DirectX.RenderingStatistics.ReportDrawCall(System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.StateChangesCount">
            <summary>
            Gets number of state changes in this frame.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.ShaderChangesCount">
            <summary>
            Gets number of times shader was changed in this frame.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.VertexBuffersChangesCount">
            <summary>
            Gets number of times vertex buffer was changed in this frame.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.IndexBuffersChangesCount">
            <summary>
            Gets number of times index buffer was changed in this frame.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.ConstantBufferChangesCount">
            <summary>
            Gets number of times constant buffer was changed in this frame.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.CreatedCommandListsCount">
            <summary>
            Gets or sets a number of DirectX CommandList that were created in the last rendered frame.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.CachedCommandListsCount">
            <summary>
            Gets or sets a number of cached DirectX CammandLists that were created in one of the previous frame and executed in the last rendered frame.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.CachedRenderedObjectsCount">
            <summary>
            Gets or sets the total number of rendered objects (RenderablePrimitives) that were rendered in the cached DirectX CommandLists.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.UpdateTimeMs">
            <summary>
            Gets number of milliseconds that were needed to update all SceneNodes.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.TotalRenderTimeMs">
            <summary>
            Gets number of milliseconds that were needed for this frame to render.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.PrepareRenderTimeMs">
            <summary>
            Gets number of milliseconds that were needed to prepare the frame to be rendered (clear the buffers, initialize render targets and states, sort rendering queues by material or camera distance).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.RenderShadowsMs">
            <summary>
            Gets number of milliseconds that were needed to draw the shadow map and process it (for example apply blur for VarianceShadowMapping).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.DrawRenderTimeMs">
            <summary>
            Gets number of milliseconds that were needed to draw all objects for this frames (calling Draw methods and any needed state change methods).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.CompleteRenderTimeMs">
            <summary>
            Gets number of milliseconds that were needed to complete the rendering (resolve anti-aliasing, resolve stereoscopic images, calling Present on SwapChain (when using DirectXOverlay) or waiting for the graphics card to finish rendering the frame (when using DirectXImage)).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.PostProcessingRenderTimeMs">
            <summary>
            Gets number of milliseconds that were needed to render all post processing effects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.HitTestingTimeMs">
            <summary>
            Gets number of milliseconds that were used for hit testing.
            Note: this time is not automatically reset to zero when new frame is started (when calling <see cref="M:Ab3d.DirectX.RenderingStatistics.StartNewFrame(System.Int32)" /> or <see cref="M:Ab3d.DirectX.RenderingStatistics.ResetTimerValues" />).
            To show correct results, user needs to manually reset the time when the value is shown (this is done in the DiagnosticsWindow).
            </summary>
            <remarks>
                <para>
            Gets number of milliseconds that were used for hit testing.
            </para>
                <para>
            Note: this time is not automatically reset to zero when new frame is started (when calling <see cref="M:Ab3d.DirectX.RenderingStatistics.StartNewFrame(System.Int32)" /> or <see cref="M:Ab3d.DirectX.RenderingStatistics.ResetTimerValues" />).
            To show correct results, user needs to manually reset the time when the value is shown (this is done in the DiagnosticsWindow).
            </para>
                <para>
            If the HitTestingTimeMs would be reset in <see cref="M:Ab3d.DirectX.RenderingStatistics.StartNewFrame(System.Int32)" /> as other timers, then the hit testing that happened in user event handlers and
            than happened before <see cref="M:Ab3d.DirectX.DXScene.Update" /> method on DXScene is called would not be measured.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.UsedBackgroundThreadsCount">
            <summary>
            Gets the number of background threads that were used to render the frame. Zero means that all the objects were rendered on the main thread.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.RenderedObjectsCountPerThread">
            <summary>
            Gets or sets an array that shows how many objects were rendered by a specific thread (index = 0 means the main thread; other indexes means background threads).
            This array is set only when multi-threading is used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.RenderTimePerThread">
            <summary>
            Gets or sets an array that shows render times used on each thread (index = 0 means the main thread; other indexes means background threads).
            This array is set only when multi-threading is used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.Other">
            <summary>
            Gets a Dictionary with string as key and object as value that can be used to store custom rendering statistics.
            This dictionary is cleared on each start of frame.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStatistics.ElapsedTimeInMs">
            <summary>
            When called during frame rendering (between StartNewFrame and EndFrame calls) the elapsed time in milliseconds from the StartNewFrame call is returned.
            When called after EndFrame method is called, the TotalRenderTimeMs is returned.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStatistics.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStatistics.StartNewFrame(System.Int32)">
            <summary>
            StartNewFrame resets all the values in RenderingStatistics and start timer for new frame.
            </summary>
            <param name="frameNumber">frameNumber</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStatistics.ResetTimerValues">
            <summary>
            Sets all timer values to 0
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStatistics.ReportDrawCall(System.Int32)">
            <summary>
            Increased the <see cref="P:Ab3d.DirectX.RenderingStatistics.DrawCallsCount" /> by one and <see cref="P:Ab3d.DirectX.RenderingStatistics.DrawnIndicesCount" /> by drawnIndicesCount.
            This method is thread safe and can be called from any thread.
            </summary>
            <param name="drawnIndicesCount">drawnIndicesCount</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStatistics.ReportDrawCalls(System.Int32,System.Int32)">
            <summary>
            Increased the <see cref="P:Ab3d.DirectX.RenderingStatistics.DrawCallsCount" /> by drawCallsCount and <see cref="P:Ab3d.DirectX.RenderingStatistics.DrawnIndicesCount" /> by drawnIndicesCount.
            This method is thread safe and can be called from any thread.
            </summary>
            <param name="drawCallsCount">drawCallsCount</param>
            <param name="drawnIndicesCount">drawnIndicesCount</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStatistics.ReportStateChanges(Ab3d.DirectX.ContextStatesManager)">
            <summary>
            Adds state changes statistics from the contextStatesManager.
            This method is automatically called from <see cref="M:Ab3d.DirectX.RenderingStatistics.EndFrame(Ab3d.DirectX.RenderingContext)" /> for the main ContextStatesManager
            but needs to be called from the ContextStatesManager used in background threads.
            This method needs to be called from the main thread.
            </summary>
            <param name="contextStatesManager">ContextStatesManager</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStatistics.EndFrame(Ab3d.DirectX.RenderingContext)">
            <summary>
            EndFrame stops the timer.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStatistics.Clone">
            <summary>
            Returns a new RenderingStatistics with the same values as this RenderingStatistics.
            </summary>
            <returns>Clone of this RenderingStatistics</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStatistics.Copy(Ab3d.DirectX.RenderingStatistics)">
            <summary>
            Copies the values from this RenderingStatistics to targetRenderingStatistics.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.ShaderQuality">
            <summary>
            ShaderQuality enum specifies possible values for shader quality that define what kind of shaders should be used to render the scene.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ShaderQuality.Undefined">
            <summary>
            Shader quality is not defined (usually used in Material when the PreferedShaderQuality is not set). 
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ShaderQuality.Low">
            <summary>
            Low quality shaders are used - usually per vertex lighting is used. This shader quality setting has the best performance (hightes frames per second) but the lowest image quality.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ShaderQuality.Normal">
            <summary>
            Normal quality shaders are used - usually per pixel lighting is used.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ShaderQuality.High">
            <summary>
            High quality shaders are used. Note: DXEngine does not contain any high quality shaders. This means that when using shaders that come with DXEnige the results are the same as for Normal quality shader (but this setting can be used when custom shaders are used).
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.SupersamplingResolveFilterType">
            <summary>
            SupersamplingResolveFilterType enum defines possible filtering types that are used to down-sample a super-sampled texture.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SupersamplingResolveFilterType.None">
            <summary>
            Performs simple bilinear read from 2x2 pixels is used - no custom filter is used.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SupersamplingResolveFilterType.SquareFilterSize5">
            <summary>
            Performs 5 bilinear reads per destination pixel in a rotated grid fashion and a center pixel with increased weight.
            The area of read texels is 2 x 2 texels around the center texel. To use this filer with 4x4 down-sampling, set the TexelOffsetsScale to 2.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SupersamplingResolveFilterType.RotatedFilterSize5">
            <summary>
            Performs 5 bilinear reads per destination pixel in a rotated grid fashion and a center pixel with increased weight.
            The area of read texels is slightly bigger then 2 x 2 texels around the center texel.
            The result is smoother but slightly blurrier and in case of 3D lines slightly thicker lines. 
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SupersamplingResolveFilterType.RotatedFilterSize9">
            <summary>
            Performs 9 bilinear reads per destination pixel in a rotated grid fashion and a center pixel with increased weight.
            The area of read texels is slightly bigger then 4 x 4 texels around the center texel.
            The result is smoother but slightly blurrier and in case of 3D lines slightly thicker lines. 
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.TextureFilteringTypes">
            <summary>
            TextureFilteringTypes enum defines the common Texture filtering types.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureFilteringTypes.Point">
            <summary>
            Uses the color of the nearest neighboring pixel (produces square pixels when zoomed in).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureFilteringTypes.Bilinear">
            <summary>
            Uses the color that is linearly interpolated from the nearest colors from the texture.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureFilteringTypes.Trilinear">
            <summary>
            Uses the color that is linearly interpolated from the nearest colors from the two nearest mip map textures.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureFilteringTypes.Anisotropic_x2">
            <summary>
            Anisotropic filtering with level 2 (compared to linear interpolation Anisotropic filtering improves details when camera angle is low).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureFilteringTypes.Anisotropic_x4">
            <summary>
            Anisotropic filtering with level 4 (compared to linear interpolation Anisotropic filtering improves details when camera angle is low).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureFilteringTypes.Anisotropic_x8">
            <summary>
            Anisotropic filtering with level 8 (compared to linear interpolation Anisotropic filtering improves details when camera angle is low).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureFilteringTypes.Anisotropic_x16">
            <summary>
            Anisotropic filtering with level 16 (compared to linear interpolation Anisotropic filtering improves details when camera angle is low).
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.TextureInfo">
            <summary>
            TextureInfo defines some properties of the texture.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureInfo.Width">
            <summary>
            Width in pixels
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureInfo.Height">
            <summary>
            Height in pixels
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureInfo.DpiX">
            <summary>
            Dpi resolution in X direction. This value may not be set for some images (for example DDS images). In this case the value double.NaN.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureInfo.DpiY">
            <summary>
            Dpi resolution in Y direction. This value may not be set for some images (for example DDS images). In this case the value double.NaN.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureInfo.Format">
            <summary>
            DXGI image format
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureInfo.HasTransparency">
            <summary>
            True when the texture has transparent pixels.
            When using <see cref="T:Ab3d.DirectX.TextureLoader" /> then standard image files (all except DDS) are by default checked for transparent pixels.
            In this case this property is true if the image actually contains transparent pixels.
            For DDS file or when transparency check is disabled in TextureLoader, then this property assumes presence of transparent pixels based on the image format.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureInfo.HasPremultipliedAlpha">
            <summary>
            True if the bitmap is using a pre-multiplied alpha colors (rgb colors are multiplied by the alpha - for example a 50% transparent red color is: r=0.5, b=0, g=0, a=0.5).
            Usually this value is determined by the DGI format, except with DDS textures where the format defines the texture compression (DDS format) and does not specify if the colors are pre-multiplied by alpha.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.DisposableDXResource">
            <summary>
            DisposableDXResource class is a base class for DXEngine resources that can be disposed.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DisposableDXResource.IsDisposed">
            <summary>
            Gets a Boolean that specifies if this resource has been disposed.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DisposableDXResource.IsDisposing">
            <summary>
            Gets a Boolean that specifis if this resource is currently being disposed (the current code is executing inside Dipose method).
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.DisposableDXResource.Disposing">
            <summary>
            Occurs when when Dispose is called.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DisposableDXResource.disposables">
            <summary>
            Disposables can be used to simply add IDisposable objects to a list that is automatically disposed when this object is diposed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DisposableDXResource.#ctor">
            <summary>
            Initializes a new instance of the DXComponentBase class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DisposableDXResource.#ctor(System.String)">
            <summary>
            Initializes a new instance of the DXComponentBase class.
            </summary>
            <param name="name">name</param>
        </member>
        <member name="M:Ab3d.DirectX.DisposableDXResource.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DisposableDXResource.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.DXDeviceResource">
            <summary>
            DXDeviceResource class is a base class for all resources that are initialized by DXDevice.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDeviceResource.parentDXDevice">
            <summary>
            parent DXDevice
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDeviceResource.IsInitialized">
            <summary>
            Gets a Boolean that specifies if this resource has already been initialized.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXDeviceResource.#ctor">
            <summary>
            Initializes a new instance of the DXComponentBase class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXDeviceResource.#ctor(System.String)">
            <summary>
            Initializes a new instance of the DXComponentBase class.
            </summary>
            <param name="name">name</param>
        </member>
        <member name="M:Ab3d.DirectX.DXDeviceResource.InitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.DXDeviceResource.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.DXDeviceResource.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.DXResourceBase">
            <summary>
            DXResourceBase class is the base class for any DXEngine's resource
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXResourceBase.Name">
            <summary>
            Gets name of this resource
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXResourceBase.Id">
            <summary>
            Gets a unique id of this resource
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXResourceBase.ResourcesTracker">
            <summary>
            Gets a static instance of DXResourcesTracker that is used to track objects derived from DXResourceBase.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXResourceBase.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXResourceBase.#ctor">
            <summary>
            Initializes a new instance of the DXResourceBase class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXResourceBase.#ctor(System.String)">
            <summary>
            Initializes a new instance of the DXResourceBase class.
            </summary>
            <param name="name">name</param>
        </member>
        <member name="M:Ab3d.DirectX.DXResourceBase.GetNextId">
            <summary>
            Get next Id as long that is unique for this application. This method is thread safe and can be called from any thread.
            </summary>
            <returns>id as long</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXResourceBase.GetNextId(Ab3d.DirectX.IDXResource)">
            <summary>
            Get next Id as long that is unique for this application. 
            This method is thread safe and can be called from any thread.
            When ResourceTracking is enabled the dxResource is collected by DXResourcesTracker.
            </summary>
            <param name="dxResource">resource that will have this id (can be null). When ResourceTracking is enabled the this dxResource is collected by DXResourcesTracker.</param>
            <returns>id as long</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXResourceBase.CreateClone">
            <summary>
            Clones the current DXResourceBase with creating a shallow copy (properties are copied but referenced objects are preserved).
            The returned cloned objects gets a new Id.
            </summary>
            <returns>Cloned object created from the current object</returns>
        </member>
        <member name="T:Ab3d.DirectX.DXResourcesTracker">
            <summary>
            DXResourcesTracker collects classes that implement IDXResource and can report all colleced classes. Objects are collected with WeakReference.
            </summary>
            <remarks>
                <para>
                    <b>DXResourcesTracker</b> collects classes that implement <see cref="T:Ab3d.DirectX.IDXResource" /> and can report all colleced classes.
            </para>
                <para>
            It is used as a static <see cref="P:Ab3d.DirectX.DXResourceBase.ResourcesTracker" /> property in <see cref="T:Ab3d.DirectX.DXResourceBase" /> class. 
            If tracking is enabled, this static instance tracks all the objects that derive from DXResourceBase.
            Objects that derive from <see cref="T:Ab3d.DirectX.SharedDXResource" /> or <see cref="T:Ab3d.DirectX.SharedDXResourceWrapper`1" /> are also tracked.
            </para>
                <para>
            Resources tracking collects all the components in a WeakReference list.
            It is possible to get collection of all resources that were collected - their ids, object type, name, etc.
            </para>
                <para>
            To enable components tracking call the <see cref="M:Ab3d.DirectX.DXResourcesTracker.StartTrackingResources" /> method - for example:<br />
            Ab3d.DirectX.DXResourceBase.ResourcesTracker.StartTrackingResources();
            </para>
                <para>
            After the resources have been tracked, it is possible to get tracked resources by <see cref="M:Ab3d.DirectX.DXResourcesTracker.GetTrackedResources" />, <see cref="M:Ab3d.DirectX.DXResourcesTracker.GetTrackedResourcesReport(System.Boolean)" />
            or display the tracked resources in Visual Studio's Immediate Window with <see cref="M:Ab3d.DirectX.DXResourcesTracker.DumpTrackedResources(System.Boolean)" />.
            </para>
                <para>
            To track all resources this method must be called before any other object is created (for example before InitializeComponent in the application's main window).
            </para>
                <para>
            It is possible to stop tracking resources with <see cref="M:Ab3d.DirectX.DXResourcesTracker.StopTrackingResources" />.
            </para>
                <para>
            If you want to track your objects that implement <see cref="T:Ab3d.DirectX.IDXResource" /> interface but are not derived from <see cref="T:Ab3d.DirectX.DXResourceBase" />, <see cref="T:Ab3d.DirectX.SharedDXResource" /> or <see cref="T:Ab3d.DirectX.SharedDXResourceWrapper`1" />,
            than all you need to do to get your object tracked is to call the <see cref="M:Ab3d.DirectX.DXResourcesTracker.AddResource(Ab3d.DirectX.IDXResource)" /> method on the static <see cref="P:Ab3d.DirectX.DXResourceBase.ResourcesTracker" /> property.
            If you would also like to get the object Id, you can also call <see cref="M:Ab3d.DirectX.DXResourceBase.GetNextId" /> method and pass your object as parameter - when resource tracking is enabled your object will be also tracked.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXResourcesTracker.IsTrackingResources">
            <summary>
            Gets a boolean that specifies if tracking resources is enabled.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXResourcesTracker.StartTrackingResources">
            <summary>
            Starts tracking of resources.
            </summary>
            <remarks>
                <para>
                    <b>StartTrackingResources</b> starts tracking of resources.
            </para>
                <para>
            After the resources have been tracked, it is possible to get tracked resources by <see cref="M:Ab3d.DirectX.DXResourcesTracker.GetTrackedResources" />, <see cref="M:Ab3d.DirectX.DXResourcesTracker.GetTrackedResourcesReport(System.Boolean)" /> 
            or display the tracked resources in Visual Studio's Immediate Window with <see cref="M:Ab3d.DirectX.DXResourcesTracker.DumpTrackedResources(System.Boolean)" />.
            </para>
                <para>
            To track all resources this method must be called before any other object is created (for example before InitializeComponent in the application's main window).
            </para>
                <para>
            It is possible to stop tracking resources with <see cref="M:Ab3d.DirectX.DXResourcesTracker.StopTrackingResources" />.
            </para>
            </remarks>
        </member>
        <member name="M:Ab3d.DirectX.DXResourcesTracker.StopTrackingResources">
            <summary>
            Stop tracking resources.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXResourcesTracker.GetTrackedResources">
            <summary>
            Gets a list of IDXResources objects that were tracked while tracking was enabled and are still alive (garbage collector did not disposed them yet).
            </summary>
            <returns>list of IDXResources objects that were tracked while tracking was enabled and are still alive (garbage collector did not disposed them yet)</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXResourcesTracker.AddResource(Ab3d.DirectX.IDXResource)">
            <summary>
            Add IDXResource to the list of tracked resources.
            </summary>
            <param name="resources">IDXResource</param>
        </member>
        <member name="M:Ab3d.DirectX.DXResourcesTracker.GetTrackedResourcesReport(System.Boolean)">
            <summary>
            Gets a formatted string with tracked resources.
            </summary>
            <param name="showFullTypeName">If true than type namespace will be also added to type name</param>
            <returns>formatted string with tracked resources</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXResourcesTracker.DumpTrackedResources(System.Boolean)">
            <summary>
            Writes formatted string with tracked resources with the System.Diagnostics.Debug.WriteLine.
            </summary>
            <param name="showFullTypeName">If true than type namespace will be also added to type name</param>
        </member>
        <member name="T:Ab3d.DirectX.DXSceneResource">
            <summary>
            DXSceneResource class is a base class for all resources that are initialized by DXScene.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXSceneResource.parentDXScene">
            <summary>
            parent DXScene
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXSceneResource.IsInitialized">
            <summary>
            Gets a Boolean that specifies if this resource has already been initialized.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXSceneResource.InitializeResources(Ab3d.DirectX.DXScene)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxScene">Parent DXScene used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.DXSceneResource.OnInitializeResources(Ab3d.DirectX.DXScene)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxScene">Parent DXScene used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.DXSceneResource.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.IDisposableDXResource">
            <summary>
            IDisposableDXResource interface defines the IsDisposed property.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.IDisposableDXResource.IsDisposed">
            <summary>
            Gets a Boolean that specifies if this resource has been disposed.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.IDXDeviceResource">
            <summary>
            IDXDeviceResource interface defines properties and methods that are used by resources that are initialized by DXDevice.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.IDXDeviceResource.IsInitialized">
            <summary>
            Gets a Boolean that specifies if this resource has already been initialized.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.IDXDeviceResource.InitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">DXDevice used to initialize resources</param>
        </member>
        <member name="T:Ab3d.DirectX.IDXResource">
            <summary>
            IDXResource interface defines base properties for any DXEngine's resource
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.IDXResource.Name">
            <summary>
            Gets name of this resource
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.IDXResource.Id">
            <summary>
            Gets a unique id of this resource
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.IDXSceneResource">
            <summary>
            IDXSceneResource interface defines properties and methods that are used by resources that are initialized by DXScene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.IDXSceneResource.IsInitialized">
            <summary>
            Gets a Boolean that specifies if this resource has already been initialized.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.IDXSceneResource.InitializeResources(Ab3d.DirectX.DXScene)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxScene">Parent DXScene used to initialize resources</param>
        </member>
        <member name="T:Ab3d.DirectX.ISharedDXResource">
            <summary>
            ISharedDXResource interface defines properties that are used for reference counted resources that can be shared by many difference objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ISharedDXResource.ReferencesCount">
            <summary>
            Gets an integer that specifies the references count for this resource.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ISharedDXResource.AddRef">
            <summary>
            Increases reference count on this resource.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ISharedDXResource.DisposeAllReferences">
            <summary>
            Disposes this object regardless of the count of references.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.SharedDXDeviceResource">
            <summary>
            SharedDXDeviceResource class is a base class for DXEngine's resources that are initialized by DXDevice and can be shared by many difference objects.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SharedDXDeviceResource.parentDXDevice">
            <summary>
            parent DXDevice
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SharedDXDeviceResource.IsInitialized">
            <summary>
            Gets a Boolean that specifies if this resource has already been initialized.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SharedDXDeviceResource.ParentDXDevice">
            <summary>
            Gets the DXDevice that was used to initialize this SharedDXDeviceResource
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXDeviceResource.#ctor">
            <summary>
            Initializes a new instance of the DXComponentBase class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXDeviceResource.#ctor(System.String)">
            <summary>
            Initializes a new instance of the DXComponentBase class.
            </summary>
            <param name="name">name</param>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXDeviceResource.InitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">dxDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXDeviceResource.IsSameDXDevice(Ab3d.DirectX.DXDevice)">
            <summary>
            Return true if the resource has been initialized with the same dxDevice.
            Note that when the dxDevice from parameter or the parentDXDevice is null, this method returns false.
            </summary>
            <param name="dxDevice">DXDevice to check</param>
            <returns>true if the resource has been initialized with the same dxDevice</returns>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXDeviceResource.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXDeviceResource.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.SharedDXResource">
            <summary>
            SharedDXResource class is a base class for DXEngine's resources that can be shared by many difference objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SharedDXResource.IsDisposed">
            <summary>
            Gets a Boolean that specifies if this resource has been disposed.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SharedDXResource.IsDisposing">
            <summary>
            Gets a Boolean that specifies if this resources is currently being disposed (Dispose method has already been called but is not yet finished).
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.SharedDXResource.Disposing">
            <summary>
            Occurs when when Dispose is called.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SharedDXResource.disposables">
            <summary>
            Disposables can be used to simply add IDisposable objects to a list that is automatically disposed when this object is diposed.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SharedDXResource.ReferencesCount">
            <summary>
            Gets an integer that specifies the references count for this resource.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXResource.AddRef">
            <summary>
            Increases reference count on this resource.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXResource.#ctor">
            <summary>
            Initializes a new instance of the SharedDXResource class and sets ReferencesCount to 1.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXResource.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SharedDXResource class and sets ReferencesCount to 1.
            </summary>
            <param name="name">name</param>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXResource.Dispose">
            <summary>
            Dispose method decreases the reference count of this object. When reference count gets to zero, this object is disposed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXResource.DisposeAllReferences">
            <summary>
            Disposes this object regardless of the count of references.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXResource.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.SharedDXResourceWrapper`1">
            <summary>
            SharedDXResourceWrapper class is a generic wrapper class that can wrap any IDisposable object and adds reference counting to it.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Ab3d.DirectX.SharedDXResourceWrapper`1.IsDisposed">
            <summary>
            Gets a Boolean that specifies if this resource has been disposed.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SharedDXResourceWrapper`1.ReferencesCount">
            <summary>
            Gets an integer that specifies the references count for the Resource.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SharedDXResourceWrapper`1.Resource">
            <summary>
            Gets the shared resource.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXResourceWrapper`1.#ctor(`0,System.String)">
            <summary>
            Creates a shared resource and sets ReferencesCount to 1.
            </summary>
            <param name="resource">stared resource instance</param>
            <param name="name">name of the shared resource</param>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXResourceWrapper`1.AddRef">
            <summary>
            Increases reference count on this resource.
            </summary>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXResourceWrapper`1.Dispose">
            <summary>
            Dispose method decreases the reference count of this object. When reference count gets to zero, this object is disposed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXResourceWrapper`1.DisposeAllReferences">
            <summary>
            Disposes this object regardless of the count of references.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXResourceWrapper`1.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.SharedDXSceneResource">
            <summary>
            SharedDXSceneResource class is a base class for DXEngine's resources that are initialized by DXScene and can be shared by many difference objects.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SharedDXSceneResource.parentDXScene">
            <summary>
            parent DXScene
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SharedDXSceneResource.IsInitialized">
            <summary>
            Gets a Boolean that specifies if this resource has already been initialized.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXSceneResource.InitializeResources(Ab3d.DirectX.DXScene)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxScene">Parent DXScene used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXSceneResource.OnInitializeResources(Ab3d.DirectX.DXScene)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxScene">Parent DXScene used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.SharedDXSceneResource.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.AssemblyShaderBytecodeProvider">
            <summary>
            AssemblyShaderBytecodeProvider class provides access to compiled shaders stored as embedded resources in an assembly.
            The class can be registered by <see cref="T:Ab3d.DirectX.EffectsManager" /> with calling its <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResource(System.String,System.Byte[])" /> or <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResourceStatic(Ab3d.DirectX.ShaderBytecodeProvider)" /> methods.
            This way the EffectsManager will be able to get shader resources (bytecode) from the resources provided by this class.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.AssemblyShaderBytecodeProvider.ResourceAssembly">
            <summary>
            Gets an assembly that was used to create this AssemblyShaderResources
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.AssemblyShaderBytecodeProvider.ResourceRootName">
            <summary>
            Gets string that specifies the root name of the shaders
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.AssemblyShaderBytecodeProvider.#ctor(System.Reflection.Assembly,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="resourceAssembly">an assembly that was used to create this AssemblyShaderResources</param>
            <param name="resourceRootName">string that specifies the root name of the shaders</param>
        </member>
        <member name="M:Ab3d.DirectX.AssemblyShaderBytecodeProvider.GetShaderBytecode(System.String)">
            <summary>
            Gets bytes array of the compiled shader with resourceName or null if this class instance does not have this resource.
            </summary>
            <param name="resourceName">name of the resource</param>
            <returns>bytes array of the compiled shader or null if this instance does not have this resource</returns>
        </member>
        <member name="M:Ab3d.DirectX.AssemblyShaderBytecodeProvider.Equals(System.Object)">
            <summary>
            Overridden Equals compares this instance with obj by refrence and also by uses the same assembly and root name
            </summary>
            <param name="obj">obj</param>
            <returns>true if obj is equal by reference or is AssemblyShaderBytecodeProvider with the same assembly and root name</returns>
        </member>
        <member name="M:Ab3d.DirectX.AssemblyShaderBytecodeProvider.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current AssemblyShaderBytecodeProvider.
            </returns>
        </member>
        <member name="M:Ab3d.DirectX.AssemblyShaderBytecodeProvider.GetAllResourceNames">
            <summary>
            Returns an array of strings that represents the resource names available in this ShaderBytecodeProvider.
            </summary>
            <returns>an array of strings that represents the resource names available in this ShaderBytecodeProvider</returns>
        </member>
        <member name="T:Ab3d.DirectX.DictionaryShaderBytecodeProvider">
            <summary>
            DictionaryShaderBytecodeProvider class provides access to shaders stored in a simple dictionary with shader name as key and its bytecode (byte array of compiled shader) as values.
            The class can be registered by <see cref="T:Ab3d.DirectX.EffectsManager" /> with calling its <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResource(System.String,System.Byte[])" /> or <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResourceStatic(Ab3d.DirectX.ShaderBytecodeProvider)" /> methods.
            This way the EffectsManager will be able to get shader resources (bytecode) from the resources provided by this class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DictionaryShaderBytecodeProvider.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DictionaryShaderBytecodeProvider.AddShaderBytecode(System.String,System.Byte[])">
            <summary>
            AddShaderBytecode add the shader name (specified as resourceName) with its bytecode to the shaders dictionary defined in this DictionaryShaderBytecodeProvider.
            If you add resourceName that was already added before, the old resourceName bytecode is overwritten by the new bytecode.
            This method is thread safe and can be called from any thread.
            </summary>
            <param name="resourceName">shader name</param>
            <param name="bytecode">byte array with compiled shader bytes</param>
        </member>
        <member name="M:Ab3d.DirectX.DictionaryShaderBytecodeProvider.GetShaderBytecode(System.String)">
            <summary>
            Gets bytes array of the compiled shader with resourceName or null if this class instance does not have this resource.
            </summary>
            <param name="resourceName">name of the resource</param>
            <returns>bytes array of the compiled shader or null if this instance does not have this resource</returns>
        </member>
        <member name="M:Ab3d.DirectX.DictionaryShaderBytecodeProvider.GetAllResourceNames">
            <summary>
            Returns an array of strings that represents the resource names available in this ShaderBytecodeProvider.
            </summary>
            <returns>an array of strings that represents the resource names available in this ShaderBytecodeProvider</returns>
        </member>
        <member name="T:Ab3d.DirectX.DirectoryShaderBytecodeProvider">
            <summary>
            DirectoryShaderBytecodeProvider class provides access to shaders stored as files in the specified directory on disk.
            Resources registered by this DirectoryShaderBytecodeProvider are available by file name with extension but without directory path.
            The class can be registered by <see cref="T:Ab3d.DirectX.EffectsManager" /> with calling its <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResource(System.String,System.Byte[])" /> or <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResourceStatic(Ab3d.DirectX.ShaderBytecodeProvider)" /> methods.
            This way the EffectsManager will be able to get shader resources (bytecode) from the resources provided by this class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DirectoryShaderBytecodeProvider.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DirectoryShaderBytecodeProvider.RefreshFiles">
            <summary>
            Refreshes the list of files in the directory. This method is thread safe.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DirectoryShaderBytecodeProvider.GetShaderBytecode(System.String)">
            <summary>
            Gets bytes array of the compiled shader with resourceName or null if this class instance does not have this resource.
            </summary>
            <param name="resourceName">name of the resource</param>
            <returns>bytes array of the compiled shader or null if this instance does not have this resource</returns>
        </member>
        <member name="M:Ab3d.DirectX.DirectoryShaderBytecodeProvider.GetAllResourceNames">
            <summary>
            Returns an array of strings that represents the resource names available in this ShaderBytecodeProvider.
            </summary>
            <returns>an array of strings that represents the resource names available in this ShaderBytecodeProvider</returns>
        </member>
        <member name="T:Ab3d.DirectX.Effect">
            <summary>
            Effect is a base class for all effects that can render a mesh (vertex and index buffer) with the material that defines the properties that defined the effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effect.RequiredInputLayoutType">
            <summary>
            Gets the input layout that is required to render this effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effect.LastUsedFrameNumber">
            <summary>
            Gets the frame number when the ApplyPerFrameSettings was last called.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effect.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">effect name</param>
        </member>
        <member name="M:Ab3d.DirectX.Effect.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Applies the material and object's world matrix to this effect.
            </summary>
            <remarks>
                <para>
                    <b>ApplyMaterial</b> applies the material and object's world matrix to this effect.
            </para>
                <para>
            Usually effects define two constant buffers:<br />
            - one that is can be changed only once per frame and contains data about lights,<br />
            - one that is different for each material and object.
            </para>
                <para>
            The first constant buffer is set by calling <see cref="M:Ab3d.DirectX.Effect.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method.
            </para>
                <para>
            The second constant buffer can be set by calling <see cref="M:Ab3d.DirectX.Effect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)" /> method.
            This sets properties defined in Material.
            It also sets projection matrices like world_view_projection and others.
            The device states (blend state, rasterizer state, etc.) are also set there.
            </para>
            </remarks>
            <param name="material">Material</param>
            <param name="renderableGeometry">object that the material is applied for (usually RenderablePrimitive).</param>
        </member>
        <member name="M:Ab3d.DirectX.Effect.PreloadShaders">
            <summary>
            PreloadShaders can be called to load the shaders in advance before they are used.
            Calling this method increases the startup time, but when the 3D object needs to be shown, it is shown faster because all the shaders have already been created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effect.ResetLastUsedFrameNumber">
            <summary>
            ResetLastUsedFrameNumber sets LastUsedFrameNumber to -1. This is used to prevent calling ApplyPerFrameSettings when this effect is used multiple times with different lights on one frame.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.EffectsManager">
            <summary>
            EffectsManager class help use the <see cref="T:Ab3d.DirectX.Effect" /> classes.
            It provides loading, caching and reusing the effects and shaders.
            All access to effects and shaders is thread safe.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.EffectsManager.vertexShadersCache">
            <summary>
            vertexShadersCache
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.EffectsManager.pixelShadersCache">
            <summary>
            pixelShadersCache
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.EffectsManager.geometryShadersCache">
            <summary>
            geometryShadersCache
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.EffectsManager.inputLayoutCache">
            <summary>
            inputLayoutCache
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.EffectsManager.EffectsCount">
            <summary>
            Gets a number of registered effects
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.EffectsManager.Effects">
            <summary>
            Gets a readonly collection of all registered effects
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.EffectsManager.IsCustomStandardEffect">
            <summary>
            Gets a Boolean that specifies if a custom standard effect was registered.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.EffectsManager.EffectRegistered">
            <summary>
            EffectRegistered event is fired when a new effect is registered
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.RegisterShaderResource(Ab3d.DirectX.ShaderBytecodeProvider)">
            <summary>
            Registers newShaderResource as source for shaders code. Returns true if resource was registered, false if the same resource was already registered.
            This method is the same as static <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResourceStatic(Ab3d.DirectX.ShaderBytecodeProvider)" /> method.
            </summary>
            <param name="newShaderResource">shader resource as ShaderResourceBase</param>
            <returns>true if resource was registered, false if the same resource was already registered</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.RegisterShaderResourceStatic(Ab3d.DirectX.ShaderBytecodeProvider)">
            <summary>
            Registers newShaderResource as source for shaders code.
            Returns true if resource was registered, false if the same resource was already registered.
            This method is the same as non-static <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResource(Ab3d.DirectX.ShaderBytecodeProvider)" /> method.
            </summary>
            <param name="newShaderBytecodeProvider">shader resource as ShaderResourceBase</param>
            <returns>true if resource was registered, false if the same resource was already registered</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.RegisterShaderResource(System.String,System.Byte[])">
            <summary>
            Registers the specified resourceName and its bytes array as a source for the shaders bytecode.
            Returns true if resource was registered, false if the same resource was already registered.
            This method is the same as static <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResourceStatic(System.String,System.Byte[])" /> method.
            </summary>
            <param name="resourceName">resource name</param>
            <param name="shaderBytecode">shader bytecode as bytes array</param>
            <returns>true if resource was registered, false if the same resource was already registered</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.RegisterShaderResourceStatic(System.String,System.Byte[])">
            <summary>
            Registers the specified resourceName and its bytes array as a source for the shaders bytecode.
            Returns true if resource was registered, false if the same resource was already registered.
            This method is the same as non-static <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResource(System.String,System.Byte[])" /> method.
            </summary>
            <param name="resourceName">resource name</param>
            <param name="shaderBytecode">shader bytecode as bytes array</param>
            <returns>true if resource was registered, false if the same resource was already registered</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.UnregisterShaderResource(Ab3d.DirectX.ShaderBytecodeProvider)">
            <summary>
            Unregisters shaderResource as source for shaders code. Returns true if resource was unregistered, false if the this resource was not registered and was therefore not unregistered.
            This method is the same as static <see cref="M:Ab3d.DirectX.EffectsManager.UnregisterShaderResourceStatic(Ab3d.DirectX.ShaderBytecodeProvider)" /> method.
            </summary>
            <param name="shaderResource">shader resource as ShaderResourceBase</param>
            <returns>true if resource was unregistered, false if the this resource was not registered and was therefore not unregistered</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.UnregisterShaderResourceStatic(Ab3d.DirectX.ShaderBytecodeProvider)">
            <summary>
            Unregisters shaderResource as source for shaders code. Returns true if resource was unregistered, false if the this resource was not registered and was therefore not unregistered.
            This method is the same as non-static <see cref="M:Ab3d.DirectX.EffectsManager.UnregisterShaderResource(Ab3d.DirectX.ShaderBytecodeProvider)" /> method.
            </summary>
            <param name="shaderBytecodeProvider">shader resource as ShaderResourceBase</param>
            <returns>true if resource was unregistered, false if the this resource was not registered and was therefore not unregistered</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.UnregisterShaderResource(System.String)">
            <summary>
            Unregisters the specified resourceName from the list of registered shader resources (resource that was previously registered by <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResource(System.String,System.Byte[])" /> or <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResourceStatic(System.String,System.Byte[])" />.
            Returns true if resource was unregistered, false if the this resource was not registered and was therefore not unregistered.
            This method is the same as static <see cref="M:Ab3d.DirectX.EffectsManager.UnregisterShaderResourceStatic(System.String)" /> method.
            </summary>
            <param name="resourceName">resource name</param>
            <returns>true if resource was unregistered, false if the this resource was not registered and was therefore not unregistered</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.UnregisterShaderResourceStatic(System.String)">
            <summary>
            Unregisters the specified resourceName from the list of registered shader resources (resource that was previously registered by <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResource(System.String,System.Byte[])" /> or <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResourceStatic(System.String,System.Byte[])" />.
            Returns true if resource was unregistered, false if the this resource was not registered and was therefore not unregistered.
            This method is the same as non-static <see cref="M:Ab3d.DirectX.EffectsManager.UnregisterShaderResource(System.String)" /> method.
            </summary>
            <param name="resourceName">resource name</param>
            <returns>true if resource was unregistered, false if the this resource was not registered and was therefore not unregistered</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.GetRegisteredShaderResourceNames">
            <summary>
            Returns an array of strings of all registered resource names.
            This method is the same as static <see cref="M:Ab3d.DirectX.EffectsManager.GetRegisteredShaderResourceNamesStatic" /> method.
            </summary>
            <returns>an array of strings of all registered resource names</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.GetRegisteredShaderResourceNamesStatic">
            <summary>
            Returns an array of strings of all registered resource names.
            </summary>
            <returns>an array of strings of all registered resource names</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.GetShaderBytes(System.String,System.Boolean)">
            <summary>
            Gets bytes array of the shader byte code. Before using this method, the shader resources need to be registered with <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResource(Ab3d.DirectX.ShaderBytecodeProvider)" /> method.
            </summary>
            <remarks>
                <para>
            Gets bytes array of the shader byte code. Before using this method, the shader resources need to be registered with <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResource(Ab3d.DirectX.ShaderBytecodeProvider)" /> method.
            </para>
                <para>
            EffectsManager by default registers the Ab3d.DXEngine assembly as an <see cref="T:Ab3d.DirectX.AssemblyShaderBytecodeProvider" /> that can provide many shaders stored as embedded resources in Ab3d.DXEngine assembly.
            </para>
                <para>
            You can register custom shader resources by creating your own instances of <see cref="T:Ab3d.DirectX.AssemblyShaderBytecodeProvider" />, <see cref="T:Ab3d.DirectX.FileShaderBytecodeProvider" /> or <see cref="T:Ab3d.DirectX.DirectoryShaderBytecodeProvider" /> or any other class that is derived from <see cref="T:Ab3d.DirectX.ShaderBytecodeProvider" />.
            </para>
            </remarks>
            <param name="resourceName">shader resource name</param>
            <param name="throwExceptionIfNotFound">if true than exception will be thrown when resourceName is not found; when false null is returned in this case</param>
            <exception name="throwExceptionIfNotFound">specifies if exception is found when the shader with resourceName cannot be found. If false (by default) and resource is not found, than null is returned.</exception>
            <returns>bytes array of the shader byte code</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.RegisterEffect(Ab3d.DirectX.Effect)">
            <summary>
            Registers the effect with EffectManager. Each used effect must be registered. Registering effect will also initialize it (called InitializeResources) if the effect was not initialized yet.
            </summary>
            <remarks>
                <para>
                    <b>RegisterEffect</b> registers the effect with EffectManager. Each used effect must be registered.
            </para>
            </remarks>
            <param name="effect">Effect</param>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.GetEffect``1(System.Boolean,System.Boolean)">
            <summary>
            Gets an effect by its type T (by default the type must exactly match the type T and no derived class is matched; this is controller by an optional parameter exactlyMatchType).
            If the effect was not yet registered by EffectsManager and if createNewEffectInstanceIfNotFound is true,
            then a new instance of effect T is created, registered with EffectsManager and returned.
            To get StandardEffect (effect that can render all possible lights), use <see cref="M:Ab3d.DirectX.EffectsManager.GetStandardEffect" /> method.
            NOTE: When the returned effect is not used any more, user must call Dispose (reference count is increased in GetEffect method).
            </summary>
            <param name="createNewEffectInstanceIfNotFound">if true (by default) and if type T is not found (already registered) then a new instance of the type T is created and registered by EffectsManager</param>
            <param name="exactlyMatchType">when true (by default) the effect type must exactly match the specified type T - no derived class is matched.</param>
            <returns>Effect with specified name.</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.GetEffect(System.String)">
            <summary>
            Gets an effect by its name (using ordinal ignore case comparison). The effect must be registered before it can be get with GetEffect. If the effect is not found null is returned.
            To get StandardEffect (effect that can render all possible lights), use <see cref="M:Ab3d.DirectX.EffectsManager.GetStandardEffect" /> method.
            NOTE: User must call Dispose on the get effect (reference count is increased in GetEffect method).
            </summary>
            <param name="effectName">name of the effect to return.</param>
            <returns>Effect with specified name.</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.IsEffectRegistered(System.String)">
            <summary>
            Returns Boolean that specifies if the effect with effectName was already registered with this EffectsManager.
            </summary>
            <param name="effectName">name of the effect</param>
            <returns>Boolean that specifies if the effect with effectName was already registered with this EffectsManager</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.GetStandardEffect">
            <summary>
            Gets a StandardEffect that can render many different lights and all standard materials.
            NOTE: User must call Dispose on the get effect (reference count is increased in GetEffect method).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.SetStandardEffect(Ab3d.DirectX.Effect)">
            <summary>
            Sets a StandardEffect that can render many different lights and all standard materials.
            If newStandardEffect is not yet registered by EffectsManager then this method also registers the newStandardEffect.
            </summary>
            <param name="newStandardEffect">Effect that will be used as standard rendering effect</param>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.GetStandardSpriteEffect">
            <summary>
            Gets the SpriteEffect that is set as standard sprite effect. User need to dispose the returned SpriteEffect when it is not used any more.
            </summary>
            <returns>SpriteEffect</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.GetVertexShader(System.String,SharpDX.Direct3D11.InputElement[],Ab3d.DirectX.SharedDXResourceWrapper{SharpDX.Direct3D11.InputLayout}@,System.Boolean)">
            <summary>
            GetVertexShader returns a SharedDXResourceWrapper with VertexShader specified by the vertexShaderResourceName.
            </summary>
            <param name="vertexShaderResourceName">name of the resource</param>
            <param name="vertexLayoutDesc">vertex layout description as array of InputElements</param>
            <param name="inputLayoutSharedResource">out SharedDXResourceWrapper with InputLayout</param>
            <param name="throwExceptionIfNotFound">if true and exception is thrown if shader is not found; else null is returned</param>
            <returns>SharedDXResourceWrapper with VertexShader</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.GetPixelShader(System.String,System.Boolean)">
            <summary>
            GetPixelShader returns a SharedDXResourceWrapper with PixelShader specified by the pixelShaderResourceName.
            </summary>
            <param name="pixelShaderResourceName">name of the resource</param>
            <param name="throwExceptionIfNotFound">if true and exception is thrown if shader is not found; else null is returned</param>
            <returns>SharedDXResourceWrapper with PixelShader</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.GetGeometryShader(System.String,System.Boolean)">
            <summary>
            GetGeometryShader returns a SharedDXResourceWrapper with GeometryShader specified by the pixelShaderResourceName.
            </summary>
            <param name="geometryShaderResourceName">name of the resource</param>
            <param name="throwExceptionIfNotFound">if true and exception is thrown if shader is not found; else null is returned</param>
            <returns>SharedDXResourceWrapper with PixelShader</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.GetShaders(System.String,System.String,SharpDX.Direct3D11.InputElement[],Ab3d.DirectX.SharedDXResourceWrapper{SharpDX.Direct3D11.VertexShader}@,Ab3d.DirectX.SharedDXResourceWrapper{SharpDX.Direct3D11.PixelShader}@,Ab3d.DirectX.SharedDXResourceWrapper{SharpDX.Direct3D11.InputLayout}@,System.Boolean)">
            <summary>
            GetShaders loads vertex shader, pixel shader and creates an InputLayout from the specified resource names
            </summary>
            <param name="vertexShaderResourceName">vertex shader resource name</param>
            <param name="pixelShaderResourceName">pixel shader resource name</param>
            <param name="vertexLayoutDesc">vertex layout description as array of InputElements</param>
            <param name="vertexShaderSharedResource">out SharedDXResourceWrapper with VertexShader</param>
            <param name="pixelShaderSharedResource">out SharedDXResourceWrapper with PixelShader</param>
            <param name="inputLayoutSharedResource">out SharedDXResourceWrapper with InputLayout</param>
            <param name="throwExceptionIfShadersNotFound">if true and exception is thrown if shader is not found; else null is returned</param>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.GetShaders(System.String,System.String,System.String,SharpDX.Direct3D11.InputElement[],Ab3d.DirectX.SharedDXResourceWrapper{SharpDX.Direct3D11.VertexShader}@,Ab3d.DirectX.SharedDXResourceWrapper{SharpDX.Direct3D11.GeometryShader}@,Ab3d.DirectX.SharedDXResourceWrapper{SharpDX.Direct3D11.PixelShader}@,Ab3d.DirectX.SharedDXResourceWrapper{SharpDX.Direct3D11.InputLayout}@,System.Boolean)">
            <summary>
            GetShaders loads vertex shader, geometry shader, pixel shader and creates an InputLayout from the specified resource names
            </summary>
            <param name="vertexShaderResourceName">vertex shader resource name</param>
            <param name="geometryShaderResourceName">geometry shader resource name</param>
            <param name="pixelShaderResourceName">pixel shader resource name</param>
            <param name="vertexLayoutDesc">vertex layout description as array of InputElements</param>
            <param name="vertexShaderSharedResource">out SharedDXResourceWrapper with VertexShader</param>
            <param name="geometryShaderSharedResource">out SharedDXResourceWrapper with GeometryShader</param>
            <param name="pixelShaderSharedResource">out SharedDXResourceWrapper with PixelShader</param>
            <param name="inputLayoutSharedResource">out SharedDXResourceWrapper with InputLayout</param>
            <param name="throwExceptionIfShadersNotFound">if true and exception is thrown if shader is not found; else null is returned</param>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.ClearAllCachedShader">
            <summary>
            Clears all cached shaders that were created by the GetXXXShader method.
            After this method is called, the shaders will be created again (useful when shader bytecode is changed).
            To remove only one shader from the cache, use the <see cref="M:Ab3d.DirectX.EffectsManager.ClearShaderCache(System.String)" /> method.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.ClearShaderCache(System.String)">
            <summary>
            Clears the cached shader that was created by the GetXXXShader method.
            After this method is called, the shader with shaderName will be created again when needed (useful when shader bytecode is changed).
            To clear all caches shaders, use the <see cref="M:Ab3d.DirectX.EffectsManager.ClearAllCachedShader" /> method.
            </summary>
            <param name="shaderName">resourceName of the shader</param>
            <returns>true if shaderName was found and its cache was removed</returns>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.OnEffectRegistered(Ab3d.DirectX.Effect)">
            <summary>
            OnEffectRegistered
            </summary>
            <param name="registeredEffect">registeredEffect</param>
        </member>
        <member name="M:Ab3d.DirectX.EffectsManager.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Effects.EnvironmentalMapEffect">
            <summary>
            InstancedObjectsEffect is an effect that can render many instances of one mesh geometry.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Effects.EnvironmentalMapEffect.EffectName">
            <summary>
            Effect name
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.EnvironmentalMapEffect.RequiredInputLayoutType">
            <summary>
            Gets the input layout that is required to render this effect.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.EnvironmentalMapEffect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.EnvironmentalMapEffect.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this effect.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.EnvironmentalMapEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.EnvironmentalMapEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Applies the material and object's world matrix to this effect.
            </summary>
            <remarks>
                <para>
                    <b>ApplyMaterial</b> applies the material and object's world matrix to this effect.
            </para>
                <para>
            Usually effects define two constant buffers:<br />
            - one that is can be changed only once per frame and contains data about lights,<br />
            - one that is different for each material and object.
            </para>
                <para>
            The first constant buffer is set by calling <see cref="M:Ab3d.DirectX.Effects.EnvironmentalMapEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method.
            </para>
                <para>
            The second constant buffer can be set by calling <see cref="M:Ab3d.DirectX.Effects.EnvironmentalMapEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)" /> method.
            This sets properties defined in Material.
            It also sets projection matrixes like world_view_projection and others.
            The device states (blend state, rasterizer state, etc.) are also set there.
            </para>
            </remarks>
            <param name="material">Material</param>
            <param name="renderableGeometry">object that the material is applied for (usually RenderablePrimitive).</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.EnvironmentalMapEffect.PreloadShaders">
            <summary>
            PreloadShaders can be called to load the shaders in advance before they are used.
            Calling this method increases the startup time, but when the 3D object needs to be shown, it is shown faster because all the shaders have already been created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.EnvironmentalMapEffect.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Effects.InstancedObjectsEffect">
            <summary>
            InstancedObjectsEffect is an effect that can render many instances of one mesh geometry.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Effects.InstancedObjectsEffect.EffectName">
            <summary>
            Effect name
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.InstancedObjectsEffect.RequiredInputLayoutType">
            <summary>
            Gets the input layout that is required to render this effect.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.InstancedObjectsEffect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.InstancedObjectsEffect.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this effect.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.InstancedObjectsEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.InstancedObjectsEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Applies the material and object's world matrix to this effect.
            </summary>
            <remarks>
                <para>
                    <b>ApplyMaterial</b> applies the material and object's world matrix to this effect.
            </para>
                <para>
            Usually effects define two constant buffers:<br />
            - one that is can be changed only once per frame and contains data about lights,<br />
            - one that is different for each material and object.
            </para>
                <para>
            The first constant buffer is set by calling <see cref="M:Ab3d.DirectX.Effects.InstancedObjectsEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method.
            </para>
                <para>
            The second constant buffer can be set by calling <see cref="M:Ab3d.DirectX.Effects.InstancedObjectsEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)" /> method.
            This sets properties defined in Material.
            It also sets projection matrixes like world_view_projection and others.
            The device states (blend state, rasterizer state, etc.) are also set there.
            </para>
            </remarks>
            <param name="material">Material</param>
            <param name="renderableGeometry">object that the material is applied for (usually RenderablePrimitive).</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.InstancedObjectsEffect.PreloadShaders">
            <summary>
            PreloadShaders can be called to load the shaders in advance before they are used.
            Calling this method increases the startup time, but when the 3D object needs to be shown, it is shown faster because all the shaders have already been created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.InstancedObjectsEffect.IsUsingPerPixelShader(Ab3d.DirectX.ShaderQuality)">
            <summary>
            Returns true when per pixel shader should be used for specified shader quality.
            </summary>
            <param name="shaderQuality">shaderQuality</param>
            <returns>true when per pixel shader should be used for specified shader quality</returns>
        </member>
        <member name="M:Ab3d.DirectX.Effects.InstancedObjectsEffect.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Effects.ModelColorLineEffect">
            <summary>
            ModelColorLineEffect is an effect that is similar to ThickLineEffect but instead rendering lines with fixed and predefined color
            the line color is based on the color of the model that the line is created for.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Effects.ModelColorLineEffect.EffectName">
            <summary>
            Effect name
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.ModelColorLineEffect.LineThickness">
            <summary>
            Gets or sets the thickness of the line in screen space units.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.ModelColorLineEffect.ReadZBuffer">
            <summary>
            Gets or sets a Boolean that specifies if Z buffer is read when rendering the line - if the depth test is done when rendering the line.
            If false then the line is rendered regardless of its depth - if is rendered even if it is behind some other 3D objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.ModelColorLineEffect.WriteZBuffer">
            <summary>
            Gets or sets a Boolean that specifies if Z buffer is written when rendering the line - if the line can occlude other 3D objects.
            If true then the objects behind the line will not be rendered. If false the line will not prevent rendering objects behind it.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.ModelColorLineEffect.DepthBias">
            <summary>
            Gets or sets a float that specifies a bias that is used when doing a depth test.
            A bias is a value that is added to the line's depth value and can provide a small offset from another object to prevent Z-fighting that occurs when two objects have almost the same depth values.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.ModelColorLineEffect.DefaultLineColor">
            <summary>
            Color of the line that is used when the color cannot be determined from WPF material
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.ModelColorLineEffect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.ModelColorLineEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Applies the material and object's world matrix to this effect.
            </summary>
            <remarks>
                <para>
                    <b>ApplyMaterial</b> applies the material and object's world matrix to this effect.
            </para>
                <para>
            Usually effects define two constant buffers:<br />
            - one that is can be changed only once per frame and contains data about lights,<br />
            - one that is different for each material and object.
            </para>
                <para>
            The first constant buffer is set by calling <see cref="M:Ab3d.DirectX.Effect.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method.
            </para>
                <para>
            The second constant buffer can be set by calling <see cref="M:Ab3d.DirectX.Effects.ModelColorLineEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)" /> method.
            This sets properties defined in Material.
            It also sets projection matrixes like world_view_projection and others.
            The device states (blend state, rasterizer state, etc.) are also set there.
            </para>
            </remarks>
            <param name="material">Material</param>
            <param name="renderableGeometry">object that the material is applied for (usually RenderablePrimitive).</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.ModelColorLineEffect.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect">
            <summary>
            PhysicallyBasedRenderingEffect is an effect that can render materials defined with physically based rendering properties - e.g. base color, metalness, roughness, emissive map, normal map and ambient occlusion textures.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect.EffectName">
            <summary>
            Effect name
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect.ShadowThreshold">
            <summary>
            Gets or sets a float value that helps prevent light bleeding (having areas that should be in shadow fully illuminated) for variance shadow mapping.
            </summary>
            <remarks>
                <para>
            Gets or sets a float value that helps prevent light bleeding (having areas that should be in shadow fully illuminated) for variance shadow mapping.
            </para>
                <para>
            The value is used to map all shadow values from 0 ... ShadowThreshold to 0 and then linearly rescale the values from ShadowThreshold to 1 into 0 to 1.
            </para>
                <para>
            For more info see "Shadow bleeding" in "Chapter 8. Summed-Area Variance Shadow Maps" (https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch08.html)
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect.ShadowTreshold">
            <summary>
            Gets or sets a float value that helps prevent light bleeding (having areas that should be in shadow fully illuminated) for variance shadow mapping.
            </summary>
            <remarks>
                <para>
            Gets or sets a float value that helps prevent light bleeding (having areas that should be in shadow fully illuminated) for variance shadow mapping.
            </para>
                <para>
            The value is used to map all shadow values from 0 ... ShadowThreshold to 0 and then linearly rescale the values from ShadowThreshold to 1 into 0 to 1.
            </para>
                <para>
            For more info see "Shadow bleeding" in "Chapter 8. Summed-Area Variance Shadow Maps" (https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch08.html)
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect.ShadowDepthBias">
            <summary>
            Gets or sets a float value that offsets the depth of the lights (distance from the lights to the object) and
            can help reduce the show artifacts in the corners. The value that works best need to be set based on the size of the scene. Default value is 0 that does not apply any bias.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect.RequiredInputLayoutType">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect.SetShadowMappingParameters(Ab3d.DirectX.ShadowLightData[],Ab3d.DirectX.RenderingContext)">
            <summary>
            SetShadowMappingParameters sets parameters needed for shadow mapping.
            </summary>
            <param name="shadowLightsData">array of ShadowLightData - one element for each light</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect.PreloadShaders">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.Effects.PhysicallyBasedRenderingEffect.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.Effects.PixelEffect">
            <summary>
            PixelEffect is an effect that is using geometry shader to create and render many pixels (small rectangles) in 3D world.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.PixelEffect.PixelSize">
            <summary>
            Gets or sets a float value that specifies the size of the pixel that is used when the size is not specified by the material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.PixelEffect.PixelColor">
            <summary>
            Gets or sets a Color4 value that specifies the color of the pixel that is used when the color is not specified by the material.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Effects.PixelEffect.EffectName">
            <summary>
            EffectName
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.PixelEffect.RequiredInputLayoutType">
            <summary>
            Gets the input layout that is required to render this effect.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.PixelEffect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.PixelEffect.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="effectName">effectName</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.PixelEffect.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.PixelEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.PixelEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Applies the material and object's world matrix to this effect.
            </summary>
            <remarks>
                <para>
                    <b>ApplyMaterial</b> applies the material and object's world matrix to this effect.
            </para>
                <para>
            Usually effects define two constant buffers:<br />
            - one that is can be changed only once per frame and contains data about lights,<br />
            - one that is different for each material and object.
            </para>
                <para>
            The first constant buffer is set by calling <see cref="M:Ab3d.DirectX.Effect.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method.
            </para>
                <para>
            The second constant buffer can be set by calling <see cref="M:Ab3d.DirectX.Effects.PixelEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)" /> method.
            This sets properties defined in Material.
            It also sets projection matrixes like world_view_projection and others.
            The device states (blend state, rasterizer state, etc.) are also set there.
            </para>
            </remarks>
            <param name="material">Material</param>
            <param name="renderableGeometry">object that the material is applied for (usually RenderablePrimitive).</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.PixelEffect.PreloadShaders">
            <summary>
            PreloadShaders can be called to load the shaders in advance before they are used.
            Calling this method increases the startup time, but when the 3D object needs to be shown, it is shown faster because all the shaders have already been created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.PixelEffect.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Effects.SolidColorEffect">
            <summary>
            SolidColorEffect is an effect that renders the mesh geometry with specified color that is not affected (changed) by the lights in the scene.
            This effect can also expand the rendered objects in the direction of the normal to create an outline effect.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Effects.SolidColorEffect.EffectName">
            <summary>
            Effect name
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.SolidColorEffect.OverrideModelColor">
            <summary>
            When true then the <see cref="P:Ab3d.DirectX.Effects.SolidColorEffect.Color" /> is used to render all the 3D models.
            When false (by default) the color defined in the model's material is used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.SolidColorEffect.OverrideBlendState">
            <summary>
            When OverrideBlendState is set then SolidColorEffect will use that blend state.
            When null (by default) then Opaque blend state is used when Alpha is 1, and PremultipliedAlphaBlend is used when Alpha is less then 1 (in this case the color components are also multiplied with alpha value to produce pre-multiplied colors).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.SolidColorEffect.OverrideRasterizerState">
            <summary>
            When OverrideRasterizerState is set then SolidColorEffect will use this rasterizer state, for example to disable object culling use <see cref="P:Ab3d.DirectX.CommonStates.CullNone" />.
            When null (by default) then back-face or front-face culling is used based on the geometry and material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.SolidColorEffect.PremultiplyAlphaColors">
            <summary>
            When PremultiplyAlphaColors is true (by default) and Alpha is less then 1, then the color components are also multiplied with alpha value to produce pre-multiplied colors.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.SolidColorEffect.OutlineThickness">
            <summary>
            Gets or sets a float that specifies the thickness of the outline that is created with expanding the objects in the direction of the normal.
            The value is specified in screen-space units. Default value is 0 that does not produce any outline.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.SolidColorEffect.DepthBias">
            <summary>
            A DepthBias is a value that specifies how much the line is moved closer to the camera. The value is specified in world coordinates.
            Default value is 0.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.SolidColorEffect.WriteMaxDepthValue">
            <summary>
            When true then the models are rendered to the back of the scene so that all other rendered objects will be rendered before them.
            This can be used to outline all selected objects without rendering selection lines between them.
            When false (by default) the models are rendered to their correct depth.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.SolidColorEffect.AddAmbientColor">
            <summary>
            When true then ambient light color is added to the color. False by default.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.SolidColorEffect.Color">
            <summary>
            Gets or sets a Color4 that is used to render all 3D models when <see cref="P:Ab3d.DirectX.Effects.SolidColorEffect.OverrideModelColor" /> property is set to true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.SolidColorEffect.RequiredInputLayoutType">
            <summary>
            Gets the input layout that is required to render this effect.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SolidColorEffect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SolidColorEffect.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this effect.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SolidColorEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SolidColorEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Applies the material and object's world matrix to this effect.
            </summary>
            <remarks>
                <para>
                    <b>ApplyMaterial</b> applies the material and object's world matrix to this effect.
            </para>
                <para>
            Usually effects define two constant buffers:<br />
            - one that is can be changed only once per frame and contains data about lights,<br />
            - one that is different for each material and object.
            </para>
                <para>
            The first constant buffer is set by calling <see cref="M:Ab3d.DirectX.Effects.SolidColorEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method.
            </para>
                <para>
            The second constant buffer can be set by calling <see cref="M:Ab3d.DirectX.Effects.SolidColorEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)" /> method.
            This sets properties defined in Material.
            It also sets projection matrices like world_view_projection and others.
            The device states (blend state, rasterizer state, etc.) are also set there.
            </para>
            </remarks>
            <param name="material">Material</param>
            <param name="renderableGeometry">object that the material is applied for (usually RenderablePrimitive).</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SolidColorEffect.PreloadShaders">
            <summary>
            PreloadShaders can be called to load the shaders in advance before they are used.
            Calling this method increases the startup time, but when the 3D object needs to be shown, it is shown faster because all the shaders have already been created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SolidColorEffect.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Effects.SpriteEffect">
            <summary>
            SpriteEffect is a base abstract class that can render 2D sprites to the scene. 
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.SpriteEffect.RequiredInputLayoutType">
            <summary>
            Gets the input layout that is required to render this effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.SpriteEffect.LastUsedFrameNumber">
            <summary>
            Gets the frame number when the ApplyPerFrameSettings was last called.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SpriteEffect.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">effect name</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SpriteEffect.ApplyPerFrameSettings(Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SpriteEffect.OnApplyPerFrameSettings(Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SpriteEffect.ApplyBatchSettings(System.Boolean,SharpDX.Matrix@,SharpDX.Direct3D11.BlendState,SharpDX.Direct3D11.SamplerState,SharpDX.Direct3D11.DepthStencilState,SharpDX.Direct3D11.RasterizerState)">
            <summary>
            Applies the setting that are used to render one sprite batch
            </summary>
            <param name="isTransformMatrixIdentity"></param>
            <param name="transformMatrix">transformMatrix</param>
            <param name="blendState">blendState</param>
            <param name="samplerState">samplerState</param>
            <param name="depthStencilState">depthStencilState</param>
            <param name="rasterizerState">rasterizerState</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SpriteEffect.ApplyTextureSetting(SharpDX.Direct3D11.ShaderResourceView)">
            <summary>
            Applies the setting that are used to sprites with the same texture
            </summary>
            <param name="texture">texture</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SpriteEffect.PreloadShaders">
            <summary>
            PreloadShaders can be called to load the shaders in advance before they are used.
            Calling this method increases the startup time, but when the 3D object needs to be shown, it is shown faster because all the shaders have already been created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.SpriteEffect.ResetLastUsedFrameNumber">
            <summary>
            ResetLastUsedFrameNumber sets LastUsedFrameNumber to -1. This is used to prevent calling ApplyPerFrameSettings when this effect is used multiple times with different lights on one frame.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Effects.StandardEffect">
            <summary>
            StandardEffect is an effect that can render the mesh geometry with the standard material.
            Standard material can define diffuse color and diffuse texture, specular color and power and emissive color.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Effects.StandardEffect.EffectName">
            <summary>
            EffectName
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.StandardEffect.RequiredInputLayoutType">
            <summary>
            Gets the input layout that is required to render this effect.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this effect.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Applies the material and object's world matrix to this effect.
            </summary>
            <remarks>
                <para>
                    <b>ApplyMaterial</b> applies the material and object's world matrix to this effect.
            </para>
                <para>
            Usually effects define two constant buffers:<br />
            - one that is can be changed only once per frame and contains data about lights,<br />
            - one that is different for each material and object.
            </para>
                <para>
            The first constant buffer is set by calling <see cref="M:Ab3d.DirectX.Effects.StandardEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method.
            </para>
                <para>
            The second constant buffer can be set by calling <see cref="M:Ab3d.DirectX.Effects.StandardEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)" /> method.
            This sets properties defined in Material.
            It also sets projection matrixes like world_view_projection and others.
            The device states (blend state, rasterizer state, etc.) are also set there.
            </para>
            </remarks>
            <param name="material">Material</param>
            <param name="renderableGeometry">object that the material is applied for (usually RenderablePrimitive).</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.PreloadShaders">
            <summary>
            PreloadShaders can be called to load the shaders in advance before they are used.
            Calling this method increases the startup time, but when the 3D object needs to be shown, it is shown faster because all the shaders have already been created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.SetCustomPerFrameConstantBuffers(SharpDX.Direct3D11.Buffer,SharpDX.Direct3D11.Buffer)">
            <summary>
            SetCustomPerFrameConstantBuffers sets custom perFrameCameraConstantsBuffer and perFrameLightsConstantBuffer.
            Note that the constant buffers need to be exactly the same as the DirectionalLightShader or SuperShader expects.
            </summary>
            <param name="perFrameCameraConstantsBuffer">perFrameCameraConstantsBuffer or null to use constant buffer from this shader (when null, then the currently used perFrameCameraConstantsBuffer is not changed)</param>
            <param name="perFrameLightsConstantBuffer">perFrameLightsConstantBuffer or null to use constant buffer from this shader (when null, then the currently used perFrameLightsConstantBuffer is not changed)</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.IsUsingSuperShader(System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight})">
            <summary>
            IsUsingSuperShader method return true if SuperShader is needed to render the specified lights. When false is returned than DirectionalLightShader can render the scene.
            This method also creates the needed shader (SuperShader or DirectionalLightShader) if is was not yet created.
            </summary>
            <param name="lights">list of lights</param>
            <returns>true if SuperShader is needed to render the specified lights; when false is returned than DirectionalLightShader can render the scene</returns>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.GetSuperShader">
            <summary>
            Returns and instance of SuperShader that is used by this StandardEffect. 
            The method increases reference count on SuperShader. This means that the returned instance must be disposed when it is not used any more.
            </summary>
            <returns>SuperShader</returns>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.GetDirectionalLightShader">
            <summary>
            Returns and instance of DirectionalLightShader that is used by this StandardEffect. 
            The method increases reference count on DirectionalLightShader. This means that the returned instance must be disposed when it is not used any more.
            </summary>
            <returns>DirectionalLightShader</returns>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.ResetRenderableGeometryMaterialFlagsValue">
            <summary>
            When RenderableGeometry objects are rendered in the same order in each frame,
            the RenderableGeometry.MaterialFlags value specifies how similar the material is
            to the previous object (for example if diffuse part is the same, then many color checks can be skipped).
            But when the order of rendering is changed or if we start rendering from the middle
            of the RenderingQueue, then we need to reset the cached value for the
            first rendered RenderableGeometry so that all the checks are done again.
            This method does that.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.IsUsingPerPixelShader(Ab3d.DirectX.ShaderQuality)">
            <summary>
            Returns true when per pixel shader should be used for specified shader quality.
            </summary>
            <param name="shaderQuality">shaderQuality</param>
            <returns>true when per pixel shader should be used for specified shader quality</returns>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.GetRequiredRenderingPassesCount(System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Gets number of passes required to render this effect.
            </summary>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.ApplyRenderingPass(System.Int32,Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets the constant buffers and prepares all the shader states for rendering the specfied rendering pass. Before this method is called the OnApplyPerFrameSettings method must be called to set other frame settings.
            </summary>
            <param name="renderingPassIndex">zero based rendering pass index</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardEffect.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Effects.StandardSpriteEffect">
            <summary>
            StandardSpriteEffect is an effect that can render 2D sprites to the scene.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Effects.StandardSpriteEffect.EffectName">
            <summary>
            Effect name
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.StandardSpriteEffect.RequiredInputLayoutType">
            <summary>
            Gets the input layout that is required to render this effect.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardSpriteEffect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardSpriteEffect.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this effect.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardSpriteEffect.PreloadShaders">
            <summary>
            PreloadShaders can be called to load the shaders in advance before they are used.
            Calling this method increases the startup time, but when the 3D object needs to be shown, it is shown faster because all the shaders have already been created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardSpriteEffect.OnApplyPerFrameSettings(Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardSpriteEffect.ApplyBatchSettings(System.Boolean,SharpDX.Matrix@,SharpDX.Direct3D11.BlendState,SharpDX.Direct3D11.SamplerState,SharpDX.Direct3D11.DepthStencilState,SharpDX.Direct3D11.RasterizerState)">
            <summary>
            Applies the setting that are used to render one sprite batch
            </summary>
            <param name="isTransformMatrixIdentity">true if transformMatrix is identity (used to improve performance)</param>
            <param name="transformMatrix">transformMatrix</param>
            <param name="blendState">blendState</param>
            <param name="samplerState">samplerState</param>
            <param name="depthStencilState">depthStencilState</param>
            <param name="rasterizerState">rasterizerState</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardSpriteEffect.ApplyTextureSetting(SharpDX.Direct3D11.ShaderResourceView)">
            <summary>
            Applies the setting that are used to sprites with the same texture
            </summary>
            <param name="texture">texture</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.StandardSpriteEffect.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Effects.ThickLineEffect">
            <summary>
            ThickLineEffect is an effect that is using geometry shader to create and render 3D lines with specified line thickness.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Effects.ThickLineEffect.NoPatternLinePattern">
            <summary>
            NoPatternLinePattern defines a line pattern that represents a solid line without any spaces. It value is 0xFFFF.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Effects.ThickLineEffect.EffectName">
            <summary>
            EffectName
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.ThickLineEffect.UseGeometryShader">
            <summary>
            Gets or sets a boolean that specifes if geometry shader is used to render the lines.
            Note that if DXScene.UseGeometryShaderFor3DLines is set to false, that this will override the value of UseGeometryShader property.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.ThickLineEffect.CustomWireframeRasterizerState">
            <summary>
            Gets or sets a RasterizerState that can be used when 3D lines are drawn without using geometry shader.
            If not set then DxDevice.CommonStates.WireframeMultisample is used.
            </summary>
            <remarks>
                <para>
                    <b>CustomWireframeRasterizerState</b> gets or sets a RasterizerState that can be used when 3D lines are drawn without using geometry shader.
            </para>
                <para>
            If CustomWireframeRasterizerState is null then DxDevice.CommonStates.WireframeMultisample is used.
            </para>
                <para>
            Using other states from DxDevice.CommonStates has the following effect:<br />
            WireframeMultisample - shows all lines antialiased (when showing huge number of lines can be significantly slower then showing non-antialiased lines)<br />
            WireframeCullNone - shows all lines without antialiasing<br />
            WireframeCullClockwise - hides hidden lines without antialiasing<br />
            WireframeCullCounterClockwise - shows only hidden lines without antialiasing<br /></para>
                <para>
            It is also possible to set any custom state to CustomWireframeRasterizerState.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.Effects.ThickLineEffect.OverrideBlendState">
            <summary>
            When OverrideBlendState is set then ThickLineEffect will use that blend state.
            When null (by default) then Opaque blend state is used when lines's alpha color is 1, and NonPremultipliedAlphaBlend is used when alpha color is less then 1.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.ThickLineEffect.RequiredInputLayoutType">
            <summary>
            Gets the input layout that is required to render this effect.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.ThickLineEffect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.ThickLineEffect.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="effectName">effectName</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.ThickLineEffect.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.ThickLineEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.ThickLineEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Applies the material and object's world matrix to this effect.
            </summary>
            <remarks>
                <para>
                    <b>ApplyMaterial</b> applies the material and object's world matrix to this effect.
            </para>
                <para>
            Usually effects define two constant buffers:<br />
            - one that is can be changed only once per frame and contains data about lights,<br />
            - one that is different for each material and object.
            </para>
                <para>
            The first constant buffer is set by calling <see cref="M:Ab3d.DirectX.Effect.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method.
            </para>
                <para>
            The second constant buffer can be set by calling <see cref="M:Ab3d.DirectX.Effects.ThickLineEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)" /> method.
            This sets properties defined in Material.
            It also sets projection matrixes like world_view_projection and others.
            The device states (blend state, rasterizer state, etc.) are also set there.
            </para>
            </remarks>
            <param name="material">Material</param>
            <param name="renderableGeometry">object that the material is applied for (usually RenderablePrimitive).</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.ThickLineEffect.PreloadShaders">
            <summary>
            PreloadShaders can be called to load the shaders in advance before they are used.
            Calling this method increases the startup time, but when the 3D object needs to be shown, it is shown faster because all the shaders have already been created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.ThickLineEffect.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Effects.VertexColorEffect">
            <summary>
            VertexColorEffect is an effect that can render 3D models with specifying different color for each models vertex (position).
            The vertex colors are provides with <see cref="T:Ab3d.DirectX.Materials.IVertexColorMaterial" />.
            </summary>
            <remarks>
                <para>
                    <b>VertexColorEffect</b> is an effect that can render 3D models with specifying different color for each models vertex (position).
            </para>
                <para>
            The vertex colors are provides with <see cref="T:Ab3d.DirectX.Materials.IVertexColorMaterial" />.
            </para>
                <para>
            VertexColorEffect support only ambient light and up to three directional lights.
            It does not support point or spot lights.
            </para>
            </remarks>
        </member>
        <member name="F:Ab3d.DirectX.Effects.VertexColorEffect.EffectName">
            <summary>
            Effect name
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Effects.VertexColorEffect.RequiredInputLayoutType">
            <summary>
            Gets the input layout that is required to render this effect.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.VertexColorEffect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.VertexColorEffect.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this effect.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.VertexColorEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.VertexColorEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Applies the material and object's world matrix to this effect.
            </summary>
            <remarks>
                <para>
                    <b>ApplyMaterial</b> applies the material and object's world matrix to this effect.
            </para>
                <para>
            Usually effects define two constant buffers:<br />
            - one that is can be changed only once per frame and contains data about lights,<br />
            - one that is different for each material and object.
            </para>
                <para>
            The first constant buffer is set by calling <see cref="M:Ab3d.DirectX.Effects.VertexColorEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method.
            </para>
                <para>
            The second constant buffer can be set by calling <see cref="M:Ab3d.DirectX.Effects.VertexColorEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)" /> method.
            This sets properties defined in Material.
            It also sets projection matrixes like world_view_projection and others.
            The device states (blend state, rasterizer state, etc.) are also set there.
            </para>
            </remarks>
            <param name="material">Material</param>
            <param name="renderableGeometry">object that the material is applied for (usually RenderablePrimitive).</param>
        </member>
        <member name="M:Ab3d.DirectX.Effects.VertexColorEffect.PreloadShaders">
            <summary>
            PreloadShaders can be called to load the shaders in advance before they are used.
            Calling this method increases the startup time, but when the 3D object needs to be shown, it is shown faster because all the shaders have already been created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Effects.VertexColorEffect.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.FileShaderBytecodeProvider">
            <summary>
            FileShaderBytecodeProvider class provides access to shaders stored as files in file system.
            The class can be registered by <see cref="T:Ab3d.DirectX.EffectsManager" /> and can be used to generate shaders from the files registered by this class.
            Before the files can be accessed, the files must be registered by <see cref="M:Ab3d.DirectX.FileShaderBytecodeProvider.AddResourceFile(System.String,System.String)" />, <see cref="M:Ab3d.DirectX.FileShaderBytecodeProvider.AddResourceFile(System.String)" /> or <see cref="M:Ab3d.DirectX.FileShaderBytecodeProvider.AddResourceFiles(System.Collections.Generic.IEnumerable{System.String})" />.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.FileShaderBytecodeProvider.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.FileShaderBytecodeProvider.AddResourceFile(System.String,System.String)">
            <summary>
            AddResourceFile registers the resourceName and associates it with the specified fullFileNameWithPath. This method is thread safe.
            </summary>
            <param name="resourceName">resourceName</param>
            <param name="fullFileNameWithPath">file name with full path to the file</param>
            <exception cref="T:System.IO.FileNotFoundException">exception is thrown when the file does not exist</exception>
        </member>
        <member name="M:Ab3d.DirectX.FileShaderBytecodeProvider.AddResourceFile(System.String)">
            <summary>
            AddResourceFile registers the file specified with fullFileNameWithPath with resource name that is generated from the file name (with extention).  This method is thread safe.
            </summary>
            <param name="fullFileNameWithPath">file name with full path to the file</param>
        </member>
        <member name="M:Ab3d.DirectX.FileShaderBytecodeProvider.AddResourceFiles(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            AddResourceFiles registers files specified in fileNames enumerable collection. This method is thread safe.
            </summary>
            <param name="fileNames">IEnumerable of file names</param>
        </member>
        <member name="M:Ab3d.DirectX.FileShaderBytecodeProvider.GetShaderBytecode(System.String)">
            <summary>
            Gets bytes array of the compiled shader with resourceName or null if this class instance does not have this resource.
            </summary>
            <param name="resourceName">name of the resource</param>
            <returns>bytes array of the compiled shader or null if this instance does not have this resource</returns>
        </member>
        <member name="M:Ab3d.DirectX.FileShaderBytecodeProvider.GetAllResourceNames">
            <summary>
            Returns an array of strings that represents the resource names available in this ShaderBytecodeProvider.
            </summary>
            <returns>an array of strings that represents the resource names available in this ShaderBytecodeProvider</returns>
        </member>
        <member name="T:Ab3d.DirectX.IMultiPassEffect">
            <summary>
            IMultiPassEffect interface provides methods that are used for effect with multiple rendering passes.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.IMultiPassEffect.GetRequiredRenderingPassesCount(System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Gets number of passes required to render this effect.
            </summary>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.IMultiPassEffect.ApplyRenderingPass(System.Int32,Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets the constant buffers and prepares all the shader states for rendering the specified rendering pass. Before this method is called the OnApplyPerFrameSettings method must be called to set other frame settings.
            </summary>
            <param name="renderingPassIndex">zero based rendering pass index</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="T:Ab3d.DirectX.ShaderBytecodeProvider">
            <summary>
            ShaderBytecodeProvider is an abstract class that is a base class for all classes that represent the source of shader byte code.
            The <see cref="T:Ab3d.DirectX.EffectsManager" /> uses the <see cref="M:Ab3d.DirectX.ShaderBytecodeProvider.GetShaderBytecode(System.String)" /> to get the requested shader resource by its name.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ShaderBytecodeProvider.GetShaderBytecode(System.String)">
            <summary>
            Gets bytes array of the compiled shader with resourceName or null if this class instance does not have this resource.
            </summary>
            <param name="resourceName">name of the resource</param>
            <returns>bytes array of the compiled shader or null if this instance does not have this resource</returns>
        </member>
        <member name="M:Ab3d.DirectX.ShaderBytecodeProvider.GetAllResourceNames">
            <summary>
            Returns an array of strings that represents the resource names available in this ShaderBytecodeProvider.
            </summary>
            <returns>an array of strings that represents the resource names available in this ShaderBytecodeProvider</returns>
        </member>
        <member name="T:Ab3d.DirectX.SimpleShaderBytecodeProvider">
            <summary>
            SimpleShaderBytecodeProvider class provides access to one shader bytecode with a specified resource name.
            The class can be registered by <see cref="T:Ab3d.DirectX.EffectsManager" /> with calling its <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResource(System.String,System.Byte[])" /> or <see cref="M:Ab3d.DirectX.EffectsManager.RegisterShaderResourceStatic(Ab3d.DirectX.ShaderBytecodeProvider)" /> methods.
            This way the EffectsManager will be able to get shader resources (bytecode) from the resources provided by this class.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SimpleShaderBytecodeProvider.ResourceName">
            <summary>
            Gets the name of the shader resource
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SimpleShaderBytecodeProvider.Bytecode">
            <summary>
            Gets the bytecode as a byte array.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SimpleShaderBytecodeProvider.#ctor(System.String,System.Byte[])">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SimpleShaderBytecodeProvider.GetShaderBytecode(System.String)">
            <summary>
            Gets bytes array of the compiled shader with resourceName or null if this class instance does not have this resource.
            </summary>
            <param name="resourceName">name of the resource</param>
            <returns>bytes array of the compiled shader or null if this instance does not have this resource</returns>
        </member>
        <member name="M:Ab3d.DirectX.SimpleShaderBytecodeProvider.GetAllResourceNames">
            <summary>
            Returns an array of strings that represents the resource names available in this ShaderBytecodeProvider.
            </summary>
            <returns>an array of strings that represents the resource names available in this ShaderBytecodeProvider</returns>
        </member>
        <member name="T:Ab3d.DirectX.BackBufferReadyEventHandler">
            <summary>
            BackBufferReadyEventHandler is used to describe the BackBufferReady event handler
            </summary>
            <param name="sender">object</param>
            <param name="e">BackBufferReadyEventArgs</param>
        </member>
        <member name="T:Ab3d.DirectX.BackBufferReadyEventArgs">
            <summary>
            BackBufferReadyEventArgs is an event handler that is used for the BackBufferReady event.
            BackBufferReady event is fired when the scene is rendered to back buffer that is ready to be mapped and copy from graphics card to system memory.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.BackBufferReadyEventArgs.Width">
            <summary>
            Width of back buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.BackBufferReadyEventArgs.Height">
            <summary>
            Height of back buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.BackBufferReadyEventArgs.Format">
            <summary>
            Format of back buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.BackBufferReadyEventArgs.Data">
            <summary>
            BackBuffer Data as SharpDX DataBox
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.BackBufferReadyEventArgs.IsRegisteredForBackBufferMapping">
            <summary>
            Boolean that can be set to false by the subscriber of the <see cref="T:Ab3d.DirectX.BackBufferReadyEventHandler" /> to unregister from being called on the next frame.
            </summary>
            <remarks>
                <para>
            IsRegisteredForBackBufferMapping is a Boolean that is set to true by default.
            The subscriber of the <see cref="T:Ab3d.DirectX.BackBufferReadyEventHandler" /> can set it to false to unregister from being called on the next frame.
            </para>
                <para>
            This simplifies scenarios when only one frame is captured. 
            With setting the IsRegisteredForBackBufferMapping to false, the subscribed does not need to call the <see cref="M:Ab3d.DirectX.RenderingContext.UnregisterBackBufferMapping(Ab3d.DirectX.BackBufferReadyEventHandler)" /> method and does not need to provide the delegate as a method.
            </para>
            </remarks>
        </member>
        <member name="M:Ab3d.DirectX.BackBufferReadyEventArgs.#ctor(System.Int32,System.Int32,SharpDX.DXGI.Format,SharpDX.DataBox)">
            <summary>
            Constructor
            </summary>
            <param name="width">width</param>
            <param name="height">height</param>
            <param name="format">format</param>
            <param name="data">data</param>
        </member>
        <member name="T:Ab3d.DirectX.CameraDistanceSortedRenderingQueue">
            <summary>
            CameraDistanceSortedRenderingQueue is rendering queue where the objects inside the queue are sorted by their distance from the camera.
            This is uses for transparent object that need to be rendered so that the objects that are more far away from the camera are rendered first.
            See remarks for more info.
            </summary>
            <remarks>
                <para>
            CameraDistanceSortedRenderingQueue is rendering queue where the objects inside the queue are sorted by their distance from the camera.
            This is uses for transparent object that need to be rendered so that the objects that are more far away from the camera are rendered first.
            </para>
                <para>
            The CameraDistanceSortedRenderingQueue uses a highly optimized quick sort algorithm.
            This algorithm is not a stable sort algorithm. This means that objects with the same sort value can change their positions (for example if A, B and C have the same value, then sort may return them in a different order as initially defined).
            Because of this it may happen that when a 3D objects is rendered with its back and front face materials, then sometimes the order of those two materials can change and this can lead to some flickering when camera is changed.
            To fix that the CameraDistanceSortedRenderingQueue by default fixes the order so that when one object renders both back and front material, then back material is always rendered before front material
            (this only works when no other object has the same distance to the camera - so that there are no other objects inserted into rendering queue between back and front face material).
            This fix can be disabled with setting <see cref="P:Ab3d.DirectX.CameraDistanceSortedRenderingQueue.FixBackFaceMaterialOrder" /> property to false.
            </para>
                <para>
            With <see cref="P:Ab3d.DirectX.CameraDistanceSortedRenderingQueue.DistantObjectsFirst" /> property it is possible to change the sorting order.
            By default this property is set to true so that distant objects are rendered first.
            This is used for rendering transparent objects.
            But if you have a few big objects that occlude most of the scene, then you may want to set this property to false.
            This will render the closest objects first and therefore occlude other objects - improving performance with early rejecting of triangles because of depth testing.
            </para>
                <para>
            To provide custom sort order, you can subscribe to <see cref="E:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.SortingCompleted" /> event
            and in the event handler change the order of RenderablePrimitive objects by changing the indexes in the provided SortedIndexes array.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.CameraDistanceSortedRenderingQueue.SortingType">
            <summary>
            Gets a RenderingQueueSorterType that specifies when the RenderingQueue needs to be resorted.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CameraDistanceSortedRenderingQueue.DistantObjectsFirst">
            <summary>
            Gets or sets the direction of sorting. When true the objects that are more far away from the camera are rendered first.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CameraDistanceSortedRenderingQueue.FixBackFaceMaterialOrder">
            <summary>
            Gets or sets a Boolean that specifies if the order of objects that render back face is manually fixed so that they are always rendered before front face materials.
            This is only used when <see cref="P:Ab3d.DirectX.CameraDistanceSortedRenderingQueue.DistantObjectsFirst" /> is true.
            Default value is true.
            See remarks in this class description for more info.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.CameraDistanceSortedRenderingQueue.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="queueName">queueName</param>
            <param name="containsTransparentObjects">boolean that specified is this rendering queue contains transparent objects or other objects that need to be rendered with alpha blending and where order of rendering is important (false by default)</param>
        </member>
        <member name="M:Ab3d.DirectX.CameraDistanceSortedRenderingQueue.SortSortedIndexes(Ab3d.DirectX.RenderingContext,Ab3d.DirectX.ICamera,System.Boolean)">
            <summary>
            Sort items in this rendering queue by setting the sortedIndexes array.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="usedCamera">ICamera</param>
            <param name="forceSorting">when true, then sorting is performed in all cases; if false sorting is performed only when needed based on the DXScene changes flag.</param>
        </member>
        <member name="M:Ab3d.DirectX.CameraDistanceSortedRenderingQueue.DisposeSortRelatedData">
            <summary>
            DisposeSortRelatedData disposes all data that are used to store and cache sort related data.
            This method is called when Disposing or when IsSortingEnabled is set to false.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.DXDevice">
            <summary>
            DXDevice is a DXEngine's wrapper for the DirectX device.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDevice.Logger">
            <summary>
            Logger object is always null in release build.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.DXDevice.BeforeDeviceDisposed">
            <summary>
            Occurs just before the DirectX device will be disposed and after all other resources have been already disposed.
            Can be used to check for undisposed resources.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDevice.NoMultisamplingSampleDescription">
            <summary>
            SampleDescription that is used to define no multisampling
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDevice.StandardBufferFormat">
            <summary>
            Standard back buffer format (Default value B8G8R8A8_UNorm is required by WPF)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDevice.StandardDepthStencilFormat">
            <summary>
            Standard format for DepthStencil buffer (D32_Float - 32 bit depth buffer, no stencil buffer)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDevice.MaxTextureDimension">
            <summary>
            Max width or height of the texture in DirectX 11.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDevice.StandardSwapEffect">
            <summary>
            Gets or sets a SwapEffect that is used to create the SwapChain (if supported by the operating system and device).
            By default this value is set to FlipDiscard that is used if supported by OS.
            Otherwise FlipSequential is used and if this is not supported then Discard is used.
            </summary>
            <remarks>
                <para>
            Gets or sets a SwapEffect that is used to create the SwapChain (if supported by the operating system and device).
            By default this value is set to FlipDiscard.
            </para>
                <para>
            If StandardSwapEffect is set to FlipDiscard then it is used when DXGI 1.4 is supported (on Windows 10).
            If FlipDiscard is not supported, then FlipSequential is used (required DXGI 1.2 - also supported on Windows 7 with Platform update).
            You can also set the value to Discard to use the bit-block transfer (bitblt) model.
            </para>
                <para>
            When using FlipDiscard or FlipSequential, then SwapChain is created with 2 back-buffers (triple buffering).
            When using Discard, then SwapChain is created with 1 back-buffer (double buffering).
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXDevice.Device">
            <summary>
            Gets a DirectX device that is used by this DXDevice
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDevice.ImmediateContext">
            <summary>
            Gets a DirectX Immediate Device context
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDevice.Adapter">
            <summary>
            Gets an adapter (graphics card) that is used by the created Device. Adapter is null if the Device is not yet created.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDevice.DXGIVersion">
            <summary>
            Gets the DXGI version supported by the Device and operating system. The versions can be from 1.1 to 1.4.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDevice.IsDebugDevice">
            <summary>
            Gets a boolean that specifies if the created Device was created with Debug layer.
            Note that this property can be false even when the <see cref="P:Ab3d.DirectX.DXDiagnostics.CreateDebugDirectXDevice" /> is true. 
            This indicates that the debug device cannot be created. This can be cased because debug layer is disabled in "DirectX Control panel" or the Debug layer is not installer on the system (it is usually installed with Visual Studio or with Windows SDK).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDevice.ImmediateContextStatesManager">
            <summary>
            ContextStatesManager that is used for the immediate contex
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDevice.EffectsManager">
            <summary>
            EffectsManager that stores all registered effects
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDevice.CommonStates">
            <summary>
            CommonStates that store all common states
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDevice.TextureCache">
            <summary>
            TextureCache is used to cache the textures
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDevice.DeviceCapabilities">
            <summary>
            DeviceCapabilities for this DirectX device
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDevice.Configuration">
            <summary>
            DXDeviceConfiguration configuration used for creation of DirectX Device and SwapChain.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDevice.ResourcesCache">
            <summary>
            Gets or sets an IDisposable object that can be used for caching the resources created on this DXDevice. 
            This property is used by DXViewportView to cache WpfMaterial, DXMeshGeometry3D and SceneNodes objects created from WPF objects. 
            It is not recommended to set this property to any other value.
            </summary>
            <remarks>
                <para>
                    <b>ResourcesCache</b> gets or sets an IDisposable object that can be used for caching the resources created on this DXDevice. 
            </para>
                <para>
            This property is used by DXViewportView to cache WpfMaterial, DXMeshGeometry3D and SceneNodes objects created from WPF objects. 
            </para>
                <para>
            When using cached objects, the same DXEngine's object is used for one WPF material object even if the material is used on many different GeometryModel3D objects; when caching is not used, each instance of GeometryModel3D object use its own instance of DXEngine's material object.
            </para>
                <para>
            It is not recommended to set this property to some other value because this will disable caching of DXEngine objects created from WPF objects.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXDevice.BackgroundThreadsManager">
            <summary>
            Gets or sets a BackgroundThreadsManager that is used for background rendering in DXScene objects (if DXScene does not provide its onw instance of BackgroundThreadsManager).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.#ctor(Ab3d.DirectX.DXDeviceConfiguration,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="configuration">DXDeviceConfiguration</param>
            <param name="name">name</param>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.InitializeDevice">
            <summary>
            InitializeDevice creates the DirectX device if it was not yet created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateDevice(SharpDX.Direct3D.DriverType,SharpDX.DXGI.Adapter1,System.Boolean)">
            <summary>
            CreateDevice creates DirectX device with specified parameters. The method can be overridden.
            </summary>
            <param name="driverType">DriverType</param>
            <param name="adapter">adapter</param>
            <param name="createDebugDevice">createDebugDevice</param>
            <returns></returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateDevice(SharpDX.Direct3D.DriverType,SharpDX.DXGI.Adapter,SharpDX.Direct3D11.DeviceCreationFlags,SharpDX.Direct3D.FeatureLevel[])">
            <summary>
            CreateDevice creates DirectX device with specified parameters.
            This method correctly handles device creation when featureLevels array contains Level_11_1 but that runtime is not installed on the system (for example on Windows 7 SP 1 without Platform Update).
            If device cannot be created an exception is thrown or null is returned.
            </summary>
            <param name="driverType">DriverType</param>
            <param name="adapter">adapter</param>
            <param name="deviceCreationFlags">deviceCreationFlags</param>
            <param name="featureLevels">array of FeatureLevel (or null)</param>
            <returns>Creates DirectX device. If device cannot be created an exception is thrown or null is returned.</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateDXSceneWithSwapChain(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.String)">
            <summary>
            CreateDXSceneWithSwapChain creates a DXScene that is using SwapChain to show its content.
            </summary>
            <param name="hWnd">handle to window that will show the DXScene content</param>
            <param name="width">width</param>
            <param name="height">height</param>
            <param name="preferedMultisampleCount">preferedMultisampleCount</param>
            <param name="supersamplingCount">super-sampling count (1 for no super-sampling)</param>
            <param name="dpiScaleX">dpiScaleX</param>
            <param name="dpiScaleY">dpiScaleY</param>
            <param name="sceneName">sceneName</param>
            <returns>DXScene</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateDXSceneWithBackBuffer(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.String)">
            <summary>
            CreateDXSceneWithBackBuffer creates a DXScene that will be using BackBuffer (instead of SwapChain) to render its content to.
            </summary>
            <param name="width">width</param>
            <param name="height">height</param>
            <param name="preferedMultisampleCount">preferedMultisampleCount</param>
            <param name="supersamplingCount">super-sampling count (1 for no super-sampling)</param>
            <param name="dpiScaleX">dpiScaleX</param>
            <param name="dpiScaleY">dpiScaleY</param>
            <param name="sceneName">sceneName</param>
            <returns>DXScene</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateSwapChain(System.IntPtr,System.Int32,System.Int32,SharpDX.DXGI.SampleDescription)">
            <summary>
            CreateSwapChain returns a SwapChain for the specified window handle, size and multisample description.
            </summary>
            <param name="hWnd">window handle</param>
            <param name="width">width</param>
            <param name="height">height</param>
            <param name="sampleDescription">multisample description</param>
            <returns>SwapChain</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateSwapChain(System.IntPtr,System.Int32,System.Int32,SharpDX.DXGI.SampleDescription,SharpDX.DXGI.SwapEffect@)">
            <summary>
            CreateSwapChain returns a SwapChain for the specified window handle, size and multisample description.
            </summary>
            <param name="hWnd">window handle</param>
            <param name="width">width</param>
            <param name="height">height</param>
            <param name="sampleDescription">multisample description</param>
            <param name="usedSwapEffect">out as SwapEffect that is used to create the SwapChain</param>
            <returns>SwapChain</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateTexture2D(SharpDX.Direct3D11.Texture2DDescription)">
            <summary>
            CreateTexture2D returns a buffer as Texture2D.
            </summary>
            <param name="backBufferDescription">Texture2DDescription</param>
            <returns>Texture2D</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateTexture2D(System.Int32,System.Int32,SharpDX.DXGI.SampleDescription,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            CreateTexture2D returns a buffer as Texture2D with standard format (defined by <see cref="F:Ab3d.DirectX.DXDevice.StandardBufferFormat" />).
            </summary>
            <param name="width">width</param>
            <param name="height">height</param>
            <param name="sampleDescription">sampleDescription (defines antialiasing)</param>
            <param name="isRenderTarget">isRenderTarget</param>
            <param name="isSharedResource">isSharedResource</param>
            <param name="isStagingTexture">isStagingTexture</param>
            <returns>Texture2D</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateTexture2D(System.Int32,System.Int32,SharpDX.DXGI.SampleDescription,System.Boolean,System.Boolean,System.Boolean,System.Boolean,SharpDX.DXGI.Format)">
            <summary>
            CreateTexture2D returns a buffer as Texture2D.
            </summary>
            <param name="width">width</param>
            <param name="height">height</param>
            <param name="sampleDescription">sampleDescription (defines antialiasing)</param>
            <param name="isRenderTarget">isRenderTarget</param>
            <param name="isSharedResource">isSharedResource</param>
            <param name="isStagingTexture">isStagingTexture</param>
            <param name="isShaderResource">isShaderResource</param>
            <param name="format">format</param>
            <returns>Texture2D</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateTexture2DDescription(System.Int32,System.Int32,SharpDX.DXGI.SampleDescription,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            CreateTexture2DDescription returns a Texture2DDescription that can be used to create a back buffer with standard format (defined by <see cref="F:Ab3d.DirectX.DXDevice.StandardBufferFormat" />).
            </summary>
            <param name="width">width</param>
            <param name="height">height</param>
            <param name="sampleDescription">sampleDescription (defines antialiasing)</param>
            <param name="isRenderTarget">isRenderTarget</param>
            <param name="isSharedResource">isSharedResource</param>
            <param name="isStagingTexture">isStagingTexture</param>
            <returns>Texture2DDescription</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateTexture2DDescription(System.Int32,System.Int32,SharpDX.DXGI.SampleDescription,System.Boolean,System.Boolean,System.Boolean,System.Boolean,SharpDX.DXGI.Format)">
            <summary>
            CreateTexture2DDescription returns a Texture2DDescription that can be used to create a back buffer.
            </summary>
            <param name="width">width</param>
            <param name="height">height</param>
            <param name="sampleDescription">sampleDescription (defines antialiasing)</param>
            <param name="isRenderTarget">isRenderTarget</param>
            <param name="isSharedResource">isSharedResource</param>
            <param name="isStagingTexture">isStagingTexture</param>
            <param name="isShaderResource">isShaderResource</param>
            <param name="format">format</param>
            <returns>Texture2DDescription</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateDepthStencilView(System.Int32,System.Int32,SharpDX.DXGI.SampleDescription,System.String)">
            <summary>
            CreateDepthStencilView returns a DepthStencilView with the specified size and multisample description
            </summary>
            <param name="width">width</param>
            <param name="height">height</param>
            <param name="sampleDescription">multisample description</param>
            <param name="name">when set (is not null) and when using debug DirectX device, the DebugName for depthStencilBuffer will be set to name and DebugName for the depthStencilView will be set to name + "View". Default value is "DepthStencilBuffer".</param>
            <returns>DepthStencilView</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateDepthStencilView(System.Int32,System.Int32,SharpDX.DXGI.SampleDescription,SharpDX.DXGI.Format,System.String)">
            <summary>
            CreateDepthStencilView returns a DepthStencilView with the specified size, multisample description and format
            </summary>
            <param name="width">width</param>
            <param name="height">height</param>
            <param name="sampleDescription">multisample description</param>
            <param name="format">format</param>
            <param name="name">when set (is not null) and when using debug DirectX device, the DebugName for depthStencilBuffer will be set to name and DebugName for the depthStencilView will be set to name + "View". Default value is "DepthStencilBuffer".</param>
            <returns>DepthStencilView</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateDepthStencilBuffer(System.Int32,System.Int32,SharpDX.DXGI.SampleDescription,SharpDX.DXGI.Format)">
            <summary>
            CreateDepthStencilBuffer returns a Texture2D that represents a DepthStencilBuffer with the specified size, multisample description and format
            </summary>
            <param name="width">width</param>
            <param name="height">height</param>
            <param name="sampleDescription">multisample description</param>
            <param name="format">format</param>
            <returns>Texture2D</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateConstantBuffer(System.Int32,System.String)">
            <summary>
            CreateConstantBuffer returns a Buffer that represents a constants buffer.
            </summary>
            <param name="bufferSize">bufferSize</param>
            <param name="constantBufferName">sets the debug name of the created constant name when a Debug DirectX device was created</param>
            <returns>Buffer</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateBlendState(SharpDX.Direct3D11.BlendOption,SharpDX.Direct3D11.BlendOption)">
            <summary>
            CreateBlendState returns a BlendState from sourceBlend and destinationBlend and operation set to Add for RGB channels (alpha values blend are added together).
            </summary>
            <param name="sourceBlend">sourceBlend</param>
            <param name="destinationBlend">destinationBlend</param>
            <returns>BlendState</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateBlendState(SharpDX.Direct3D11.BlendStateDescription)">
            <summary>
            CreateBlendState returns a BlendState from BlendStateDescription.
            </summary>
            <param name="blendStateDesc">BlendStateDescription</param>
            <returns>BlendState</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateRasterizerState(SharpDX.Direct3D11.CullMode,SharpDX.Direct3D11.FillMode,System.Boolean,System.Boolean)">
            <summary>
            CreateRasterizerState returns a RasterizerState.
            </summary>
            <param name="cullMode">cullMode</param>
            <param name="fillMode">fillMode</param>
            <param name="enableMultisample">enableMultisample</param>
            <param name="isFrontCounterClockwise">isFrontCounterClockwise</param>
            <returns>RasterizerState</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateDepthStencilState(System.Boolean,System.Boolean)">
            <summary>
            CreateDepthStencilState returns a DepthStencilState
            </summary>
            <param name="depthEnable">depthEnable</param>
            <param name="depthWriteEnable">depthWriteEnable</param>
            <returns>DepthStencilState</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.CreateSamplerState(SharpDX.Direct3D11.Filter,SharpDX.Direct3D11.TextureAddressMode,System.Int32)">
            <summary>
            CreateSamplerState returns a SamplerState
            </summary>
            <param name="filter">filter</param>
            <param name="addressMode">addressMode</param>
            <param name="maximumAnisotropy">maximumAnisotropy</param>
            <returns>SamplerState</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.IsUsingDefaultSystemAdapter">
            <summary>
            Returns true if the default system adapter is used.
            </summary>
            <returns>true if the default system adapter is used</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.GetUsedMultisamplingDescription(System.Int32)">
            <summary>
            GetUsedMultisamplingDescription returns a SampleDescription from specified multisampleCount
            </summary>
            <param name="multisampleCount">multisampleCount</param>
            <returns>SampleDescription</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.IsAnyDXSceneRegistered">
            <summary>
            Gets true if any DXScene is using this DXDevice. Else returns false.
            </summary>
            <returns>Gets true if any DXScene is using this DXDevice. Else returns false.</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.GetAllSystemAdapters">
            <summary>
            Returns all Adapter1 that are supported on the system.
            </summary>
            <exception cref="T:Ab3d.DirectX.DXEngineException">DXEngineException when DXGI 1.1 Factory cannot be created</exception>
            <returns>all Adapter1 that are supported on the system</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.DisposeWithDXDevice(System.IDisposable)">
            <summary>
            DisposeWithDXDevice method adds the specified disposable object to the list of objects that will be disposed when this DXDevice will be disposed.
            </summary>
            <param name="disposable">IDisposable</param>
        </member>
        <member name="M:Ab3d.DirectX.DXDevice.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.DXDeviceConfiguration">
            <summary>
            DXDeviceConfiguration is used to define properties that are used for creation of DirectX Device and SwapChain.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDeviceConfiguration.AllSupportedFeatureLevels">
            <summary>
            Gets an array of all FeatureLevels supported by DXEngine
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDeviceConfiguration.DriverType">
            <summary>
            Gets or sets a DirectX DriverType. Usually this property is set to Hardware or Warp (used for high speed software rendering).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDeviceConfiguration.SupportedFeatureLevels">
            <summary>
            Gets or sets an array of FeatureLevel that specify which feature levels are required to create the DirectX device (by default feature levels equal and higher than 10 are used).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDeviceConfiguration.Adapter">
            <summary>
            Gets or sets an adapter (graphics card) that will be used to create DirectX device. When null (by default) the default adapter is used.
            To get the actual Adapter used by the created DirectX Device see the <see cref="P:Ab3d.DirectX.DXDevice.Adapter" /> property.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXDeviceConfiguration.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.DXDiagnostics">
            <summary>
            DXDiagnostics class contains static properties that define which diagnostics features of the DXEngine will be turned on.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.DXDiagnostics.LogLevels">
            <summary>
            LogLevels define log levels that are used to specify which DXEngine messages are written to Console / Output window.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDiagnostics.LogLevels.None">
            <summary>
            No messages are written
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDiagnostics.LogLevels.Warn">
            <summary>
            Write all Warnings, Errors and Fatal errors
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDiagnostics.LogLevels.Error">
            <summary>
            Write all Errors and Fatal errors
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXDiagnostics.LogLevels.Fatal">
            <summary>
            Write only Fatal errors
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDiagnostics.IsCollectingStatistics">
            <summary>
            Gets or sets a static Boolean that specifies if DXEngine is collecting rendering statistics to <see cref="T:Ab3d.DirectX.RenderingStatistics" /> class that can be read from <see cref="P:Ab3d.DirectX.DXScene.Statistics" /> property.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDiagnostics.CreateDebugDirectXDevice">
            <summary>
            Gets or sets a static Boolean that specifies if the DirectX device is created with debug flat that enabled DirectX debug layer.
            To use debug layer the Windows SDK or DirectX SDK must be installed.
            To check if the device was created with the debug layer, see the <see cref="P:Ab3d.DirectX.DXDevice.IsDebugDevice" /> property after the DXDevice was created.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDiagnostics.ReportLiveDeviceObjectsOnDispose">
            <summary>
            Gets or sets a static Boolean that specifies if ReportLiveDeviceObjects method is called when the DirectX device is disposed.
            This method reports all live (not disposed) DirectX objects to the Visual Studio Output window. <see cref="P:Ab3d.DirectX.DXDiagnostics.CreateDebugDirectXDevice" /> must be set to true and DirectX debug layer must be enabled for this property to work.
            See remarks for more info.
            </summary>
            <remarks>
                <para>
                    <b>ReportLiveDeviceObjectsOnDispose</b> gets or sets a static Boolean that specifies if ReportLiveDeviceObjects method is called when the DirectX device is disposed.
            </para>
                <para>
                    <see cref="P:Ab3d.DirectX.DXDiagnostics.CreateDebugDirectXDevice" /> must be set to true for this property to work (ReportLiveDeviceObjects method is available only when a debug DirectX device is created; this also required DirectX debug layer to be enabled).
            </para>
                <para>
            This method reports all live (not disposed) DirectX objects to the Visual Studio Output window. 
            </para>
                <para>
            To see if there are any undisposed objects, you need to check if the "Refcount" number is bigger than 0. 
            This means that there are still some outer references to that object.
            If "IntRef" is bigger than zero, than this is not a problem because this shows internal references that will be automatically disposed.
            To show this report, there still need to be some outer references live for ID3D11Device (usually 6) and ID3D11Context (usually 1). 
            So if you see some references there, this is not a problem because those references will be released when the DXDevice is disposed.
            </para>
                <para>
            The following shows a sample report output (note that the last line shows one live reference to the DirectionalLightShader_perObjectNoWVPConstantsBuffer):
            </para>
                <code>
            D3D11 WARNING: Live ID3D11Device at 0x0C5CED14, Refcount: 6 [ STATE_CREATION WARNING #441: LIVE_DEVICE]
            D3D11 WARNING: 	Live ID3D11Context at 0x0C5CFC40, Refcount: 1, IntRef: 1 [STATE_CREATION WARNING #2097226: LIVE_CONTEXT]
            D3D11 WARNING: 	Live ID3DDeviceContextState at 0x0C6BF6F8, Refcount: 0, IntRef: 1 [STATE_CREATION WARNING #3145742: LIVE_DEVICECONTEXTSTATE]
            D3D11 WARNING: 	Live ID3D11BlendState at 0x0C6C5674, Name: Opaque, Refcount: 0, IntRef: 1 [STATE_CREATION WARNING #435: LIVE_BLENDSTATE]
            D3D11 WARNING: 	Live ID3D11DepthStencilState at 0x0C6C608C, Refcount: 0, IntRef: 1 [STATE_CREATION WARNING #436: LIVE_DEPTHSTENCILSTATE]
            D3D11 WARNING: 	Live ID3D11RasterizerState at 0x0C6C6824, Refcount: 0, IntRef: 1 [STATE_CREATION WARNING #437: LIVE_RASTERIZERSTATE]
            D3D11 WARNING: 	Live ID3D11Sampler at 0x0C6C63DC, Refcount: 0, IntRef: 1 [STATE_CREATION WARNING #434: LIVE_SAMPLER]
            D3D11 WARNING: 	Live ID3D11Query at 0x0C5BDA64, Refcount: 0, IntRef: 1 [STATE_CREATION WARNING #438: LIVE_QUERY]
            D3D11 WARNING: 	Live ID3D11DepthStencilState at 0x0C6C5EE4, Name: DepthReadWrite, Refcount: 0, IntRef: 0 [STATE_CREATION WARNING #436: LIVE_DEPTHSTENCILSTATE]
            D3D11 WARNING: 	Live ID3D11RasterizerState at 0x0E4A9764, Name: CullClockwise, Refcount: 0, IntRef: 0 [STATE_CREATION WARNING #437: LIVE_RASTERIZERSTATE]
            D3D11 WARNING: 	Live ID3D11Texture2D at 0x0C6CABEC, Name: MSAABackBuffer, Refcount: 0, IntRef: 1 [STATE_CREATION WARNING #425: LIVE_TEXTURE2D]
            D3D11 WARNING: 	Live ID3D11RenderTargetView at 0x0C6CAF04, Name: MSAABackBufferRenderTargetView, Refcount: 0, IntRef: 0 [STATE_CREATION WARNING #428: LIVE_RENDERTARGETVIEW]
            D3D11 WARNING: 	Live ID3D11Texture2D at 0x0E4C2F2C, Refcount: 0, IntRef: 1 [STATE_CREATION WARNING #425: LIVE_TEXTURE2D]
            D3D11 WARNING: 	Live ID3D11DepthStencilView at 0x0C6A5544, Name: DepthStencilView, Refcount: 0, IntRef: 0 [STATE_CREATION WARNING #429: LIVE_DEPTHSTENCILVIEW]
            D3D11 WARNING: 	Live ID3D11Buffer at 0x0C3C0FCC, Name: DirectionalLightShader_perFrameCameraConstantsBuffer, Refcount: 0, IntRef: 0 [STATE_CREATION WARNING #423: LIVE_BUFFER]
            D3D11 WARNING: 	Live ID3D11Buffer at 0x0E70AB0C, Name: DirectionalLightShader_perFrameDirectionalLightsConstantsBuffer, Refcount: 0, IntRef: 0 [STATE_CREATION WARNING #423: LIVE_BUFFER]
            D3D11 WARNING: 	Live ID3D11Buffer at 0x0E7111AC, Name: DirectionalLightShader_perObjectNoWVPConstantsBuffer, Refcount: 1, IntRef: 0 [STATE_CREATION WARNING #423: LIVE_BUFFER]
            </code>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXDiagnostics.LogLevel">
            <summary>
            Gets or sets a log level that specifies which DXEngine messages are written to Output Window and to LogFileName file (if specified). Default value is Error.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDiagnostics.LogFileName">
            <summary>
            Gets to sets a string that specifies the file name that is used to store log messages. By default this property is set to null. This prevents writing log messages to file.
            You can also set this property to "desktop" and this will created the "DXEngine.log" on the user's desktop folder.
            
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDiagnostics.IsWritingLogToOutput">
            <summary>
            Gets or sets a Boolean that specifies if log messages are written to Visual Studio Output window.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDiagnostics.LogAction">
            <summary>
            Gets or sets an action that is called when a Warning or Error log message is written to log. 
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXDiagnostics.IsResourceTrackingEnabled">
            <summary>
            Gets or sets a Boolean that specifies if DirectX resources construction and disposal is tracked with DXEngine.
            After resource tracing is enabled, you can get the report by calling <see cref="M:Ab3d.DirectX.DXDiagnostics.GetTrackedResourcesReport(System.Boolean)" /> method.
            Default value if false.
            </summary>
            <remarks>
                <para>
                    <b>IsResourceTrackingEnabled</b> gets or sets a Boolean that specifies if DirectX resources construction and disposal is tracked with DXEngine.
            </para>
                <para>
            To get a more detailed information about COM object construction and destruction it is possible to use ObjectTracker from SharpDX.
            To enable it set the SharpDX.Configuration.EnableObjectTracking to true.
            Then call the SharpDX.Diagnostics.ObjectTracker.ReportActiveObjects() method to get report of live object and the call stack to their construction.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXDiagnostics.IsD3DPerformanceEventGroupingEnabled">
            <summary>
            Gets or sets a Boolean that specifies if D3DPerf_BeginEvent and D3DPerf_EndEvent are called when running each rendering step.
            This can be used to Graphics debugger to simplify rendering debugging. This requires using DirectX layer (<see cref="P:Ab3d.DirectX.DXDiagnostics.CreateDebugDirectXDevice" />. 
            When using SharpDX 3.1 or newer you need to add reference to SharpDX.Desktop.
            Default value is false.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXDiagnostics.GetTrackedResourcesReport(System.Boolean)">
            <summary>
            Gets a formated string with tracked resources (resource tracking must be enabled with <see cref="P:Ab3d.DirectX.DXDiagnostics.IsResourceTrackingEnabled" /> before calling this method or null is returned).
            </summary>
            <param name="showFullTypeName">If true than type namespace will be also added to type name</param>
            <returns>formated string with tracked resources</returns>
        </member>
        <member name="P:Ab3d.DirectX.DXDiagnostics.CurrentDXView">
            <summary>
            Gets or sets a DXView (or DXViewportView) that is currently shown. This value is used by DXEngineSnoop to find the DXView control.
            The value is stored in a private WeakReference to prevent rooting the object by a static filed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXDiagnostics.CaptureNextFrame(Ab3d.DirectX.DXScene)">
            <summary>
            CaptureNextFrame programmatically captures the next rendered frame with Visual Studio Graphics Debugging.
            This works for DirectXOverlay and DirectXImage presentation type.
            Capture is supported on Windows 8.1 and newer operating system, with installed Windows Software Development Kit (SDK) and only when the Visual Studio Graphics Debugging is running.
            The method returns true when capture is supported. If capture is not supported, false is returned.
            </summary>
            <remarks>
                <para>
                    <b>CaptureNextFrame</b> programmatically captures the next rendered frame with Visual Studio Graphics Debugging.
            </para>
                <para>
            This works for DirectXOverlay and DirectXImage presentation type.
            </para>
                <para>
            Capture is supported on Windows 8.1 and newer operating system, with installed Windows Software Development Kit (SDK) and only when the Visual Studio Graphics Debugging is running.
            </para>
                <para>
            The method returns true when capture is supported. If capture is not supported, false is returned.
            </para>
                <para>
            It possible to check if capture is available with calling <see cref="M:Ab3d.DirectX.DXDiagnostics.IsCaptureFrameSupported" /> method.
            </para>
            </remarks>
            <param name="dxScene">DXScene that will be captured</param>
            <returns>true when capture is supported; false if capture is not supported</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXDiagnostics.IsCaptureFrameSupported">
            <summary>
            Returns true if programmatical capture of frame into Visual Studio Graphics Debugging is supported.
            Capture is supported on Windows 8.1 and newer operating system, with installed Windows Software Development Kit (SDK) and only when the Visual Studio Graphics Debugging is running.
            </summary>
            <returns>true if programmatical capture of frame is supported</returns>
        </member>
        <member name="T:Ab3d.DirectX.EffectRegisteredEventHandler">
            <summary>
            EffectRegisteredEventHandler is an event handler with EffectRegisteredEventArgs as an argument and is used for  the EffectRegistered event in EffectsManager.
            </summary>
            <param name="sender">sender</param>
            <param name="e">EffectRegisteredEventArgs</param>
        </member>
        <member name="T:Ab3d.DirectX.EffectRegisteredEventArgs">
            <summary>
            EffectRegisteredEventArgs class defines the Effect that was registered by EffectsManager and is used in the EffectRegistered event in EffectsManager.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.EffectRegisteredEventArgs.RegisteredEffect">
            <summary>
            newly registered effect
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.EffectRegisteredEventArgs.#ctor(Ab3d.DirectX.Effect)">
            <summary>
            Constructor
            </summary>
            <param name="registeredEffect">Effect</param>
        </member>
        <member name="T:Ab3d.DirectX.ISortedRenderingQueue">
            <summary>
            ISortedRenderingQueue interface defines methods that are used by RenderingQueue that support sorting of its items.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ISortedRenderingQueue.IsSortingEnabled">
            <summary>
            If true than sortable RenderQueues will be sorted.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ISortedRenderingQueue.SortingType">
            <summary>
            Gets a RenderingQueueSorterType that specifies when the RenderingQueue needs to be resorted.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ISortedRenderingQueue.Sort(Ab3d.DirectX.RenderingContext,Ab3d.DirectX.ICamera,System.Boolean)">
            <summary>
            Sort items in rendering queue
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="usedCamera">ICamera</param>
            <param name="forceSorting">when true, then sorting is performed in all cases; if false sorting is performed only when necessary based on the DXScene changes flag.</param>
            <returns>true if sort was performed, false if no sorting was required</returns>
        </member>
        <member name="T:Ab3d.DirectX.MaterialSortedRenderingQueue">
            <summary>
            MaterialSortedRenderingQueue is rendering queue where the objects inside the queue are sorted so that objects with the same material are rendered one after another - this minimizes the state changes and increases the performance.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MaterialSortedRenderingQueue.SortingType">
            <summary>
            Gets a RenderingQueueSorterType that specifies when the RenderingQueue needs to be resorted.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.MaterialSortedRenderingQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="queueName">queueName</param>
            <param name="useMultiThreading">boolean that specified is this rendering queue can be rendered with using multiple threads (false by default)</param>
            <param name="containsTransparentObjects">boolean that specified is this rendering queue contains transparent objects or other objects that need to be rendered with alpha blending and where order of rendering is important (false by default)</param>
            <param name="allowedEffectType">when not null (by default) then only RenderablePrimitive with this Effect can be added to this rendering queues (usually this is used for MultiThreaded rendering)</param>
        </member>
        <member name="M:Ab3d.DirectX.MaterialSortedRenderingQueue.SortSortedIndexes(Ab3d.DirectX.RenderingContext,Ab3d.DirectX.ICamera,System.Boolean)">
            <summary>
            Sort items in this rendering queue by setting the sortedIndexes array.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="usedCamera">ICamera</param>
            <param name="forceSorting">when true, then sorting is performed in all cases; if false sorting is performed only when needed based on the DXScene changes flag.</param>
            <returns>true if sort was performed, false if no sorting was required</returns>
        </member>
        <member name="T:Ab3d.DirectX.RenderablePrimitiveRenderingQueue">
            <summary>
            RenderablePrimitiveRenderingQueue is derived from RenderingQueue. 
            The difference from RenderingQueue is that RenderablePrimitiveRenderingQueue can accept (with Add method) only objects derived from RenderablePrimitive. 
            This is useful for rendering queues that need to be sorted for example MaterialSortedRenderingQueue and CameraDistanceSortedRenderingQueue.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveRenderingQueue.renderablePrimitives">
            <summary>
            List of RenderablePrimitive objects used by this RenderablePrimitiveRenderingQueue
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderablePrimitiveRenderingQueue.AllowedEffectType">
            <summary>
            Gets allowedEffectType that can be set in the constructor. When AllowedEffectType is not null then this RenderingQueue can get only RenderablePrimitive objects that use the specified Effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderablePrimitiveRenderingQueue.Count">
            <summary>
            Count of RenderablePrimitive objects used by this RenderablePrimitiveRenderingQueue
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderablePrimitiveRenderingQueue.Item(System.Int32)">
            <summary>
            Gets a RenderablePrimitiveBase with the specified index
            </summary>
            <param name="index">index of the item in this queue</param>
            <returns>RenderablePrimitiveBase with the specified index</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitiveRenderingQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="queueName">queueName</param>
            <param name="useMultiThreading">boolean that specified is this rendering queue can be rendered with using multiple threads (false by default)</param>
            <param name="containsTransparentObjects">boolean that specified is this rendering queue contains transparent objects or other objects that need to be rendered with alpha blending and where order of rendering is important (false by default)</param>
            <param name="allowedEffectType">when not null (by default) then only RenderablePrimitive with this Effect can be added to this rendering queues (usually this is used for MultiThreaded rendering)</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitiveRenderingQueue.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitiveRenderingQueue.ResetCachedMaterialFlags">
            <summary>
            Resets MaterialFlags in all renderableGeometries and then sets the ResetCachedMaterialFlagsOnNextRender to false.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitiveRenderingQueue.Add(Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Adds renderable object to this queue
            </summary>
            <param name="renderable">renderable object</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitiveRenderingQueue.Clear">
            <summary>
            Removes all renderable objects from this queue
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitiveRenderingQueue.Remove(Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Removes renderable object to this queue
            </summary>
            <param name="renderable">renderable object</param>
            <returns>true if object was removed or false if object was not found</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitiveRenderingQueue.Replace(Ab3d.DirectX.RenderablePrimitiveBase,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Replaces oldRenderablePrimitive object with newRenderablePrimitive (the newRenderablePrimitive preserves the positions of the oldRenderablePrimitive).
            </summary>
            <param name="oldRenderable">renderable object that will be replaced</param>
            <param name="newRenderable">renderable object that will replace the oldRenderablePrimitive</param>
            <returns>true if object was removed or false if object was not found</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitiveRenderingQueue.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.RenderingQueue">
            <summary>
            RenderingQueue is a queue that is used to store renderable objects that have similar properties and are rendered one after another.
            Objects inside the queue can be reordered or sorted to improve performance or make sure that the rendered results are correct (for example for transparency sorting).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderingQueue.Name">
            <summary>
            Name of this RenderingQueue.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderingQueue.UseMultiThreading">
            <summary>
            Gets a Boolean that specifies if this rendering queue can be rendered in multiple threads.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderingQueue.ContainsTransparentObjects">
            <summary>
            Gets a Boolean that specifies if this RenderingQueue can contains transparent objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingQueue.IsRenderedWithCustomRenderingStep">
            <summary>
            When set to true, then this RenderingQueue can be rendered only with a <see cref="T:Ab3d.DirectX.RenderObjectsRenderingStep" /> that has the <see cref="P:Ab3d.DirectX.RenderObjectsRenderingStep.FilterRenderingQueuesFunction" /> set
            and is not rendered with standard RenderObjectsRenderingStep (<see cref="P:Ab3d.DirectX.DXScene.DefaultRenderObjectsRenderingStep" />).
            </summary>
            <remarks>
                <para>
            When set to true, then this RenderingQueue can be rendered only on with a <see cref="T:Ab3d.DirectX.RenderObjectsRenderingStep" /> that has the <see cref="P:Ab3d.DirectX.RenderObjectsRenderingStep.FilterRenderingQueuesFunction" /> set
            and is not rendered with standard RenderObjectsRenderingStep (<see cref="P:Ab3d.DirectX.DXScene.DefaultRenderObjectsRenderingStep" />).
            </para>
                <para>
            This property can be used when this RenderingQueue contains objects that need to be rendered only with a special RenderObjectsRenderingStep.
            With setting this property to true the standard RenderObjectsRenderingStep will skip this RenderingQueue (you do not need to filter them manually with setting FilterRenderingQueuesFunction on standard RenderObjectsRenderingStep).
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.RenderingQueue.IsRenderingEnabled">
            <summary>
            Gets or sets a Boolean that specifies if the objects in this rendering queue are rendered (true by default).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingQueue.IsDisposed">
            <summary>
            True if this RenderingQueue was disposed
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderingQueue.renderableGeometries">
            <summary>
            List of renderable objects used by this RenderingQueue
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingQueue.Count">
            <summary>
            Count of renderable objects used by this RenderingQueue
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingQueue.Item(System.Int32)">
            <summary>
            Gets a RenderablePrimitiveBase with the specified index
            </summary>
            <param name="index">index of the item in this queue</param>
            <returns>RenderablePrimitiveBase with the specified index</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingQueue.#ctor(System.String,System.Boolean,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="queueName">name of this RenderingQueue</param>
            <param name="useMultiThreading">boolean that specified is this rendering queue can be rendered with using multiple threads (false by default)</param>
            <param name="containsTransparentObjects">boolean that specified is this rendering queue contains transparent objects or other objects that need to be rendered with alpha blending and where order of rendering is important (false by default)</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingQueue.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingQueue.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingQueue.Clear">
            <summary>
            Removes all renderable objects from this queue
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingQueue.ResetCachedMaterialFlags">
            <summary>
            Resets MaterialFlags in all renderableGeometries and then sets the ResetCachedMaterialFlagsOnNextRender to false.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingQueue.Add(Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Adds renderable object to this queue
            </summary>
            <param name="renderable">renderable object</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingQueue.Remove(Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Removes renderable object from this queue
            </summary>
            <param name="renderable">renderable object</param>
            <returns>true if object was removed or false if object was not found</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingQueue.Replace(Ab3d.DirectX.RenderablePrimitiveBase,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Replaces oldRenderablePrimitive object with newRenderablePrimitive (the newRenderablePrimitive preserves the positions of the oldRenderablePrimitive).
            </summary>
            <param name="oldRenderablePrimitive">renderable object that will be replaced</param>
            <param name="newRenderablePrimitive">renderable object that will replace the oldRenderablePrimitive</param>
            <returns>true if object was removed or false if object was not found</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingQueue.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingQueue.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingQueue.ToString">
            <summary>
            ToString
            </summary>
            <returns>description</returns>
        </member>
        <member name="T:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue">
            <summary>
            RenderablePrimitiveRenderingQueue is derived from RenderingQueue. 
            The difference from RenderingQueue is that RenderablePrimitiveRenderingQueue can accept (with Add method) only objects derived from RenderablePrimitive. 
            This is useful for rendering queues that need to be sorted for example MaterialSortedRenderingQueue and CameraDistanceSortedRenderingQueue.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.RenderingQueueSorterType">
            <summary>
            RenderingQueueSorterType defines types of sorting that can be used by a RenderingQueue
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.RenderingQueueSorterType.None">
            <summary>
            No sorting is performed - objects are rendering in the same order as they are added to the queue
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.RenderingQueueSorterType.CameraDistance">
            <summary>
            Objects are sorted by camera distance
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.RenderingQueueSorterType.Material">
            <summary>
            Objects are sorted in such a way so that objects with same material are rendered together to reduce the number of needed state changes.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.RenderingQueueSorterType.Other">
            <summary>
            Objects are sorted by some other criteria.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.sortedIndexes">
            <summary>
            When sortedIndexes is set, it represents an array of indexes that point to a sorted collection of the renderablePrimitives.
            This field is used when <see cref="F:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.areSortedIndexesValid" /> is set to true.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.areSortedIndexesValid">
            <summary>
            When true, then the <see cref="F:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.sortedIndexes" /> contains a valid indexes of the sorted renderablePrimitives.
            For performance reasons there are no checks if sortedIndexes are valid so isSortedIndexesValid must be set to true ONLY when sortedIndexes is 100% valid.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.IsSorted">
            <summary>
            Gets a Boolean that specified is rendering queue items have been sorted.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.IsSortingEnabled">
            <summary>
            If true than sortable RenderQueues will be sorted.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.SortingCompleted">
            <summary>
            RenderingQueueSortingCompleted event is called after this RenderingQueue is sorted.
            It allows the code in the event handler to change the order in which objects are rendered by changing the values in the provided SortedIndexes array
            (note: use RenderablePrimitives.Count to get number of items because SortedIndexes.Length may be to big).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.SortingType">
            <summary>
            Gets a RenderingQueueSorterType that specifies when the RenderingQueue needs to be resorted.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.Item(System.Int32)">
            <summary>
            Gets a RenderablePrimitiveBase with the specified index
            </summary>
            <param name="index">index of the item in this queue</param>
            <returns>RenderablePrimitiveBase with the specified index</returns>
        </member>
        <member name="M:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="queueName">queueName</param>
            <param name="useMultiThreading">boolean that specified is this rendering queue can be rendered with using multiple threads (false by default)</param>
            <param name="containsTransparentObjects">boolean that specified is this rendering queue contains transparent objects or other objects that need to be rendered with alpha blending and where order of rendering is important (false by default)</param>
            <param name="allowedEffectType">when not null (by default) then only RenderablePrimitive with this Effect can be added to this rendering queues (usually this is used for MultiThreaded rendering)</param>
        </member>
        <member name="M:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.Add(Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Adds renderable object to this queue
            </summary>
            <param name="renderable">renderable object</param>
        </member>
        <member name="M:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.Clear">
            <summary>
            Removes all renderable objects from this queue
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.Remove(Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Removes renderable object to this queue
            </summary>
            <param name="renderable">renderable object</param>
            <returns>true if object was removed or false if object was not found</returns>
        </member>
        <member name="M:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.Replace(Ab3d.DirectX.RenderablePrimitiveBase,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Replaces oldRenderablePrimitive object with newRenderablePrimitive (the newRenderablePrimitive preserves the positions of the oldRenderablePrimitive).
            </summary>
            <param name="oldRenderable">renderable object that will be replaced</param>
            <param name="newRenderable">renderable object that will replace the oldRenderablePrimitive</param>
            <returns>true if object was removed or false if object was not found</returns>
        </member>
        <member name="M:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.GetUnsortedItems">
            <summary>
            Returns a ReadOnlyCollection that is a copy of the unsorted renderablePrimitives.
            </summary>
            <returns>unsorted renderablePrimitives as a ReadOnlyCollection</returns>
        </member>
        <member name="M:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.OnRenderingQueueSortingCompleted(Ab3d.DirectX.RenderingQueueSortingCompletedEventArgs)">
            <summary>
            OnRenderingQueueSortingCompleted
            </summary>
            <param name="e">RenderingQueueSortingCompletedEventArgs</param>
        </member>
        <member name="M:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.Sort(Ab3d.DirectX.RenderingContext,Ab3d.DirectX.ICamera,System.Boolean)">
            <summary>
            Sort items in this rendering queue.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="usedCamera">ICamera</param>
            <param name="forceSorting">when true, then sorting is performed in all cases; if false sorting is performed only when needed based on the DXScene changes flag.</param>
            <returns>true if sort was performed, false if no sorting was required</returns>
        </member>
        <member name="M:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.SortSortedIndexes(Ab3d.DirectX.RenderingContext,Ab3d.DirectX.ICamera,System.Boolean)">
            <summary>
            Sort items in this rendering queue by setting the sortedIndexes array.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="usedCamera">ICamera</param>
            <param name="forceSorting"></param>
            <returns>true if sort was performed, false if no sorting was required</returns>
        </member>
        <member name="M:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.DisposeSortRelatedData">
            <summary>
            DisposeSortRelatedData disposes all data that are used to store and cache sort related data.
            This method is called when Disposing or when IsSortingEnabled is set to false.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.TextureCache">
            <summary>
            TextureCache class provides texture cashing for DXEngine.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.TextureCache.GenerateMipMaps">
            <summary>
            Gets or sets a Boolean that specifies if mip-maps are generated when texture is created by this TextureCache
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.TextureCache.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.TextureCache.GetTextureFromFile(System.String,System.Boolean@)">
            <summary>
            Checks if a texture with specified fileName was already loaded and cached. 
            In this case the method returns a cached texture and increases its reference count. Otherwise null is returned.
            You need to dispose the texture when it is not used any more.
            </summary>
            <param name="fileName">file name</param>
            <param name="hasTransparency">returns true if texture has transparent colors</param>
            <returns>ShaderResourceView wrapped by SharedDXResourceWrapper or null if texture with the specified fileName was not yet cached</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureCache.GetTextureFromObject(System.Object,System.Boolean@)">
            <summary>
            Check cache and tries to find a texture that was created from the originalObject.
            If texture is not found, null is returned.
            The texture needs to be disposed when it is not used any more.
            </summary>
            <param name="originalObject">object used to create the texture</param>
            <param name="hasTransparency">returns true if texture has transparent colors</param>
            <returns>ShaderResourceView wrapped by SharedDXResourceWrapper</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureCache.CacheTexture(SharpDX.Direct3D11.ShaderResourceView,System.Boolean,System.String)">
            <summary>
            CacheTexture stores the texture (as ShaderResourceView) as cached texture created from the originalObject.
            </summary>
            <param name="textureView">ShaderResourceView</param>
            <param name="hasTransparency">true if texture has transparent colors</param>
            <param name="textureFileName">file name of the texture</param>
            <returns>ShaderResourceView wrapped by SharedDXResourceWrapper</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureCache.CacheTexture(SharpDX.Direct3D11.ShaderResourceView,System.Boolean,System.Object)">
            <summary>
            CacheTexture stores the texture (as ShaderResourceView) as cached texture created from the originalObject.
            </summary>
            <param name="textureView">ShaderResourceView</param>
            <param name="hasTransparency">true if texture has transparent colors</param>
            <param name="originalObject">originalObject</param>
            <returns>ShaderResourceView wrapped by SharedDXResourceWrapper</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureCache.CleanupCache">
            <summary>
            Cleans all disposed objects from cache
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.TextureCache.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.DXHitTestContext">
            <summary>
            DXHitTestContext provides a context information for hit testing.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXHitTestContext.DXScene">
            <summary>
            DXScene
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXHitTestContext.HitTestParameters">
            <summary>
            Gets the currently used <see cref="T:Ab3d.DirectX.DXHitTestOptions" /> object from the DXScene.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXHitTestContext.#ctor(Ab3d.DirectX.DXScene)">
            <summary>
            Constructor
            </summary>
            <param name="dxScene">DXScene</param>
        </member>
        <member name="T:Ab3d.DirectX.DXHitTestOptions">
            <summary>
            DXHitTestOptions class specifies hit testing parameters that are used with DXScene's hit testing.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.DXHitTestOptions.HitTestFilterResult">
            <summary>Specifies the return result of a hit test filter callback method.</summary>
        </member>
        <member name="F:Ab3d.DirectX.DXHitTestOptions.HitTestFilterResult.Stop">
            <summary>
            Stop hit testing (do not check any other SceneNode)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXHitTestOptions.HitTestFilterResult.Continue">
            <summary>
            Continue hit testing this SceneNode and its child nodes.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXHitTestOptions.HitTestFilterResult.ContinueSkipSelf">
            <summary>
            Continue hit testing the child scene nodes but skip this scene node.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXHitTestOptions.HitTestFilterResult.ContinueSkipChildren">
            <summary>
            Continue hit testing this scene node but skip child scene nodes.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXHitTestOptions.HitTestFilterResult.ContinueSkipSelfAndChildren">
            <summary>
            Continue hit testing but skip this scene node and its child scene nodes (test SceneNodes in other branches).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXHitTestOptions.HitTestFilterCallback">
            <summary>
            When HitTestFilterCallback is specified, the specified predicate is used as a filter that specifies if hit testing is executed on the specified SceneNode and its child SceneNodes (returns true) or not (returns false).
            When HitTestFilterCallback is null, hit testing is executed on all SceneNodes (as the predicate would always return true).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXHitTestOptions.UseMultiThreading">
            <summary>
            When true then multi-threaded hit testing algorithms are used when possible.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXHitTestOptions.GetOnlyFrontFacingTriangles">
            <summary>
            When true then only triangles that have normals (calculated from triangle positions) oriented in the opposite direction as the ray are returned (because ray is usually created from the camera's position this returns only triangles that are facing the camera).
            When false (by default), all hit triangles are returned regardless of their orientation.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXHitTestOptions.GetOnlyOneHitPerSceneNode">
            <summary>
            When true then only one hit result is get from one SceneNode.
            When false (by default), then multiple hit results can be created by one SceneNode.
            This property is used only by the <see cref="M:Ab3d.DirectX.DXScene.GetAllHitObjects(SharpDX.Ray,Ab3d.DirectX.SceneNode)" /> method and not by <see cref="M:Ab3d.DirectX.DXScene.GetClosestHitObject(SharpDX.Ray,Ab3d.DirectX.SceneNode)" /> method.
            </summary>
            <remarks>
                <para>
            When true then only one hit result is get from one SceneNode.
            </para>
                <para>
            When false (by default), then multiple hit results can be created by one SceneNode (for example one hit result when ray enters the object and one hit result when ray leaves the object).
            </para>
                <para>
            This property is used only by the <see cref="M:Ab3d.DirectX.DXScene.GetAllHitObjects(SharpDX.Ray,Ab3d.DirectX.SceneNode)" /> method and not by <see cref="M:Ab3d.DirectX.DXScene.GetClosestHitObject(SharpDX.Ray,Ab3d.DirectX.SceneNode)" /> method.
            </para>
                <seealso cref="P:Ab3d.DirectX.DXHitTestOptions.GetOnlyFrontFacingTriangles" />
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXHitTestOptions.MeshPositionsCountForOctTreeGeneration">
            <summary>
            Gets or sets an integer value that specifies number of positions in a mesh (DXMeshGeometry3D) at which a OctTree is generated to speed up hit testing
            (e.g. if mesh has more positions then a value specified with this property, then OctTree will be generated for the mesh).
            Default value is 512.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXHitTestOptions.GenerateOctTreeOnMeshInitialization">
            <summary>
            When true and when mesh has more positions than <see cref="P:Ab3d.DirectX.DXHitTestOptions.MeshPositionsCountForOctTreeGeneration" />, then the OctTree is generated at mesh initialization time.
            When false and when mesh has more positions than <see cref="P:Ab3d.DirectX.DXHitTestOptions.MeshPositionsCountForOctTreeGeneration" />, then the OctTree is generated when first HitTest method is called on the mesh.
            Default value is false.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXHitTestOptions.OctTreeMaxNodeLevel">
            <summary>
            Number of levels used for OctTree - bigger number reduces the number of triangles in each node but increased the OctTree initialization time and used memory. Default value is 4.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXHitTestOptions.OctTreeExpandChildBoundingBoxes">
            <summary>
            ExpandChildBoundingBoxes is a float that defined how much the bounding boxes of node overlap.
            By default the value is set to 0.2 - so each bounding box is extended for 20% (but it does not go out of the parent's bounding box).
            This way the triangles that lay on node borders will be put into the child nodes instead of having them in the parent node (there we need to do a hit test every time).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXHitTestOptions.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXHitTestOptions.Clone">
            <summary>
            Returns a cloned version of this DXHitTestOptions.
            </summary>
            <returns>cloned version of this DXHitTestOptions</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXHitTestOptions.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.DXHitTestOptions.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.DXHitTestResult">
            <summary>
            DXHitTestResult is a base class for hit test results in DXEngine.
            </summary>
            <remarks>
                <para>
            DXHitTestResult is a base class for hit test results in DXEngine.
            </para>
                <para>
            The base class defines only <see cref="F:Ab3d.DirectX.DXHitTestResult.HitSceneNode" /> field.
            </para>
                <para>
            The virtual <see cref="M:Ab3d.DirectX.DXHitTestResult.IsSameObject(Ab3d.DirectX.DXHitTestResult)" /> should be overridden by derived classes to provide custom logic when MouseLeave and MouseEnter events should be triggered.
            By default this happens when the <see cref="F:Ab3d.DirectX.DXHitTestResult.HitSceneNode" /> is changed. But when one SceneNode can show multiple objects (for examples with objects instancing),
            then the custom IsSameObject method can trigger MouseLeave and MouseEnter events in case mouse moves to another part of the SceneNode (another object's instance).
            </para>
            </remarks>
        </member>
        <member name="F:Ab3d.DirectX.DXHitTestResult.HitSceneNode">
            <summary>
            Hit SceneNode (can be null when no object was hit)
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXHitTestResult.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXHitTestResult.#ctor(Ab3d.DirectX.SceneNode)">
            <summary>
            Constructor
            </summary>
            <param name="hitSceneNode">hit SceneNode (can be null when no object was hit)</param>
        </member>
        <member name="M:Ab3d.DirectX.DXHitTestResult.IsSameObject(Ab3d.DirectX.DXHitTestResult)">
            <summary>
            Returns true when the other DXHitTestResult represents the same object.
            When false is returned then new MouseLeave and MouseEnter events will be triggered.
            </summary>
            <param name="otherHitTestResult">other DXHitTestResult</param>
            <returns>true when the other DXHitTestResult represents the same object</returns>
        </member>
        <member name="T:Ab3d.DirectX.DXRayHitTestResult">
            <summary>
            DXRayHitTestResult class provides result of a ray hit test.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXRayHitTestResult.HitPosition">
            <summary>
            Vector3 that specifies hit position.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXRayHitTestResult.DistanceToRayOrigin">
            <summary>
            Distance to the ray's origin.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXRayHitTestResult.TriangleIndex">
            <summary>
            Index of the hit triangle.
            TriangleIndex can be converted into an index in the TriangleIndices collection or in indexBuffer with multiplying the TriangleIndex by 3.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXRayHitTestResult.#ctor(SharpDX.Vector3,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="hitPosition">Vector3 that specifies hit position</param>
            <param name="distanceToRayOrigin">Distance to the ray's origin</param>
        </member>
        <member name="M:Ab3d.DirectX.DXRayHitTestResult.#ctor(SharpDX.Vector3,Ab3d.DirectX.SceneNode,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="hitPosition">Vector3 that specifies hit position</param>
            <param name="hitSceneNode">hit SceneNode</param>
            <param name="distanceToRayOrigin">Distance to the ray's origin</param>
        </member>
        <member name="T:Ab3d.DirectX.DXRayInstancedHitTestResult">
            <summary>
            DXRayInstancedHitTestResult class provides result of a ray hit test that is executed on instanced object.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXRayInstancedHitTestResult.HitInstanceIndex">
            <summary>
            Index of hit instance
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXRayInstancedHitTestResult.#ctor(SharpDX.Vector3,Ab3d.DirectX.SceneNode,System.Single,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="hitPosition">Vector3 that specifies hit position</param>
            <param name="hitSceneNode">hit SceneNode</param>
            <param name="distanceToRayOrigin">Distance to the ray's origin</param>
            <param name="hitInstanceIndex">Index of hit instance</param>
        </member>
        <member name="M:Ab3d.DirectX.DXRayInstancedHitTestResult.#ctor(Ab3d.DirectX.DXRayHitTestResult,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="dxRayHitTestResult">DXRayHitTestResult</param>
            <param name="hitInstanceIndex">Index of hit instance</param>
        </member>
        <member name="M:Ab3d.DirectX.DXRayInstancedHitTestResult.IsSameObject(Ab3d.DirectX.DXHitTestResult)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.Lights.AmbientLight">
            <summary>
            AmbientLight is a lights that adds the specified color to all objects in the scene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.AmbientLight.Color">
            <summary>
            Gets or sets an ambient color.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Lights.AmbientLight.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.Lights.AmbientLight" /> class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Lights.AmbientLight.#ctor(SharpDX.Color3)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.Lights.AmbientLight" /> class.
            </summary>
            <param name="color">Color3</param>
        </member>
        <member name="M:Ab3d.DirectX.Lights.AmbientLight.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.Lights.AmbientLight" /> class.
            </summary>
            <param name="intensity">intensity can be from 0 to 1 - 0 means Black color, 1 means White color</param>
        </member>
        <member name="M:Ab3d.DirectX.Lights.AmbientLight.SetIntensity(System.Single)">
            <summary>
            Sets the intensity of the ambient light - intensity can be from 0 to 1 - 0 means Black color, 1 means White color.
            </summary>
            <param name="intensity">intensity can be from 0 to 1 - 0 means Black color, 1 means White color</param>
        </member>
        <member name="M:Ab3d.DirectX.Lights.AmbientLight.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Ab3d.DirectX.Lights.DirectionalLight">
            <summary>
            DirectionalLight is a lights that shines from infinint and has a direction vector set.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.DirectionalLight.Direction">
            <summary>
            Gets or sets a Vector3 that specifies the direction of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.DirectionalLight.DiffuseColor">
            <summary>
            Gets or sets a Color3 that specifies the diffuse color of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.DirectionalLight.SpecularColor">
            <summary>
            Gets or sets a Color3 that specifies the specular color of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.DirectionalLight.IsCastingShadow">
            <summary>
            Gets or sets a Booleans that specifies if this light casts a shadow.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Lights.DirectionalLight.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.Lights.DirectionalLight" /> class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Lights.DirectionalLight.#ctor(SharpDX.Vector3)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.Lights.DirectionalLight" /> class.
            </summary>
            <param name="direction">Vector3 that specifies the direction of this light</param>
        </member>
        <member name="M:Ab3d.DirectX.Lights.DirectionalLight.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Ab3d.DirectX.Lights.IAmbientLight">
            <summary>
            IAmbientLight interface represents an ambient light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.IAmbientLight.Color">
            <summary>
            Gets an ambient color.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Lights.IDirectionalLight">
            <summary>
            IDirectionalLight interface defines a lights that shines from infinint and has a direction vector set.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.IDirectionalLight.Direction">
            <summary>
            Gets a Vector3 that specifies the direction of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.IDirectionalLight.DiffuseColor">
            <summary>
            Gets a Color3 that specifies the diffuse color of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.IDirectionalLight.SpecularColor">
            <summary>
            Gets a Color3 that specifies the specular color of this light.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Lights.ILight">
            <summary>
            ILight interface represents a 3D light
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.ILight.ParentSceneNode">
            <summary>
            Gets a parent SceneNode - the transformation of the parent SceneNode also affect this light. ParentSceneNode can be null.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.ILight.IsEnabled">
            <summary>
            Gets a boolean that specifies if this light is enabled (turned on).
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Lights.IPointLight">
            <summary>
            IPointLight interface represents a lights that emits light in all directions from a specifed position.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.IPointLight.DiffuseColor">
            <summary>
            Gets a Color3 that specifies a diffuse color of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.IPointLight.SpecularColor">
            <summary>
            Gets a Color3 that specifies a specular color of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.IPointLight.Position">
            <summary>
            Gets a Vector3 that specifies the positions of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.IPointLight.Range">
            <summary>
            Gets a range of this point light - range does not affect the light brightness but just disables light calculation for all pixels that are farther away.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.IPointLight.Attenuation">
            <summary>
            Gets a Vector3 that specifies the parameters for the quadratic light function - the Vector3 components are: constant, linear and quadratic parameter.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Lights.IShadowCastingLight">
            <summary>
            IShadowCastingLight interface represents a lights that can cast a shadow.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.IShadowCastingLight.IsCastingShadow">
            <summary>
            Gets or sets a Booleans that specifies if this light casts a shadow.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Lights.ISpotLight">
            <summary>
            ISpotLight interface defines a lights that emits lights that is positions in the specified positions and emits light in a specfied directon and with specified cone.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.ISpotLight.Direction">
            <summary>
            Gets a Vector3 that specifies the direction of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.ISpotLight.InnerConeAngle">
            <summary>
            Gets an inner cone angle in degrees.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.ISpotLight.OuterConeAngle">
            <summary>
            Gets an outer cone angle in degrees.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.ISpotLight.FallOff">
            <summary>
            Gets a fallout value that specifies how the light intensity attenuates between inner and outer cone.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Lights.LightBase">
            <summary>
            LightBase is a base light class
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.LightBase.ParentSceneNode">
            <summary>
            Gets or sets a parent SceneNode - the transformation of the parent SceneNode also affect this light. ParentSceneNode can be null.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.LightBase.IsEnabled">
            <summary>
            Gets or sets a boolean that specifies if this light is enabled (turned on).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Lights.LightBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.Lights.LightBase" /> class.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Lights.PointLight">
            <summary>
            PointLight is a lights that emits light in all directions from a specifed position.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.PointLight.DiffuseColor">
            <summary>
            Gets or sets a Color3 that specifies a diffuse color of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.PointLight.SpecularColor">
            <summary>
            Gets or sets a Color3 that specifies a specular color of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.PointLight.Position">
            <summary>
            Gets or sets a Vector3 that specifies the positions of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.PointLight.Range">
            <summary>
            Gets or sets a range of this point light - range does not affect the light brightness but just disables light calculation for all pixels that are farther away.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.PointLight.Attenuation">
            <summary>
            Gets or sets a Vector3 that specifies the parameters for the quadratic light function - the Vector3 components are: constant, linear and quadratic parameter. Default value is (1, 0, 0)
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Lights.PointLight.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.Lights.PointLight" /> class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Lights.PointLight.#ctor(SharpDX.Vector3,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.Lights.PointLight" /> class.
            </summary>
            <param name="position">Vector3 that specifies the positions of this light</param>
            <param name="range">range of this point light - range does not affect the light brightness but just disables light calculation for all pixels that are farther away.</param>
        </member>
        <member name="M:Ab3d.DirectX.Lights.PointLight.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Ab3d.DirectX.Lights.SpotLight">
            <summary>
            SpotLight is a lights that emits lights that is positions in the specified positions and emits light in a specfied directon and with specified cone.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Lights.SpotLight.DefaultFallout">
            <summary>
            Default FallOff value for SpotLight
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.SpotLight.Direction">
            <summary>
            Gets or sets a Vector3 that specifies the direction of this light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.SpotLight.InnerConeAngle">
            <summary>
            Gets or sets an inner cone angle in degrees.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.SpotLight.OuterConeAngle">
            <summary>
            Gets or sets an outer cone angle in degrees.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.SpotLight.FallOff">
            <summary>
            Gets or sets a fallout value that specifies how the light intensity attenuates between inner and outer cone.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Lights.SpotLight.IsCastingShadow">
            <summary>
            Gets or sets a Booleans that specifies if this light casts a shadow.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Lights.SpotLight.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.Lights.SpotLight" /> class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Lights.SpotLight.#ctor(SharpDX.Vector3,System.Single,SharpDX.Vector3)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.Lights.SpotLight" /> class.
            </summary>
            <param name="position">Vector3 that specifies the positions of this light</param>
            <param name="range">range of this point light - range does not affect the light brightness but just disables light calculation for all pixels that are farther away</param>
            <param name="direction">Vector3 that specifies the direction of this light</param>
        </member>
        <member name="M:Ab3d.DirectX.Lights.SpotLight.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Ab3d.DirectX.ILightNode">
            <summary>
            ILightNode interface is used by SceneNodes that contain a light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ILightNode.Light">
            <summary>
            Gets the light defined by this SceneNode.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.EffectMaterial">
            <summary>
            EffectMaterial is a material that uses the custom Effect to draw the material.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.EffectMaterial.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.EffectMaterial.#ctor(Ab3d.DirectX.Effect)">
            <summary>
            Constructor
            </summary>
            <param name="effect">effect</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.EffectMaterial.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            OnInitializeResources
            </summary>
            <param name="dxDevice">DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.EffectMaterial.ToString">
            <summary>
            ToString
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Ab3d.DirectX.Materials.HiddenLineMaterial">
            <summary>
            HiddenLineMaterial defines properties for 3D lines that will be rendered only in parts that should be hidden - line parts that are behind other 3D objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.HiddenLineMaterial.LineColor">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.HiddenLineMaterial.LineThickness">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.HiddenLineMaterial.DepthBias">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.HiddenLineMaterial.IsPolyLine">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.HiddenLineMaterial.MiterLimit">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.HiddenLineMaterial.LinePattern">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.HiddenLineMaterial.LinePatternScale">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.HiddenLineMaterial.LinePatternOffset">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.HiddenLineMaterial.IsRenderingOnlyHiddenLines">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.Materials.HiddenLineMaterial.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.HiddenLineMaterial.#ctor(SharpDX.Color4,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="lineColor">lineColor</param>
            <param name="lineThickness">lineThickness</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.HiddenLineMaterial.OnEffectChanged(Ab3d.DirectX.Effect,Ab3d.DirectX.Effect)">
            <summary>
            OnEffectChanged is called after the effect is changed - overridden methods can return false to prevent the change of effect.
            </summary>
            <param name="oldEffect">old Effect</param>
            <param name="newEffect">new Effect</param>
            <returns>false to prevent the change, true to allow the change</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.HiddenLineMaterial.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.HiddenLineMaterial.GetDefaultRenderingQueue(Ab3d.DirectX.DXScene)">
            <summary>
            Returns the RenderingQueue that should be used to render this material.
            </summary>
            <param name="parentDXScene">DXScene</param>
            <returns>RenderingQueue that should be used to render this material</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.HiddenLineMaterial.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.HiddenLineMaterial.ToString">
            <summary>
            ToString
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IConstantBuffersCache">
            <summary>
            IConstantBuffersCache interface can be implemented by a Material that supports cashing constant buffers.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IConstantBuffersCache.CachedConstantBuffers">
            <summary>
            Gets or sets an array of DirectX Constant buffers that can be created for this instance of Material.
            The buffers can be created in Effects and can be reused for multiple frames when the material is not changed.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IConstantBuffersCache.ConstantBuffersVersion">
            <summary>
            Gets or sets a version that was read from Material's Version at the time of creating the CachedConstantBuffers
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IDiffuseMaterial">
            <summary>
            IDiffuseMaterial interface defines properties that define a material that reflect diffuse light.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IDiffuseMaterial.Alpha">
            <summary>
            Gets a float value that defines the alpha value for the material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IDiffuseMaterial.AmbientColor">
            <summary>
            Gets a Color3 that specifies an color that defines how much ambient color is reflected by this material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IDiffuseMaterial.DiffuseColor">
            <summary>
            Gets a Color3 that specifies the diffuse color of this material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IDiffuseMaterial.IsPreMultipliedAlphaColor">
            <summary>
            When IsPreMultipliedAlphaColor is true (false by default) and Alpha is less then 1, then the color components of the <see cref="P:Ab3d.DirectX.Materials.IDiffuseMaterial.DiffuseColor" /> are already multiplied with alpha value to produce pre-multiplied colors.
            When false, then non-premultiplied color is converted in pre-multiplied color when this is required by the shader.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IDiffuseTextureMaterial">
            <summary>
            IDiffuseTextureMaterial interface defines properties that define a material with textures.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IDiffuseTextureMaterial.TextureResourceName">
            <summary>
            Gets a string that can be used to specify the name of the texture - this is usually a file name.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IDiffuseTextureMaterial.DiffuseTextures">
            <summary>
            Gets an array of ShaderResourceView that define the textures.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IDiffuseTextureMaterial.SamplerStates">
            <summary>
            Gets an array of SamplerState that define the state of the samplers.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IDiffuseTextureMaterial.TextureBlendState">
            <summary>
            Gets a BlendState that is used to render the texture. If null a CommonStates.Opaque will be used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IDiffuseTextureMaterial.AlphaClipThreshold">
            <summary>
            Pixels with alpha color values below this value will be clipped (not rendered and their depth will not be written to depth buffer).
            Expected values are between 0 and 1.
            When 0 (by default) then alpha clipping is disabled - this means that also pixels with alpha value 0 are fully processed (they are not visible but its depth value is still written so objects that are rendered afterwards and are behind the pixel will not be visible).
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IEmissiveMaterial">
            <summary>
            IEmissiveMaterial interface defines properties that define a material that emit the light in a specifed color - the object is always in the EmissiveColor regardless of the lights.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IEmissiveMaterial.HasOnlyEmissiveColor">
            <summary>
            Gets a Boolean that specifies if this material has only emissive color.
            If false than other material properties are also defined.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IEmissiveMaterial.EmissiveColor">
            <summary>
            Gets a Color3 that that represents the emissive color - the color of the object regardless of the lights.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IEnvironmentalMapMaterial">
            <summary>
            IEnvironmentalMapMaterial interface defines properties that define a material that show reflection of the environment defined by the EnvironmentalCubeMap.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IEnvironmentalMapMaterial.EnvironmentalCubeMap">
            <summary>
            Gets ShaderResourceView that defines the EnvironmentalCubeMap. 
            ShaderResourceView should define a cube map with 6 textures for each side of the cube.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IEnvironmentalMapMaterial.ReflectionFactor">
            <summary>
            Gets reflection factor from 0 to 1 that is used when <see cref="P:Ab3d.DirectX.Materials.IEnvironmentalMapMaterial.ReflectionMap" /> is not set (is null). 
            Values 1 means full reflection (only enviromental map will be shown) and 0 means that only diffuse material without environmental map is shown.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IEnvironmentalMapMaterial.ReflectionMap">
            <summary>
            Gets ShaderResourceView that defines the reflection map where white colors mean fully reflective image and black colors mean no reflection (fully diffuse).
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IHiddenLineMaterial">
            <summary>
            IHiddenLineMaterial interface provides a property that specify if the hidden part of the line will be rendered.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IHiddenLineMaterial.IsRenderingOnlyHiddenLines">
            <summary>
            Gets a boolean that specifies if line with this material will be rendered when it is in front of other 3D objects 
            (IsRenderingOnlyHiddenLines is false), or when the line is hidden - is behind other 3D objects (IsRenderingOnlyHiddenLines is true)
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.ILineMaterial">
            <summary>
            ILineMaterial interface defines properties that define a line material - 3D object with this material will be rendered as wireframe.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.ILineMaterial.LineColor">
            <summary>
            Gets the color of the line.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.ILineMaterial.LineThickness">
            <summary>
            Gets the thickness of the line in screen space units.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.ILineMaterial.DepthBias">
            <summary>
            Gets a float that specifies a bias that is used when doing a depth test.
            A bias is a value that specifies how much the line is moved closer to the camera. The value is specified in world coordinates.
            When camera is farther away from the object, then a bigger DepthBias is needed.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.ILinePattern">
            <summary>
            ILinePattern interface can be implemented by a Line material that support line patterns.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.ILinePattern.LinePattern">
            <summary>
            Gets the 16 bit int value that defines the line pattern - if bit is 1 then line is drawn, when 0 line is not drawn.
            For example value 0xFFFF means full line without any dots or dashes. Value 0x5555 means line with dots - one full dot follows one empty dot.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.ILinePattern.LinePatternScale">
            <summary>
            Gets the pattern scale factor. Value 1 does not scale the pattern. Values bigger then 1 increase the pattern length; values smaller then 1 decrease the pattern length (making it more dense).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.ILinePattern.LinePatternOffset">
            <summary>
            Gets a pattern offset. This value is usually between 0 and 1 - 0 value means no offset, 1 means offset for the whole patter which is the same as no offset. Value 0.1 means that the line will begin with the pattern advanced by 10%.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.ILineRenderingTechnique">
            <summary>
            ILineRenderingTechnique interface is used to override the DXScene line rendering setting.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.ILineRenderingTechnique.UseGeometryShaderFor3DLines">
            <summary>
            When UseGeometryShaderFor3DLines is not null, then this overrides the <see cref="P:Ab3d.DirectX.DXScene.UseGeometryShaderFor3DLines" /> setting in DXScene object.
            If set to false and also the <see cref="P:Ab3d.DirectX.Materials.ILineRenderingTechnique.RenderAntialiased3DLines" /> is set to false, then the lines are always rendered as 1 pixel thick lines.
            Note that when using super-sampling the line rendered with that DXAttribute become dimmer because the super-sampled image is still rendered with 1 pixel thick line and that is then down-sampled to final image.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.ILineRenderingTechnique.RenderAntialiased3DLines">
            <summary>
            When RenderAntialiased3DLines  is not null, then this overrides the <see cref="P:Ab3d.DirectX.DXScene.RenderAntialiased3DLines" /> setting in DXScene object.
            This setting can be used only when <see cref="P:Ab3d.DirectX.Materials.ILineRenderingTechnique.UseGeometryShaderFor3DLines" /> is set to false.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IMultiMapMaterial">
            <summary>
            IMultiMapMaterial interface defines TextureMaps property that is a list of <see cref="T:Ab3d.DirectX.Materials.TextureMapInfo" /> objects
            and is used to define a material that uses multiple texture maps.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IMultiMapMaterial.TextureMaps">
            <summary>
            Gets a list of <see cref="T:Ab3d.DirectX.Materials.TextureMapInfo" /> object that defines texture maps that should be rendered with this material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IMultiMapMaterial.BlendState">
            <summary>
            Gets a BlendState that is used to render the base texture. If null a <see cref="P:Ab3d.DirectX.CommonStates.Opaque" /> or a <see cref="P:Ab3d.DirectX.CommonStates.PremultipliedAdditiveBlend" /> (in case of transparency) will be used.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IPhysicallyBasedMaterial">
            <summary>
            IPhysicallyBasedMaterial interface defines basic values that are used with material for Physically based rendering (PBR material).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IPhysicallyBasedMaterial.BaseColor">
            <summary>
            Color4 used for diffuse colors in non-metals ("dielectrics") or specular color in metals.
            When used with BaseColor texture, this color defines a color mask that is multiplied with each texture value.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IPhysicallyBasedMaterial.Metalness">
            <summary>
            Float value that specifies the amount of metalness - 0 for non-metal; 1 for raw metal.
            When used with Metalness texture, this value defines a mask that is multiplied with each texture value.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IPhysicallyBasedMaterial.Roughness">
            <summary>
            Float value that defines surface irregularities - 0 for totally flat surface; 1 for rough surface without any reflection.
            When used with Roughness texture, this value defines a mask that is multiplied with each texture value.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IPhysicallyBasedMaterial.AmbientOcclusionFactor">
            <summary>
            Float value that defines a factor that is multiplied with the ambient occlusion texture (when specified).
            Default value is 1 which does not change the values in the texture.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IPixelMaterial">
            <summary>
            IPixelMaterial interface defines properties that define a pixel material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IPixelMaterial.PixelColor">
            <summary>
            Gets the color of the pixels.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IPixelMaterial.PixelSize">
            <summary>
            Gets the width and height of the pixel in screen space units.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IPolyLine">
            <summary>
            IPolyLine interface is used by line materials that can define poly lines (connected line segments).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IPolyLine.IsPolyLine">
            <summary>
            Gets a Boolean that specifies if the line segments are rendered as polyline with connected segments (when true), or disconnected segments (when false).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IPolyLine.MiterLimit">
            <summary>
            Gets a value that defines at which line thickness the mitered (sharp) line joint is converted into beveled (square) line joint.
            For example, a value of 4 requires the mitered joint length to be 4 times the line thickness before the joint becomes beveled.
            MiterLimit is used only when IsPolyLine is set to true.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.ISpecularMaterial">
            <summary>
            ISpecularMaterial interface defines properties that define specular properties of the material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.ISpecularMaterial.HasSpecularColor">
            <summary>
            Gets a boolean that specifies if this material is using specular effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.ISpecularMaterial.SpecularColor">
            <summary>
            Gets the Color3 that specifies the color used to draw the specular highlight effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.ISpecularMaterial.SpecularPower">
            <summary>
            Gets a float that specifies the power of the specular effect. Zero values means that the specular effect is turned off.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.ITransparentMaterial">
            <summary>
            ITransparentMaterial interface defines HasTransparency property that specifies if this material need to be rendered with alpha blending enabled.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.ITransparentMaterial.HasTransparency">
            <summary>
            Gets a boolean that specifies if this material is semi-transparent and needs to be alpha blended with the scene.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IVertexColorMaterial">
            <summary>
            IVertexColorMaterial interface defines the VertexColorsVertexBufferBinding property that is used to specify vertex buffer that defines colors for each position.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IVertexColorMaterial.VertexColorsVertexBufferBinding">
            <summary>
            Gets a VertexBufferBinding for an array of Color4 values where each value represents a color of one position.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IVertexScalesMaterial">
            <summary>
            IVertexSizeMaterial interface defines the VertexSizesVertexBufferBinding property that is used to specify vertex buffer that defines scales (as one float value) for each position.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IVertexScalesMaterial.VertexScalesVertexBufferBinding">
            <summary>
            Gets a VertexBufferBinding for an array of float values where each value represents a scale (or size) of one position.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.IZBufferStateMaterial">
            <summary>
            IZBufferStateMaterial defines ReadZBuffer and WriteZBuffer properties that control how ZBuffer is used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IZBufferStateMaterial.ReadZBuffer">
            <summary>
            Gets a Boolean that specifies if Z buffer is read when rendering the object - if the depth test is done when rendering the object.
            If false then the object is rendered regardless of its depth - if is rendered even if it is behind some other 3D objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.IZBufferStateMaterial.WriteZBuffer">
            <summary>
            Gets a Boolean that specifies if Z buffer is written when rendering the object - if the object can occlude other 3D objects.
            If true then the objects behind the object will not be rendered. If false the object will not prevent rendering objects behind it.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.LineMaterial">
            <summary>
            LineMaterial defines properties that define how 3D lines are drawn.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.LineMaterial.DefaultMiterLimit">
            <summary>
            Miter limit value that is used when the <see cref="P:Ab3d.DirectX.Materials.LineMaterial.MiterLimit" /> is explicitly not specified.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.LineMaterial.LineColor">
            <summary>
            Gets or sets the color of the line that is determined from the WpfModel material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.LineMaterial.LineThickness">
            <summary>
            Gets or sets the thickness of the line in screen space units. This value is scaled with DPI scale factor.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.LineMaterial.ReadZBuffer">
            <summary>
            Gets or sets a Boolean that specifies if Z buffer is read when rendering the line - if the depth test is done when rendering the line.
            If false then the line is rendered regardless of its depth - if is rendered even if it is behind some other 3D objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.LineMaterial.WriteZBuffer">
            <summary>
            Gets or sets a Boolean that specifies if Z buffer is written when rendering the line - if the line can occlude other 3D objects.
            If true then the objects behind the line will not be rendered. If false the line will not prevent rendering objects behind it.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.LineMaterial.DepthBias">
            <summary>
            Gets a float that specifies a bias that is used when doing a depth test.
            A bias is a value that specifies how much the line is moved closer to the camera. The value is specified in world coordinates.
            When camera is farther away from the object, then a bigger DepthBias is needed.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.LineMaterial.IsPolyLine">
            <summary>
            Gets or sets a Boolean that specifies if the line segments are rendered as polyline with connected segments (when true), or disconnected segments (when false).
            Default value is false.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.LineMaterial.MiterLimit">
            <summary>
            Gets or sets a float value that defines at which line thickness the mitered (sharp) line joint is converted into beveled (square) line joint.
            For example, a value of 4 requires the mitered joint length to be 4 times the line thickness before the joint becomes beveled.
            MiterLimit is used only when IsPolyLine is set to true.
            Default value is 2.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.LineMaterial.LinePattern">
            <summary>
            Gets or sets the 16 bit int value that defines the line pattern - if bit is 1 then line is drawn, when 0 line is not drawn.
            For example value 0xFFFF means full line without any dots or dashes. Value 0x5555 means line with dots - one full dot follows one empty dot.
            Default value is 0xFFFF which means that no pattern will be drawn.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.LineMaterial.LinePatternScale">
            <summary>
            Gets or sets the pattern scale factor. Value 1 does not scale the pattern. Values bigger then 1 increase the pattern length; values smaller then 1 decrease the pattern length (making it more dense).
            Default value is 1.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.LineMaterial.LinePatternOffset">
            <summary>
            Gets or sets a pattern offset. This value is usually between 0 and 1 - 0 value means no offset, 1 means offset for the whole patter which is the same as no offset. Value 0.1 means that the line will begin with the pattern advanced by 10%.
            Default value is 0.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.LineMaterial.UseGeometryShaderFor3DLines">
            <summary>
            When UseGeometryShaderFor3DLines is not null, then this overrides the <see cref="P:Ab3d.DirectX.DXScene.UseGeometryShaderFor3DLines" /> setting in DXScene object.
            If set to false and also the <see cref="P:Ab3d.DirectX.Materials.LineMaterial.RenderAntialiased3DLines" /> is set to false, then the lines are always rendered as 1 pixel thick lines.
            Note that when using super-sampling the line rendered with that DXAttribute become dimmer because the super-sampled image is still rendered with 1 pixel thick line and that is then down-sampled to final image.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.LineMaterial.RenderAntialiased3DLines">
            <summary>
            When RenderAntialiased3DLines  is not null, then this overrides the <see cref="P:Ab3d.DirectX.DXScene.RenderAntialiased3DLines" /> setting in DXScene object.
            This setting can be used only when <see cref="P:Ab3d.DirectX.Materials.LineMaterial.UseGeometryShaderFor3DLines" /> is set to false.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.LineMaterial.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.LineMaterial.#ctor(SharpDX.Color4,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="lineColor">lineColor</param>
            <param name="lineThickness">lineThickness</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.LineMaterial.OnEffectChanged(Ab3d.DirectX.Effect,Ab3d.DirectX.Effect)">
            <summary>
            OnEffectChanged is called after the effect is changed - overridden methods can return false to prevent the change of effect.
            </summary>
            <param name="oldEffect">old Effect</param>
            <param name="newEffect">new Effect</param>
            <returns>false to prevent the change, true to allow the change</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.LineMaterial.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.LineMaterial.GetDefaultRenderingQueue(Ab3d.DirectX.DXScene)">
            <summary>
            Returns the RenderingQueue that should be used to render this material.
            </summary>
            <param name="parentDXScene">DXScene</param>
            <returns>RenderingQueue that should be used to render this material</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.LineMaterial.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.LineMaterial.ToString">
            <summary>
            ToString
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Ab3d.DirectX.Materials.MultiMapMaterial">
            <summary>
            MultiMapMaterial class defines a DXEngine's material that can use multiple texture maps.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.TextureMaps">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.BlendState">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.HasTransparency">
            <summary>
            Gets or sets a boolean that specifies if this material is semi-transparent and needs to be alpha blended with the scene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.Alpha">
            <summary>
            Gets or sets a float value that defines the alpha value for the material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.AmbientColor">
            <summary>
            Gets or sets a Color3 that specifies an color that defines how much ambient color is reflected by this material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.DiffuseColor">
            <summary>
            Gets or sets a Color3 that specifies the diffuse color of this material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.IsPreMultipliedAlphaColor">
            <summary>
            When IsPreMultipliedAlphaColor is true (false by default) and Alpha is less then 1, then the color components of the <see cref="P:Ab3d.DirectX.Materials.MultiMapMaterial.DiffuseColor" /> are already multiplied with alpha value to produce pre-multiplied colors.
            When false, then non-pre-multiplied color is converted in pre-multiplied color when this is required by the shader.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.TextureResourceName">
            <summary>
            Gets or sets a string that can be used to specify the name of the texture - this can be a the file name of the texture file.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.DiffuseTextures">
            <summary>
            Gets or sets an array of ShaderResourceView that define the textures.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.SamplerStates">
            <summary>
            Gets or sets an array of SamplerState that define the state of the samplers.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.TextureBlendState">
            <summary>
            Gets a BlendState that is used to render the texture. If null a CommonStates.Opaque will be used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.AlphaClipThreshold">
            <summary>
            Pixels with alpha color values below this value will be clipped (not rendered and their depth will not be written to depth buffer).
            Expected values are between 0 and 1.
            When 0 (by default) then alpha clipping is disabled - this means that also pixels with alpha value 0 are fully processed (they are not visible but its depth value is still written so objects that are rendered afterwards and are behind the pixel will not be visible).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.HasSpecularColor">
            <summary>
            Gets a boolean that specifies if this material is using specular effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.SpecularColor">
            <summary>
            Gets or sets the Color3 that specifies the color used to draw the specular highlight effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.SpecularPower">
            <summary>
            Gets or sets a float that specifies the power of the specular effect. Zero values means that the specular effect is turned off.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.EmissiveColor">
            <summary>
            Gets or sets a Boolean that specifies if this material has only emissive color.
            If false than other material properties are also defined.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.MultiMapMaterial.HasOnlyEmissiveColor">
            <summary>
            Gets or sets a Color3 that that represents the emissive color - the color of the object regardless of the lights.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.MultiMapMaterial.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.MultiMapMaterial.SetTextureMap(Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.SamplerState,System.String)">
            <summary>
            SetTextureMap updates existing TextureMapInfo (when TextureMapInfo with the same mapType was already added) or adds a new TextureMapInfo to the <see cref="P:Ab3d.DirectX.Materials.MultiMapMaterial.TextureMaps" /> list.
            To preserve the existing SamplerState, you can use <see cref="M:Ab3d.DirectX.Materials.MultiMapMaterial.SetTextureMap(Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,System.String)" /> method.
            </summary>
            <param name="mapType">type of texture map - one of TextureMapTypes</param>
            <param name="newShaderResourceView">ShaderResourceView</param>
            <param name="newSamplerState">SamplerState</param>
            <param name="textureResourceName">File name or resource name of the texture map (optional and can be null)</param>
            <returns>newShaderResourceView</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.MultiMapMaterial.SetTextureMap(Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,System.String)">
            <summary>
            SetTextureMap updates existing TextureMapInfo (when TextureMapInfo with the same mapType was already added) or adds a new TextureMapInfo to the <see cref="P:Ab3d.DirectX.Materials.MultiMapMaterial.TextureMaps" /> list.
            To also set the SamplerState, you can use <see cref="M:Ab3d.DirectX.Materials.MultiMapMaterial.SetTextureMap(Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.SamplerState,System.String)" /> method.
            </summary>
            <param name="mapType">type of texture map - one of TextureMapTypes</param>
            <param name="newShaderResourceView">ShaderResourceView</param>
            <param name="textureResourceName">File name or resource name of the texture map (optional and can be null)</param>
            <returns>newShaderResourceView</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.MultiMapMaterial.RemoveTextureMap(Ab3d.DirectX.Materials.TextureMapTypes)">
            <summary>
            Removes all TextureMapInfo structs with the specified mapType from the <see cref="P:Ab3d.DirectX.Materials.MultiMapMaterial.TextureMaps" />.
            </summary>
            <param name="mapType">TextureMapTypes</param>
            <returns>true is any TextureMapInfo was removed</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.MultiMapMaterial.SetTextureMap(Ab3d.DirectX.Materials.IMultiMapMaterial,Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.SamplerState,System.String)">
            <summary>
            SetTextureMap updates existing TextureMapInfo (when TextureMapInfo with the same mapType was already added) or adds a new TextureMapInfo to the <see cref="P:Ab3d.DirectX.Materials.MultiMapMaterial.TextureMaps" /> list.
            To preserve the existing SamplerState, you can use <see cref="M:Ab3d.DirectX.Materials.MultiMapMaterial.SetTextureMap(Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,System.String)" /> method.
            </summary>
            <param name="multiMapMaterial">IMultiMapMaterial</param>
            <param name="mapType">type of texture map - one of TextureMapTypes</param>
            <param name="newShaderResourceView">ShaderResourceView</param>
            <param name="newSamplerState">SamplerState</param>
            <param name="textureResourceName">File name or resource name of the texture map (optional and can be null)</param>
            <returns>newShaderResourceView</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.MultiMapMaterial.SetTextureMap(Ab3d.DirectX.Materials.IMultiMapMaterial,Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,System.String)">
            <summary>
            SetTextureMap updates existing TextureMapInfo (when TextureMapInfo with the same mapType was already added) or adds a new TextureMapInfo to the <see cref="P:Ab3d.DirectX.Materials.MultiMapMaterial.TextureMaps" /> list.
            To preserve the existing SamplerState, you can use <see cref="M:Ab3d.DirectX.Materials.MultiMapMaterial.SetTextureMap(Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,System.String)" /> method.
            </summary>
            <param name="multiMapMaterial">IMultiMapMaterial</param>
            <param name="mapType">type of texture map - one of TextureMapTypes</param>
            <param name="newShaderResourceView">ShaderResourceView</param>
            <param name="textureResourceName">File name or resource name of the texture map (optional and can be null)</param>
            <returns>newShaderResourceView</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.MultiMapMaterial.RemoveTextureMap(Ab3d.DirectX.Materials.IMultiMapMaterial,Ab3d.DirectX.Materials.TextureMapTypes)">
            <summary>
            Removes all TextureMapInfo structs with the specified mapType from the TextureMaps
            </summary>
            <param name="multiMapMaterial">IMultiMapMaterial</param>
            <param name="mapType">TextureMapTypes</param>
            <returns>true is any TextureMapInfo was removed</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.MultiMapMaterial.ToString">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.Materials.PhysicallyBasedMaterial">
            <summary>
            PhysicallyBasedMaterial class defines a DXEngine's material that defines a material for Physically based rendering (PBR material).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.BaseColor">
            <summary>
            Color4 used for diffuse colors in non-metals ("dielectrics") or specular color in metals.
            When used with BaseColor texture, this color defines a color mask that is multiplied with each texture value.
            Default value is White.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.Metalness">
            <summary>
            Float value that specifies the amount of metalness - 0 for non-metal; 1 for raw metal.
            When used with Metalness texture, this value defines a mask that is multiplied with each texture value.
            Default value is 1.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.Roughness">
            <summary>
            Float value that defines surface irregularities - 0 for totally flat surface; 1 for rough surface without any reflection.
            When used with Roughness texture, this value defines a mask that is multiplied with each texture value.
            Default value is 1.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.AmbientOcclusionFactor">
            <summary>
            Float value that defines a factor that is multiplied with the ambient occlusion texture (when specified).
            Default value is 1 which does not change the values in the texture.
            Default value is 1.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.TextureMaps">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.BlendState">
            <summary>
            Gets a BlendState that is used to render the base texture. If null a <see cref="P:Ab3d.DirectX.CommonStates.Opaque" /> or a <see cref="P:Ab3d.DirectX.CommonStates.PremultipliedAdditiveBlend" /> (in case of transparency) will be used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.EmissiveColor">
            <summary>
            Gets or sets a Color3 that that represents the emissive color - the color of the object regardless of the lights.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.HasOnlyEmissiveColor">
            <summary>
            Gets a Boolean that specifies if this material has only emissive color. This property is not used in PhysicallyBasedMaterial and always returns false.   
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.HasTransparency">
            <summary>
            Gets a boolean that specifies if this material is semi-transparent and needs to be alpha blended with the scene.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.HasTextureMap(Ab3d.DirectX.Materials.TextureMapTypes)">
            <summary>
            Returns true if this PhysicallyBasedMaterial defines the specified map type (has specified MapType in TextureMaps and it has a ShaderResourceView that is not null).
            </summary>
            <param name="mapType">type of texture map - one of TextureMapTypes</param>
            <returns>true if this PhysicallyBasedMaterial defines the specified map type</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.SetTextureMap(Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.SamplerState,System.String)">
            <summary>
            SetTextureMap updates existing TextureMapInfo (when TextureMapInfo with the same mapType was already added) or adds a new TextureMapInfo to the <see cref="P:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.TextureMaps" /> list.
            To preserve the existing SamplerState, you can use <see cref="M:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.SetTextureMap(Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,System.String)" /> method.
            </summary>
            <param name="mapType">type of texture map - one of TextureMapTypes</param>
            <param name="newShaderResourceView">ShaderResourceView</param>
            <param name="newSamplerState">SamplerState</param>
            <param name="textureResourceName">File name or resource name of the texture map (optional and can be null)</param>
            <returns>newShaderResourceView</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.SetTextureMap(Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,System.String)">
            <summary>
            SetTextureMap updates existing TextureMapInfo (when TextureMapInfo with the same mapType was already added) or adds a new TextureMapInfo to the <see cref="P:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.TextureMaps" /> list.
            To also set the SamplerState, you can use <see cref="M:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.SetTextureMap(Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.SamplerState,System.String)" /> method.
            </summary>
            <param name="mapType">type of texture map - one of TextureMapTypes</param>
            <param name="newShaderResourceView">ShaderResourceView</param>
            <param name="textureResourceName">File name or resource name of the texture map (optional and can be null)</param>
            <returns>newShaderResourceView</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.RemoveTextureMap(Ab3d.DirectX.Materials.TextureMapTypes)">
            <summary>
            Removes all TextureMapInfo structs with the specified mapType from the <see cref="P:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.TextureMaps" />.
            </summary>
            <param name="mapType">TextureMapTypes</param>
            <returns>true is any TextureMapInfo was removed</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.OnEffectChanged(Ab3d.DirectX.Effect,Ab3d.DirectX.Effect)">
            <summary>
            OnEffectChanged is called after the effect is changed - overridden methods can return false to prevent the change of effect.
            </summary>
            <param name="oldEffect">old Effect</param>
            <param name="newEffect">new Effect</param>
            <returns>false to prevent the change, true to allow the change</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PhysicallyBasedMaterial.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Materials.PixelMaterial">
            <summary>
            PixelMaterial defines how 3D pixels are drawn with the <see cref="T:Ab3d.DirectX.Effects.PixelEffect" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PixelMaterial.PixelColor">
            <summary>
            Gets or sets the Color4 of pixels. Default value is White.
            When <see cref="P:Ab3d.DirectX.Materials.PixelMaterial.PixelColors" /> array is set, the value of this property is used as a mask that is multiplied with each color defined in the array.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PixelMaterial.PixelSize">
            <summary>
            Gets or sets the width and height of the pixel in screen space units. This value is scaled with DPI scale factor.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PixelMaterial.ReadZBuffer">
            <summary>
            Gets or sets a Boolean that specifies if Z buffer is read when rendering the pixel - if the depth test is done when rendering the pixel.
            If false then the pixel is rendered regardless of its depth - if is rendered even if it is behind some other 3D objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PixelMaterial.WriteZBuffer">
            <summary>
            Gets or sets a Boolean that specifies if Z buffer is written when rendering the pixel - if the pixel can occlude other 3D objects.
            If true then the objects behind the pixel will not be rendered. If false the line will not prevent rendering objects behind it.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PixelMaterial.CreateDynamicBuffer">
            <summary>
            Gets or sets a Boolean that specifies if a dynamic vertex buffer will be created from the <see cref="P:Ab3d.DirectX.Materials.PixelMaterial.PixelColors" /> array.
            This can be used in case when the colors change very often.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PixelMaterial.PixelColors">
            <summary>
            Gets or sets a Color4 array that specifies the colors for each pixel. When color's alpha is 0, the pixel is not rendered.
            When PixelColors array is set, the <see cref="P:Ab3d.DirectX.Materials.PixelMaterial.PixelColor" /> is used as a mask that is multiplied with each color defined in the array (set PixelColor to White to use the values specified in this array).
            When null, the color of all the pixels is set by the color defined by the <see cref="P:Ab3d.DirectX.Materials.PixelMaterial.PixelColor" /> property.
            When individual values of PixelColors are changed, you need to call <see cref="M:Ab3d.DirectX.Materials.PixelMaterial.UpdatePixelColors" /> method for the changes to take effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PixelMaterial.PixelSizes">
            <summary>
            Gets or sets a float array that specifies the sizes for each pixel. When size is less of equal to 0, the pixel is not rendered.
            When PixelSizes array is set, the <see cref="P:Ab3d.DirectX.Materials.PixelMaterial.PixelSize" /> value is multiplied with each size defined in the array (set PixelSize to 1 to use the values specified in this array).
            When null, the size of all the pixels is set by the value defined by the <see cref="P:Ab3d.DirectX.Materials.PixelMaterial.PixelSize" /> property.
            When individual values of PixelSizes are changed, you need to call <see cref="M:Ab3d.DirectX.Materials.PixelMaterial.UpdatePixelSizes" /> method for the changes to take effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PixelMaterial.VertexColorsVertexBufferBinding">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.PixelMaterial.VertexScalesVertexBufferBinding">
            <summary>
            Gets a VertexBufferBinding that is created from <see cref="P:Ab3d.DirectX.Materials.PixelMaterial.PixelSizes" /> array.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PixelMaterial.#ctor">
            <summary>
            Constructor with white color and pixel size set to 1.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PixelMaterial.#ctor(SharpDX.Color4,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="pixelColor">pixelColor</param>
            <param name="pixelSize">pixelSize</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PixelMaterial.UpdatePixelColors">
            <summary>
            UpdatePixelColors method updates the DirectX vertex buffer from the current values of <see cref="P:Ab3d.DirectX.Materials.PixelMaterial.PixelColors" />.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PixelMaterial.UpdatePixelSizes">
            <summary>
            UpdatePixelSizes method updates the DirectX vertex buffer from the current values of <see cref="P:Ab3d.DirectX.Materials.PixelMaterial.PixelSize" />.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PixelMaterial.OnEffectChanged(Ab3d.DirectX.Effect,Ab3d.DirectX.Effect)">
            <summary>
            OnEffectChanged is called after the effect is changed - overridden methods can return false to prevent the change of effect.
            </summary>
            <param name="oldEffect">old Effect</param>
            <param name="newEffect">new Effect</param>
            <returns>false to prevent the change, true to allow the change</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PixelMaterial.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PixelMaterial.GetDefaultRenderingQueue(Ab3d.DirectX.DXScene)">
            <summary>
            Returns the RenderingQueue that should be used to render this material.
            </summary>
            <param name="parentDXScene">DXScene</param>
            <returns>RenderingQueue that should be used to render this material</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PixelMaterial.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PixelMaterial.ToString">
            <summary>
            ToString
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Ab3d.DirectX.Materials.PositionColoredLineMaterial">
            <summary>
            PositionColoredLineMaterial is a <see cref="T:Ab3d.DirectX.Materials.LineMaterial" /> that contains additional properties
            that can be used to render 3D lines with different start and end colors.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PositionColoredLineMaterial.VertexColorsVertexBufferBinding">
            <summary>
            Gets a VertexBufferBinding for an array of Color4 values where each value represents a color of one position.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PositionColoredLineMaterial.HasTransparency">
            <summary>
            Gets a boolean that specifies if this material is semi-transparent and needs to be alpha blended with the scene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PositionColoredLineMaterial.CreateDynamicBuffer">
            <summary>
            Gets or sets a Boolean that specifies if a dynamic vertex buffer will be created from the <see cref="P:Ab3d.DirectX.Materials.PositionColoredLineMaterial.PositionColors" /> array.
            This can be used in case when the colors change very often.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.PositionColoredLineMaterial.PositionColors">
            <summary>
            Gets or sets the Color4 array that specifies the colors for each position of the object.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PositionColoredLineMaterial.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PositionColoredLineMaterial.Update">
            <summary>
            Update method updates the DirectX vertex buffer from the current values of <see cref="P:Ab3d.DirectX.Materials.PositionColoredLineMaterial.PositionColors" />.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PositionColoredLineMaterial.GetDefaultRenderingQueue(Ab3d.DirectX.DXScene)">
            <summary>
            Returns the RenderingQueue that should be used to render this material.
            </summary>
            <param name="parentDXScene">DXScene</param>
            <returns>RenderingQueue that should be used to render this material</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PositionColoredLineMaterial.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.PositionColoredLineMaterial.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Materials.StandardMaterial">
            <summary>
            StandardMaterial is a material that defines the standard properties to show the diffuse, specular and emissive material properties.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.StandardMaterial.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.StandardMaterial.#ctor(SharpDX.Color3,System.Single)">
            <summary>
            StandardMaterial constructor with a diffuse color and an alpha value (alpha is 1 when not specified)
            </summary>
            <param name="diffuseColor">diffuseColor as Color3</param>
            <param name="alpha">optional alpha value (1 by default)</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.StandardMaterial.#ctor(SharpDX.Color4)">
            <summary>
            StandardMaterial constructor with diffuse color and alpha specified in Color4 struct.
            </summary>
            <param name="diffuseColorWithAlpha">diffuseColor as Color4</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.StandardMaterial.#ctor(SharpDX.Direct3D11.ShaderResourceView,System.Boolean)">
            <summary>
            StandardMaterial constructor with diffuse texture specified with textureShaderResourceView
            </summary>
            <param name="textureShaderResourceView">texture as ShaderResourceView</param>
            <param name="hasTransparency">Boolean that specifies if the loaded image has transparency</param>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.HasTransparency">
            <summary>
            Gets or sets a boolean that specifies if this material is semi-transparent and needs to be alpha blended with the scene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.Alpha">
            <summary>
            Gets or sets a float value that defines the alpha value for the material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.AmbientColor">
            <summary>
            Gets or sets a Color3 that specifies an color that defines how much ambient color is reflected by this material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.DiffuseColor">
            <summary>
            Gets or sets a Color3 that specifies the diffuse color of this material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.IsPreMultipliedAlphaColor">
            <summary>
            When IsPreMultipliedAlphaColor is true (false by default) and Alpha is less then 1, then the color components of the <see cref="P:Ab3d.DirectX.Materials.StandardMaterial.DiffuseColor" /> are already multiplied with alpha value to produce pre-multiplied colors.
            When false, then non-pre-multiplied color is converted in pre-multiplied color when this is required by the shader.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.TextureResourceName">
            <summary>
            Gets or sets a string that can be used to specify the name of the texture - this can be a the file name of the texture file.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.DiffuseTextures">
            <summary>
            Gets or sets an array of ShaderResourceView objects that define the textures.
            Note: setting ShaderResourceView objects to StandardMaterial does not increase reference count on the ShaderResourceView objects. This means that you should not dispose ShaderResourceView objects after they are set to this StandardMaterial.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.SamplerStates">
            <summary>
            Gets or sets an array of SamplerState objects that define the state of the samplers.
            Note: setting SamplerStates objects to StandardMaterial does not increase reference count on the SamplerStates objects. This means that you should not dispose SamplerStates objects after they are set to this StandardMaterial.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.TextureBlendState">
            <summary>
            Gets a BlendState that is used to render the texture. If null a CommonStates.Opaque will be used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.AlphaClipThreshold">
            <summary>
            Pixels with alpha color values below this value will be clipped (not rendered and their depth will not be written to depth buffer).
            Expected values are between 0 and 1.
            When 0 (by default) then alpha clipping is disabled - this means that also pixels with alpha value 0 are fully processed (they are not visible but its depth value is still written so objects that are rendered afterwards and are behind the pixel will not be visible).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.HasSpecularColor">
            <summary>
            Gets a boolean that specifies if this material is using specular effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.SpecularColor">
            <summary>
            Gets or sets the Color3 that specifies the color used to draw the specular highlight effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.SpecularPower">
            <summary>
            Gets or sets a float that specifies the power of the specular effect. Zero values means that the specular effect is turned off.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.EmissiveColor">
            <summary>
            Gets or sets a Color3 that that represents the emissive color - the color of the object regardless of the lights.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.StandardMaterial.HasOnlyEmissiveColor">
            <summary>
            Gets or sets a Boolean that specifies if this material has only emissive color.
            If false than other material properties are also defined.        
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.StandardMaterial.ToString">
            <summary>
            ToString
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Ab3d.DirectX.Materials.TextureMapInfo">
            <summary>
            TextureMapInfo class defines fields that describe one texture map.
            The class is used in <see cref="T:Ab3d.DirectX.Materials.IMultiMapMaterial" /> that is used by <see cref="T:Ab3d.DirectX.Materials.MultiMapMaterial" /> and <see cref="T:Ab3d.DirectX.Materials.PhysicallyBasedMaterial" />.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapInfo.TextureResourceName">
            <summary>
            File name or resource name of the texture map (optional and can be null)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapInfo.MapType">
            <summary>
            Type of texture map
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapInfo.ShaderResourceView">
            <summary>
            DirectX ShaderResourceView of the texture
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapInfo.SamplerState">
            <summary>
            SamplerState of the texture. When null, a default <see cref="P:Ab3d.DirectX.CommonStates.WrapSampler" /> is used.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.TextureMapInfo.#ctor(Ab3d.DirectX.Materials.TextureMapTypes,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.SamplerState,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="mapType">TextureMapTypes</param>
            <param name="shaderResourceView">ShaderResourceView</param>
            <param name="samplerState">SamplerState (when null, a default <see cref="P:Ab3d.DirectX.CommonStates.WrapSampler" /> is used)</param>
            <param name="textureResourceName">File name or resource name of the texture map (optional and can be null)</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.TextureMapInfo.ToString">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.Materials.TextureMapTypes">
            <summary>
            TextureMapTypes enum define possible types of texture maps. 
            The enum is used by the <see cref="T:Ab3d.DirectX.Materials.TextureMapInfo" /> class.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.DiffuseColor">
            <summary>
            Diffuse color
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.SpecularColor">
            <summary>
            Specular color
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.NormalMap">
            <summary>
            Normal map that specified normal adjustment vector.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.ReflectionMap">
            <summary>
            Reflection map that specifies which part or the object reflects the EnvironmentCubeMap
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.EnvironmentCubeMap">
            <summary>
            Environment as a CubeMap
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.Albedo">
            <summary>
            Albedo for PBR (Physically-based rendering)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.BaseColor">
            <summary>
            Base color for PBR (Physically-based rendering)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.Metalness">
            <summary>
            Metalness for PBR (Physically-based rendering)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.SpecularF0">
            <summary>
            Specular F0 for PBR (Physically-based rendering)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.Roughness">
            <summary>
            Roughness for PBR (Physically-based rendering)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.Glossiness">
            <summary>
            Glossiness for PBR (Physically-based rendering)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.AmbientOcclusion">
            <summary>
            Baked Ambient occlusion
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.MetalnessRoughness">
            <summary>
            One texture for both Metalness (as red channel) and Roughness (as green channel) values used for PBR (Physically-based rendering)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.Emissive">
            <summary>
            Emissive
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.Cavity">
            <summary>
            Cavity (not supported)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Materials.TextureMapTypes.Transparency">
            <summary>
            Transparency (not supported)
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.Materials.VertexColorMaterial">
            <summary>
            VertexColorMaterial can be used to render 3D objects with specifying color for each of its position.
            </summary>
            <remarks>
                <para>
            VertexColorMaterial can be used to render 3D objects with specifying color for each of its position.
            </para>
                <para>
            The colors of each position is specified in the <see cref="P:Ab3d.DirectX.Materials.VertexColorMaterial.PositionColors" /> array.
            </para>
                <para>
            When values in the <see cref="P:Ab3d.DirectX.Materials.VertexColorMaterial.PositionColors" /> array are changed, you need to call <see cref="M:Ab3d.DirectX.Materials.VertexColorMaterial.Update" /> method to update the DirectX resources.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.Materials.VertexColorMaterial.HasSpecularColor">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.VertexColorMaterial.SpecularColor">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.VertexColorMaterial.SpecularPower">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.VertexColorMaterial.HasTransparency">
            <inheritdoc />
        </member>
        <member name="P:Ab3d.DirectX.Materials.VertexColorMaterial.CreateDynamicBuffer">
            <summary>
            Gets or sets a Boolean that specifies if a dynamic vertex buffer will be created from the <see cref="P:Ab3d.DirectX.Materials.VertexColorMaterial.PositionColors" /> array.
            This can be used in case when the colors change very often.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.VertexColorMaterial.PositionColors">
            <summary>
            Gets or sets the Color4 array that specifies the colors for each position of the object.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Materials.VertexColorMaterial.VertexColorsVertexBufferBinding">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.Materials.VertexColorMaterial.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.VertexColorMaterial.#ctor(SharpDX.Color4[])">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.VertexColorMaterial.Update">
            <summary>
            Update method updates the DirectX vertex buffer from the current values of <see cref="P:Ab3d.DirectX.Materials.VertexColorMaterial.PositionColors" />.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Materials.VertexColorMaterial.OnEffectChanged(Ab3d.DirectX.Effect,Ab3d.DirectX.Effect)">
            <summary>
            OnEffectChanged is called after the effect is changed - overridden methods can return false to prevent the change of effect.
            </summary>
            <param name="oldEffect">old Effect</param>
            <param name="newEffect">new Effect</param>
            <returns>false to prevent the change, true to allow the change</returns>
        </member>
        <member name="M:Ab3d.DirectX.Materials.VertexColorMaterial.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.Materials.VertexColorMaterial.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Material">
            <summary>
            Material is a base abstract class from which all DXEngine's material must be derived from.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.Material.MaterialChanged">
            <summary>
            MaterialChanged
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Material.PreferedShaderQuality">
            <summary>
            Gets or sets a shader quality that should be used to render this material.
            When this property is set to any other value than Undefined (by default) it overrides the ShaderQuality setting set in GraphicsProfile.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Material.Effect">
            <summary>
            Gets or sets the Effect that is used to render this material.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Material.Version">
            <summary>
            Gets the version number of this Material. Version is increased each time the material is changed. 
            Note: When material is changed a lot of times, the Version value can overflow from positive to negative numbers (to prevent problems do not check for bigger value but for not equal value)
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Material.OnEffectChanged(Ab3d.DirectX.Effect,Ab3d.DirectX.Effect)">
            <summary>
            OnEffectChanged is called after the effect is changed - overridden methods can return false to prevent the change of effect.
            </summary>
            <param name="oldEffect">old Effect</param>
            <param name="newEffect">new Effect</param>
            <returns>false to prevent the change, true to allow the change</returns>
        </member>
        <member name="M:Ab3d.DirectX.Material.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            OnInitializeResources
            </summary>
            <param name="dxDevice">DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.Material.OnMaterialChanged">
            <summary>
            OnMaterialChanged
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Material.GetDefaultRenderingQueue(Ab3d.DirectX.DXScene)">
            <summary>
            Returns the RenderingQueue that should be used to render this material.
            The default method implementation returns <see cref="P:Ab3d.DirectX.DXScene.TransparentRenderingQueue" /> or <see cref="P:Ab3d.DirectX.DXScene.OtherGeometryRenderingQueue" /> based on the HasTransparency value.
            </summary>
            <param name="parentDXScene">DXScene</param>
            <returns>RenderingQueue that should be used to render this material</returns>
        </member>
        <member name="M:Ab3d.DirectX.Material.Refresh">
            <summary>
            Refresh method regenerates the material and the resources it created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Material.Clone">
            <summary>
            Clones the current material with creating a shallow copy of this Material (properties are copied but referenced objects are preserved).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Ab3d.DirectX.Material.ToString">
            <summary>
            ToString
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Ab3d.DirectX.ClonedRenderablePrimitive">
            <summary>
            ClonedRenderablePrimitive is rendered with the same resources as originalRenderablePrimitiveBase but with different Material.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ClonedRenderablePrimitive.OriginalRenderablePrimitive">
            <summary>
            OriginalRenderablePrimitive that was used to create this ClonedRenderablePrimitive
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ClonedRenderablePrimitive.#ctor(Ab3d.DirectX.RenderablePrimitive,Ab3d.DirectX.Material)">
            <summary>
            Constructor
            </summary>
            <param name="originalRenderablePrimitive">RenderablePrimitive that will be rendered again with new resources</param>
            <param name="material">New Material that will be used instead of Material defined in the originalRenderablePrimitiveBase</param>
        </member>
        <member name="M:Ab3d.DirectX.ClonedRenderablePrimitive.RenderGeometry(Ab3d.DirectX.RenderingContext)">
            <summary>
            RenderGeometry renders the geometry (executes draw calls but does not apply material settings)
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="T:Ab3d.DirectX.CustomRenderablePrimitive">
            <summary>
            CustomRenderablePrimitive is a class that represent the raw renderable object that can be added to rendering queue 
            and is created with providing custom Action that is called when this object needs to be rendered.
            CustomRenderablePrimitive is use by the <see cref="T:Ab3d.DirectX.CustomRenderableNode" /> object.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderablePrimitive.#ctor(System.Action{Ab3d.DirectX.RenderingContext,System.Object},System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="renderAction">Action takes RenderingContext and object and is called when this object needs to be rendered</param>
            <param name="originalObject">Optional object that is send as parameter to the renderAction (null by default)</param>
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderablePrimitive.RenderGeometry(Ab3d.DirectX.RenderingContext)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.GeometryMesh">
            <summary>
            GeometryMesh class is used to create Index and Vertex buffers from list of positions, normals, textureCoordinates and triangleIndices.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.GeometryMesh.Positions">
            <summary>
            Gets or sets IList of Vector3 that represents the Positions.
            When this property is changed, the <see cref="M:Ab3d.DirectX.GeometryMesh.RecreateMesh" /> method must be called.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.GeometryMesh.Normals">
            <summary>
            Gets or sets IList of Vector3 that represents the Normals.
            When this property is changed, the <see cref="M:Ab3d.DirectX.GeometryMesh.RecreateMesh" /> method must be called.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.GeometryMesh.TextureCoordinates">
            <summary>
            Gets or sets IList of Vector2 that represents the TextureCoordinates.
            When this property is changed, the <see cref="M:Ab3d.DirectX.GeometryMesh.RecreateMesh" /> method must be called.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.GeometryMesh.TriangleIndices">
            <summary>
            Gets or sets IList of ints that represents the triangle indices.
            When this property is changed, the <see cref="M:Ab3d.DirectX.GeometryMesh.RecreateMesh" /> method must be called.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.GeometryMesh.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">optional name</param>
        </member>
        <member name="M:Ab3d.DirectX.GeometryMesh.#ctor(System.Collections.Generic.IList{SharpDX.Vector3},System.Collections.Generic.IList{SharpDX.Vector3},System.Collections.Generic.IList{SharpDX.Vector2},System.Collections.Generic.IList{System.Int32},System.String)">
            <summary>
            Constructor
            </summary>
            <param name="positions">positions</param>
            <param name="normals">normals</param>
            <param name="textureCoordinates">textureCoordinates</param>
            <param name="triangleIndices">triangleIndices</param>
            <param name="name">optional name</param>
        </member>
        <member name="M:Ab3d.DirectX.GeometryMesh.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.GeometryMesh.RecreateMesh">
            <summary>
            RecreateMesh disposes the existing VertexBuffers and IndexBuffer and recreates the buffers.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.GeometryMesh.UpdateBounds">
            <summary>
            Updates the Bounds of this mesh
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.GeometryMesh.GetClosestHitResult(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext)">
            <summary>
            GetClosestHitResult method returns a <see cref="T:Ab3d.DirectX.DXRayHitTestResult" /> with the closest triangle hit by the specified ray.
            When no triangle is hit, null is returned.
            </summary>
            <param name="localRay">SharpDX.Ray in local SceneNode coordinate system</param>
            <param name="hitTestContext">DXHitTestContext</param>
            <returns>DXRayHitTestResult with the closest triangle hit or null when no triangle is hit</returns>
        </member>
        <member name="M:Ab3d.DirectX.GeometryMesh.GetNextHitResult(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext,Ab3d.DirectX.DXRayHitTestResult)">
            <summary>
            GetNextHitResult method continues hit testing from the previously returned hit test and returns a <see cref="T:Ab3d.DirectX.DXRayHitTestResult" />
            with the next hit triangle (not necessary the next closest triangle) or null if no other triangle is hit.
            This method can be used to get all hit results.
            </summary>
            <param name="localRay">SharpDX.Ray in local SceneNode coordinate system</param>
            <param name="hitTestContext">DXHitTestContext</param>
            <param name="previousHitResult">DXRayHitTestResult as result of the previous call to GetNextHitResult method or null if this is the first time this method is called</param>
            <returns>DXRayHitTestResult with the next triangle hit or null when no triangle is hit</returns>
        </member>
        <member name="M:Ab3d.DirectX.GeometryMesh.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.IDynamicVertexBufferCreator">
            <summary>
            IDynamicVertexBufferCreator interface defines <see cref="P:Ab3d.DirectX.IDynamicVertexBufferCreator.CreateDynamicVertexBuffer" /> property and is used on meshes that can create a dynamic vertex buffer.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.IDynamicVertexBufferCreator.CreateDynamicVertexBuffer">
            <summary>
            Gets or sets a Boolean that specifies if the vertex buffer is created as a dynamic buffer.
            This can provide slightly better performance for cases when vertex buffer is updated very often.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.MeshBase">
            <summary>
            MeshBase is a base class that defines the data about one 3D model that are stored in the DirectX structures that are used to draw the model.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshBase.Materials">
            <summary>
            Array of Materials
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshBase.VertexBufferBindings">
            <summary>
            Array of VertexBufferBinding
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshBase.BaseVertexLocation">
            <summary>
            start index in VertexBuffer used in DrawIndexed method
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshBase.IndexBuffer">
            <summary>
            IndexBuffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshBase.PrimitiveTopology">
            <summary>
            PrimitiveTopology
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshBase.InputLayoutType">
            <summary>
            InputLayoutType
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshBase.StartIndexLocation">
            <summary>
            start index in IndexBuffer used in DrawIndexed method
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshBase.IndexCount">
            <summary>
            number of indices to render 
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshBase.IndexBufferFormat">
            <summary>
            Format of the index buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshBase.IsFrontCounterClockwise">
            <summary>
            True if triangles are oriented in counter clockwise orientation
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshBase.Bounds">
            <summary>
            Bounds of the mesh
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshBase.SubMeshes">
            <summary>
            Array of Submesh objects
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.MeshBase.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshBase.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.GeometryMeshGenerator">
            <summary>
            GeometryMeshGenerator contains static methods that can create Mesh objects.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.GeometryMeshGenerator.CreateFullScreenQuad(System.String)">
            <summary>
            Creates a SimpleMash that defines a full screen quad (rectangle created with two triangles).
            </summary>
            <param name="name">name - FullScreenQuad by default</param>
            <returns>SimpleMesh</returns>
        </member>
        <member name="M:Ab3d.DirectX.GeometryMeshGenerator.CreateViewportQuad(SharpDX.ViewportF,System.String)">
            <summary>
            Creates a SimpleMash that defines a quad (rectangle created with two triangles) from the specified coordinates - (0,0) is upper left corner, (1,1) is lower right corner.
            </summary>
            <param name="viewport">viewport</param>
            <param name="name">name - ViewportQuad by default</param>
            <returns>SimpleMesh</returns>
        </member>
        <member name="M:Ab3d.DirectX.GeometryMeshGenerator.CreateViewportQuad(System.Single,System.Single,System.Single,System.Single,System.String)">
            <summary>
            Creates a SimpleMash that defines a quad (rectangle created with two triangles) from the specified coordinates - x1 and y1 defines the bottom left position (-1, -1 for full screen); x2 and y2 define the upper right position (1, 1 for full screen).
            </summary>
            <param name="x1">x1</param>
            <param name="y1">y1 (-1 is bottom, 1 is top)</param>
            <param name="x2">x2</param>
            <param name="y2">y2</param>
            <param name="name">name - ViewportQuad by default</param>
            <returns>SimpleMesh</returns>
        </member>
        <member name="T:Ab3d.DirectX.OptimizedPointMesh`1">
            <summary>
            OptimizedPointMesh class is used to show point cloud and can dynamically reduce the number of rendered positions to improver rendering performance.
            It creates one Vertex buffer and multiple Index buffers that are used to provide different level of optimized sub-sets of all the vertices.
            </summary>
            <remarks>
                <para>
                    <b>OptimizedPointMesh</b> class is used to show point cloud with optimized number of shown points.
            </para>
                <para>
            It creates one Vertex buffer and multiple Index buffers that are used to provide different level of optimized sub-sets of all the vertices.
            </para>
                <para>
            OptimizedPointMesh also support hit testing. To get the position index of the closest position, call the <see cref="M:Ab3d.DirectX.OptimizedPointMesh`1.GetClosestPositionIndex(SharpDX.Ray,System.Single@)" /> or <see cref="M:Ab3d.DirectX.OptimizedPointMesh`1.GetClosestPositionIndex(SharpDX.Ray)" /> method.
            To get all position indexes that are close to the specified ray use the <see cref="M:Ab3d.DirectX.OptimizedPointMesh`1.GetPositionIndexesAroundRay(SharpDX.Ray,System.Single,System.Collections.Generic.List{System.Int32}@,System.Boolean,System.Int32)" /> or <see cref="M:Ab3d.DirectX.OptimizedPointMesh`1.GetPositionIndexesAroundRay(SharpDX.Ray,System.Single,System.Boolean,System.Int32)" /> method.
            All those methods are highly optimized and check only the segments that ray goes through (ray intersects segment's bounding box) and this significantly reduces the number of checked positions.
            </para>
                <para>
            OptimizedPointMesh uses two techniques to do the optimization:<br />
            1)<br />
            Divide all the positions into multiple segments and when rendering it checks bounding box of each segment to determine if it is visible on the screen on not. Number of segments is defined in the OptimizedPointMesh constructor.<br /><br />
            2)<br />
            For each segment multiple optimization views (Index Buffers) are created where the number of positions is defined by the pixel size on the screen and how close together the positions are (positions that are closer then size of one pixel are rendered as one pixel).
            Number of views is defined by <see cref="F:Ab3d.DirectX.OptimizedPointMesh`1.MaxOptimizationViewsCount" /> and <see cref="F:Ab3d.DirectX.OptimizedPointMesh`1.OptimizationIndicesNumberThreshold" /> properties.
            </para>
                <para>
            Before OptimizedPointMesh can be rendered for the first time, the <see cref="M:Ab3d.DirectX.OptimizedPointMesh`1.Optimize(SharpDX.Size2,System.Double)" /> method must be called. It generates the Index Buffers for the segments based on the size of Viewport and size of pixel.
            This method can take a while to execute so call it only when the size of Viewport or pixel is changed.
            </para>
                <para>
            To determine which segments are visible and which are hidden, the <see cref="M:Ab3d.DirectX.OptimizedPointMesh`1.UpdateVisibleSegments(SharpDX.Matrix)" /> method needs to be called before rendering.
            </para>
                <para>
            Then you can call <see cref="M:Ab3d.DirectX.OptimizedPointMesh`1.RenderGeometry(Ab3d.DirectX.RenderingContext)" /> method.
            </para>
                <para>
                    <b>IMPORTANT:</b>
                    <br />
            It is very important that the positions are organized in such a way that the positions that are close together in 3D space are also close together in positions array.
            This way the OptimizedPointMesh will be able to efficiently group positions into segments and render only one position instead of multiple positions that are close together.
            </para>
                <para>
            Please contact support@ab4d.com to get more information about the OptimizedPointMesh.
            </para>
            </remarks>
            <typeparam name="T">struct that holds data for one vertex - for example Ab3d.DirectX.PositionNormal</typeparam>
        </member>
        <member name="F:Ab3d.DirectX.OptimizedPointMesh`1.OptimizationIndicesNumberThreshold">
            <summary>
            OptimizationIndicesNumberThreshold specifies at which number of indices user is satisfied with performance and no more views (Index buffers) will be created.
            When number of indices defined in all segments is less then the number specified in this field, then no more views are created.
            Smaller value can create more optimization views and can take longer to initialize.
            Default value is 100000.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.OptimizedPointMesh`1.MaxOptimizationViewsCount">
            <summary>
            MaxOptimizationViewsCount specifies maximum number of views (Index buffers) for each segment.
            Default value is 10.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.OptimizedPointMesh`1.UseMultiThreadedAnalysis">
            <summary>
            UseMultiThreadedAnalysis specifies if generation of optimization views is run on multiple threads.
            Default value is true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.OptimizedPointMesh`1.PositionsArray">
            <summary>
            Gets the array of Vector3 elements that define the positions for this OptimizedPointMesh.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.OptimizedPointMesh`1.VertexBufferArray">
            <summary>
            Gets or sets an array of T structs that define the vertex buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.OptimizedPointMesh`1.OptimizePositions">
            <summary>
            Gets or sets a Boolean that specifies if smart point reduction algorithm is used to skip rendering positions that are close together.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.OptimizedPointMesh`1.RenderOnlyVisibleSegments">
            <summary>
            Gets or sets a Boolean that specifies if only visible segments are rendered. 
            When RenderOnlyVisibleSegments is true, the <see cref="M:Ab3d.DirectX.OptimizedPointMesh`1.UpdateVisibleSegments(SharpDX.Matrix)" /> method must be called before rendering.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.OptimizedPointMesh`1.#ctor(SharpDX.Vector3[],SharpDX.BoundingBox,System.Int32,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="positionsArray">array of positions as Vector3 - if T is Position then this array can be the same as vertexBufferArray</param>
            <param name="name">name (optional)</param>
            <param name="bounds">BoundingBox of the positions - if Empty then it will be calculated in the constructor of this OptimizedPointMesh</param>
            <param name="segmentsCount">number of segments that will be used to divide all the vertices</param>
        </member>
        <member name="M:Ab3d.DirectX.OptimizedPointMesh`1.#ctor(`0[],SharpDX.Vector3[],Ab3d.DirectX.InputLayoutType,SharpDX.BoundingBox,System.Int32,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="vertexBufferArray">array of T structs that define the vertex buffer</param>
            <param name="positionsArray">array of positions as Vector3 - if T is Position then this array can be the same as vertexBufferArray</param>
            <param name="inputLayoutType">InputLayoutType</param>
            <param name="name">name (optional)</param>
            <param name="bounds">BoundingBox of the positions - if Empty then it will be calculated in the constructor of this OptimizedPointMesh</param>
            <param name="segmentsCount">number of segments that will be used to divide all the vertices</param>
        </member>
        <member name="M:Ab3d.DirectX.OptimizedPointMesh`1.Optimize(SharpDX.Size2,System.Double)">
            <summary>
            Optimize method optimizes the positions with preparing the segments and data views that will be used for different camera positions.
            This method should be call after a bigger change of the Viewport3D's size.
            </summary>
            <param name="standardViewport3DSize">size of Viewport3D that will get the best optimization by this OptimizedPointMesh</param>
            <param name="standardPointSize">size of one point that is rendered on the screen</param>
        </member>
        <member name="M:Ab3d.DirectX.OptimizedPointMesh`1.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.OptimizedPointMesh`1.UpdateVisibleSegments(SharpDX.Matrix)">
            <summary>
            UpdateVisibleSegments method gets camera's worldViewProjectionMatrix as parameter and updates which segments are visible and will be rendered
            in the next rendering pass.
            When worldViewProjectionMatrix parameter is Identity then all segments are shown.
            </summary>
            <param name="worldViewProjectionMatrix"></param>
        </member>
        <member name="M:Ab3d.DirectX.OptimizedPointMesh`1.RenderGeometry(Ab3d.DirectX.RenderingContext)">
            <summary>
            RenderGeometry renders the geometry (executes draw calls but does not apply material settings)
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.OptimizedPointMesh`1.GetClosestPositionIndex(SharpDX.Ray)">
            <summary>
            Returns an index of the position that is the closest to the specified ray.
            The method is highly optimized and checks only the segments that ray goes through (ray intersects segment's bounding box) and this significantly reduces the number of checked positions.
            When no segment is hit by the ray, then -1 is returned.
            To also get the distance to the ray use the <see cref="M:Ab3d.DirectX.OptimizedPointMesh`1.GetClosestPositionIndex(SharpDX.Ray,System.Single@)" />.
            </summary>
            <param name="ray">SharpDX.Ray</param>
            <returns>an index of the position that is the closest to the specified ray; or -1 when no segment is hit by the ray</returns>
        </member>
        <member name="M:Ab3d.DirectX.OptimizedPointMesh`1.GetClosestPositionIndex(SharpDX.Ray,System.Single@)">
            <summary>
            Returns an index of the position that is the closest to the specified ray. The method also sets the distance to the out parameter.
            The method is highly optimized and checks only the segments that ray goes through (ray intersects segment's bounding box) and this significantly reduces the number of checked positions.
            When no segment is hit by the ray, then -1 is returned and distance is set to NaN.
            </summary>
            <param name="ray">SharpDX.Ray</param>
            <param name="distance">out parameter that is set to the distance of the position to the ray</param>
            <returns>an index of the position that is the closest to the specified ray; or -1 when no segment is hit by the ray</returns>
        </member>
        <member name="M:Ab3d.DirectX.OptimizedPointMesh`1.GetPositionIndexesAroundRay(SharpDX.Ray,System.Single,System.Boolean,System.Int32)">
            <summary>
            GetPositionIndexesAroundRay method returns a list of position indexes that are closer to the ray then the specified maxDistance.
            By default (when orderByDistanceToRayPosition is true) the position are ordered by the distance to the ray's Position.
            When maxResultsCount is set to a bigger number then 0, then it is possible to limit the number of returned indexes.
            To prevent creating List object on each call to this method, call the overload that takes the List object as ref.
            </summary>
            <param name="ray">SharpDX.Ray</param>
            <param name="maxDistance">distance as float</param>
            <param name="orderByDistanceToRayPosition">when true (by default) the position are ordered by the distance to the ray's Position; when false then the positions are unordered</param>
            <param name="maxResultsCount">when bigger then 0, then the number of items in the List is limited (no additional positions are checked).</param>
            <returns>a list of position indexes that are closer to the ray then the specified maxDistance</returns>
        </member>
        <member name="M:Ab3d.DirectX.OptimizedPointMesh`1.GetPositionIndexesAroundRay(SharpDX.Ray,System.Single,System.Collections.Generic.List{System.Int32}@,System.Boolean,System.Int32)">
            <summary>
            GetPositionIndexesAroundRay method returns a list of position indexes that are closer to the ray then the specified maxDistance.
            By default (when orderByDistanceToRayPosition is true) the position are ordered by the distance to the ray's Position.
            When maxResultsCount is set to a bigger number then 0, then it is possible to limit the number of returned indexes.
            </summary>
            <param name="ray">SharpDX.Ray</param>
            <param name="maxDistance">distance as float</param>
            <param name="positionIndexes">a reference to a List of integer that will be filled by position indexes</param>
            <param name="orderByDistanceToRayPosition">when true (by default) the position are ordered by the distance to the ray's Position; when false then the positions are unordered</param>
            <param name="maxResultsCount">when bigger then 0, then the number of items in the List is limited (no additional positions are checked).</param>
        </member>
        <member name="M:Ab3d.DirectX.OptimizedPointMesh`1.GetPixel3DSize(Ab3d.DirectX.ICamera,System.Single,SharpDX.Vector3)">
            <summary>
            GetPixel3DSize returns size of one pixel at specified position on screen based on the specified camera and view width.
            For example, value 5 means a box at the specified position and with size set to 5 will be rendered to 1 pixel on screen.
            </summary>
            <param name="dxCamera">Camera that is used to view the 3D scene</param>
            <param name="viewportWidth">width of the viewport (in screen coordinates)</param>
            <param name="position">Vector3 of the position for where the calculation should be done</param>
            <returns>size of one pixel at specified position on the screen</returns>
        </member>
        <member name="M:Ab3d.DirectX.OptimizedPointMesh`1.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.RenderableInstancedObjectsPrimitive">
            <summary>
            RenderableInstancedObjectsPrimitive class is a <see cref="T:Ab3d.DirectX.RenderablePrimitive" /> that can be used to render multiple instances of
            geometry based DXScene's <see cref="T:Ab3d.DirectX.ObjectNode" /> and where the instances are defined by VertexBufferBinding.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderableInstancedObjectsPrimitive.InstanceBufferBinding">
            <summary>
            VertexBufferBinding that represents instances buffer
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderableInstancedObjectsPrimitive.InstancesCount">
            <summary>
            The number of instances
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderableInstancedObjectsPrimitive.StartInstanceIndex">
            <summary>
            The start index of the instances in InstanceBufferBinding
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderableInstancedObjectsPrimitive.UseInstanceObjectColor">
            <summary>
            Defines the source of the object diffuse color: if true (by default) then color defined in instance buffer is used; if false color defined in IDiffuseMaterial is used for all instaces.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderableInstancedObjectsPrimitive.UseScreenSpaceScaling">
            <summary>
            When true (false by default) then each instance is scaled in the shader so that the value specified in matrix's M11
            defines the size of the rendered object on screen (when the size of the mesh is 1).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderableInstancedObjectsPrimitive.#ctor(Ab3d.DirectX.ObjectNode,Ab3d.DirectX.MeshBase,Ab3d.DirectX.Material,SharpDX.Direct3D11.VertexBufferBinding,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderableInstancedObjectsPrimitive" /> class.
            </summary>
            <param name="parentObjectNode">The parent ObjectNode</param>
            <param name="meshBase">MeshBase</param>
            <param name="material">Material</param>
            <param name="instanceBufferBinding">VertexBufferBinding that represents instances buffer</param>
            <param name="instancesCount">The number of instances</param>
            <param name="startInstanceIndex">The start index of the instances in InstanceBufferBinding</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderableInstancedObjectsPrimitive.RenderGeometry(Ab3d.DirectX.RenderingContext)">
            <summary>
            RenderGeometry renders the geometry (executes draw calls but does not apply material settings)
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="T:Ab3d.DirectX.RenderableMeshPrimitive">
            <summary>
            RenderableMeshPrimitive class is a <see cref="T:Ab3d.DirectX.RenderablePrimitive" /> that can be used to render geometry based on the <see cref="F:Ab3d.DirectX.RenderableMeshPrimitive.MeshBase" /> and <see cref="F:Ab3d.DirectX.RenderableMeshPrimitive.SubMesh" />.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderableMeshPrimitive.MeshBase">
            <summary>
            MeshBase used to initialize this RenderableMeshPrimitive
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderableMeshPrimitive.SubMesh">
            <summary>
            SubMesh used to initialize this RenderableMesh. Can be null when only MeshBase is used.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderableMeshPrimitive.#ctor(Ab3d.DirectX.MeshBase,Ab3d.DirectX.Material)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderableMeshPrimitive" /> class.
            </summary>
            <param name="meshBase">MeshBase</param>
            <param name="material">Material</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderableMeshPrimitive.#ctor(Ab3d.DirectX.MeshBase,Ab3d.DirectX.Material,SharpDX.Matrix@)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderableMeshPrimitive" /> class.
            </summary>
            <param name="meshBase">MeshBase</param>
            <param name="material">Material</param>
            <param name="worldMatrix">world matrix</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderableMeshPrimitive.#ctor(Ab3d.DirectX.MeshBase,Ab3d.DirectX.SubMesh,Ab3d.DirectX.Material)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderableMeshPrimitive" /> class.
            </summary>
            <param name="meshBase">MeshBase</param>
            <param name="submesh">SubMesh</param>
            <param name="material">Material</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderableMeshPrimitive.#ctor(Ab3d.DirectX.MeshBase,Ab3d.DirectX.SubMesh,Ab3d.DirectX.Material,SharpDX.Matrix@)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderableMeshPrimitive" /> class.
            </summary>
            <param name="meshBase">MeshBase</param>
            <param name="submesh">SubMesh</param>
            <param name="material">Material</param>
            <param name="worldMatrix">world matrix</param>
        </member>
        <member name="T:Ab3d.DirectX.RenderableObjectNodePrimitive">
            <summary>
            RenderableObjectNodePrimitive class is a <see cref="T:Ab3d.DirectX.RenderablePrimitive" /> that can be used to render 3D objects created from DXScene's <see cref="T:Ab3d.DirectX.ObjectNode" /> objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderableObjectNodePrimitive.ParentObjectNode">
            <summary>
            ObjectNode used to initialize this RenderableObjectNodePrimitive
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderableObjectNodePrimitive.#ctor(Ab3d.DirectX.ObjectNode,Ab3d.DirectX.MeshBase,Ab3d.DirectX.Material)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderableObjectNodePrimitive" /> class.
            </summary>
            <param name="parentObjectNode">ObjectNode</param>
            <param name="meshBase">MeshBase</param>
            <param name="material">Material</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderableObjectNodePrimitive.#ctor(Ab3d.DirectX.ObjectNode,Ab3d.DirectX.MeshBase,Ab3d.DirectX.SubMesh)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderableObjectNodePrimitive" /> class.
            </summary>
            <param name="parentObjectNode">ObjectNode</param>
            <param name="meshBase">MeshBase</param>
            <param name="subMesh">SubMesh</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderableObjectNodePrimitive.#ctor(Ab3d.DirectX.ObjectNode,Ab3d.DirectX.MeshBase,Ab3d.DirectX.Material,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderableObjectNodePrimitive" /> class.
            </summary>
            <param name="parentObjectNode">ObjectNode</param>
            <param name="meshBase">MeshBase</param>
            <param name="material">material</param>
            <param name="indexCount">Number of indices to render</param>
            <param name="startIndexLocation">start index in IndexBuffer used in DrawIndexed method</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderableObjectNodePrimitive.#ctor(Ab3d.DirectX.ObjectNode,Ab3d.DirectX.MeshBase,Ab3d.DirectX.Material,System.Int32,System.Int32,SharpDX.Matrix@)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderableObjectNodePrimitive" /> class.
            </summary>
            <param name="parentObjectNode">ObjectNode</param>
            <param name="meshBase">MeshBase</param>
            <param name="material">material</param>
            <param name="indexCount">Number of indices to render</param>
            <param name="startIndexLocation">start index in IndexBuffer used in DrawIndexed method</param>
            <param name="worldMatrix"></param>
        </member>
        <member name="M:Ab3d.DirectX.RenderableObjectNodePrimitive.#ctor(Ab3d.DirectX.ObjectNode,Ab3d.DirectX.MeshBase,Ab3d.DirectX.SubMesh,SharpDX.Matrix@)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderableObjectNodePrimitive" /> class.
            </summary>
            <param name="parentObjectNode">ObjectNode</param>
            <param name="meshBase">MeshBase</param>
            <param name="subMesh">SubMesh</param>
            <param name="worldMatrix">world matrix</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderableObjectNodePrimitive.#ctor(Ab3d.DirectX.ObjectNode,Ab3d.DirectX.MeshBase,Ab3d.DirectX.Material,SharpDX.Matrix@)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderableObjectNodePrimitive" /> class.
            </summary>
            <param name="parentObjectNode">ObjectNode</param>
            <param name="meshBase">MeshBase</param>
            <param name="material">Material</param>
            <param name="worldMatrix">world matrix</param>
        </member>
        <member name="T:Ab3d.DirectX.RenderablePrimitive">
            <summary>
            RenderablePrimitive is a base class that is derived from <see cref="T:Ab3d.DirectX.RenderablePrimitiveBase" /> and implements rendering geometry based on the
            resources defined by the RenderablePrimitive constructor.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitive.StateSortValue">
            <summary>
            The state sort value represent an unsigned Int32 number that is a short hash value calculated from the properties of this RenderablePrimitive 
            (mostly from material) and can be used to sort and group similar RenderablePrimitive. This can improve performance.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitive.Distance">
            <summary>
            The distance from the camera
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitive.PrimitiveTopology">
            <summary>
            PrimitiveTopology
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitive.InputLayoutType">
            <summary>
            InputLayoutType
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitive.VertexBufferBindings">
            <summary>
            Array of VertexBufferBinding
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitive.BaseVertexLocation">
            <summary>
            start index in VertexBuffer used in DrawIndexed method
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderablePrimitive.IndexBuffer">
            <summary>
            IndexBuffer
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitive.IndexBufferFormat">
            <summary>
            Format of IndexBuffer
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitive.StartIndexLocation">
            <summary>
            start index in IndexBuffer used in DrawIndexed method
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitive.IndexCount">
            <summary>
            Number of indices to render
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitive.Bounds">
            <summary>
            Bounds
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitive.Tag">
            <summary>
            Arbitrary tag
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitive.#ctor(System.Object,Ab3d.DirectX.Material,SharpDX.Direct3D.PrimitiveTopology,Ab3d.DirectX.InputLayoutType,SharpDX.Direct3D11.VertexBufferBinding[],SharpDX.Direct3D11.Buffer,SharpDX.DXGI.Format,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderablePrimitive" /> class.
            </summary>
            <param name="originalObject">The original object that was used to create this RenderablePrimitive</param>
            <param name="material">Material</param>
            <param name="primitiveTopology">PrimitiveTopology</param>
            <param name="inputLayoutType">InputLayoutType</param>
            <param name="vertexBufferBindings">array of VertexBufferBinding</param>
            <param name="indexBuffer">IndexBuffer</param>
            <param name="indexBufferFormat">format of IndexBuffer</param>
            <param name="indexCount">Number of indices to render</param>
            <param name="startIndexLocation">start index in IndexBuffer used in DrawIndexed method</param>
            <param name="baseVertexLocation">start index in VertexBuffer used in DrawIndexed method</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitive.#ctor(System.Object,Ab3d.DirectX.Material,SharpDX.Direct3D.PrimitiveTopology,Ab3d.DirectX.InputLayoutType,SharpDX.Direct3D11.VertexBufferBinding[],SharpDX.Direct3D11.Buffer,SharpDX.DXGI.Format,System.Int32,System.Int32,System.Int32,Ab3d.DirectX.Bounds)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderablePrimitive" /> class.
            </summary>
            <param name="originalObject">The original object.</param>
            <param name="material">Material</param>
            <param name="primitiveTopology">PrimitiveTopology</param>
            <param name="inputLayoutType">InputLayoutType</param>
            <param name="vertexBufferBindings">array of VertexBufferBinding</param>
            <param name="indexBuffer">IndexBuffer</param>
            <param name="indexBufferFormat">format of IndexBuffer</param>
            <param name="indexCount">Number of indices to render</param>
            <param name="startIndexLocation">start index in IndexBuffer used in DrawIndexed method</param>
            <param name="baseVertexLocation">start index in VertexBuffer used in DrawIndexed method</param>
            <param name="bounds">bounds</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitive.#ctor(System.Object,Ab3d.DirectX.Material,SharpDX.Direct3D.PrimitiveTopology,Ab3d.DirectX.InputLayoutType,SharpDX.Direct3D11.VertexBufferBinding[],SharpDX.Direct3D11.Buffer,SharpDX.DXGI.Format,System.Int32,System.Int32,System.Int32,SharpDX.Matrix@,Ab3d.DirectX.Bounds)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderablePrimitive" /> class.
            </summary>
            <param name="originalObject">The original object.</param>
            <param name="material">Material</param>
            <param name="primitiveTopology">PrimitiveTopology</param>
            <param name="inputLayoutType">InputLayoutType</param>
            <param name="vertexBufferBindings">array of VertexBufferBinding</param>
            <param name="indexBuffer">IndexBuffer</param>
            <param name="indexBufferFormat">format of IndexBuffer</param>
            <param name="indexCount">Number of indices to render</param>
            <param name="startIndexLocation">start index in IndexBuffer used in DrawIndexed method</param>
            <param name="baseVertexLocation">start index in VertexBuffer used in DrawIndexed method</param>
            <param name="worldMatrix">world matrix</param>
            <param name="bounds">bounds</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitive.RenderGeometry(Ab3d.DirectX.RenderingContext)">
            <summary>
            RenderGeometry renders the geometry (executes draw calls but does not apply material settings)
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitive.ChangeVertexBuffer(SharpDX.Direct3D11.VertexBufferBinding,System.Int32)">
            <summary>
            ChangeVertexBuffer changes the vertex buffer used by this RenderablePrimitive.
            </summary>
            <param name="newVertexBufferBinding">new VertexBufferBinding</param>
            <param name="vertexBufferBindingIndex">index of VertexBufferBinding in the <see cref="F:Ab3d.DirectX.RenderablePrimitive.VertexBufferBindings" /> array (default value is 0)</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitive.ChangeVertexBuffers(SharpDX.Direct3D11.VertexBufferBinding[])">
            <summary>
            ChangeVertexBuffers changes the vertex buffers used by this RenderablePrimitive.
            </summary>
            <param name="newVertexBufferBindings">array of new VertexBufferBinding</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitive.ChangeIndexBuffers(SharpDX.Direct3D11.Buffer,System.Int32,System.Int32)">
            <summary>
            ChangeIndexBuffers changes the index buffer used by this RenderablePrimitive.
            </summary>
            <param name="newIndexBuffer">new IndexBuffer</param>
            <param name="startIndexLocation">start index in IndexBuffer used in DrawIndexed method</param>
            <param name="indexCount">number of triangle indices in the buffer</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitive.SetMaterialSortHash">
            <summary>
            SetMaterialSortHash calculates the StateSortValue based on the current material and other properties of this RenderablePrimitive
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.RenderablePrimitiveBase">
            <summary>
            RenderablePrimitiveBase is a base abstract class that represents a low level geometry object that is prepared to be rendered with DirectX.
            It contains all required DirectX buffers and required data to prepare the rendering states.
            RenderablePrimitiveBase objects are rendered in the <see cref="T:Ab3d.DirectX.RenderObjectsRenderingStep" /> rendering step and can be added to any <see cref="T:Ab3d.DirectX.RenderingQueue" />.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.RenderablePrimitiveBase.RenderablePrimitiveRenderingFlags">
            <summary>
            RenderablePrimitiveRenderingFlags define flags that can be used by the <see cref="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderingFlags" /> field.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderablePrimitiveRenderingFlags.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderablePrimitiveRenderingFlags.IsVisible">
            <summary>
            IsVisible
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderablePrimitiveRenderingFlags.IsWorldMatrixIdentity">
            <summary>
            IsWorldMatrixIdentity
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderablePrimitiveRenderingFlags.IsFrontCounterClockwise">
            <summary>
            IsFrontCounterClockwise
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderablePrimitiveRenderingFlags.IsBackFaceMaterial">
            <summary>
            IsBackFaceMaterial
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderablePrimitiveRenderingFlags.IsCastingShadow">
            <summary>
            IsCastingShadow - when set this object casts a shadow
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderablePrimitiveRenderingFlags.IsReceivingShadow">
            <summary>
            IsReceivingShadow - when set, this object receives shadow
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderingFlags">
            <summary>
            Flags that provide information on how this RenderablePrimitive is rendered.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderablePrimitiveBase.IsVisible">
            <summary>
            When IsVisible property is false this prevents rendering the RenderablePrimitiveBase.
            This property gets or set the flag from <see cref="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderingFlags" /> field.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderablePrimitiveBase.IsFrontCounterClockwise">
            <summary>
            IsFrontCounterClockwise specifies the orientation of the positions in the 3D geometry - if true than the positions are oriented in a counter clockwise manner.
            This property gets or set the flag from <see cref="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderingFlags" /> field.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderablePrimitiveBase.IsBackFaceMaterial">
            <summary>
            IsBackFaceMaterial specifies if the material is used to render front (IsBackFaceMaterial == false) or back (IsBackFaceMaterial == true) faces.
            This property gets or set the flag from <see cref="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderingFlags" /> field.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderablePrimitiveBase.IsWorldMatrixIdentity">
            <summary>
            Boolean that specifies if WorldMatrix is identity.
            This property gets or set the flag from <see cref="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderingFlags" /> field.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderablePrimitiveBase.IsCastingShadow">
            <summary>
            IsCastingShadow specifies if this object casts shadow.
            This property gets or set the flag from <see cref="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderingFlags" /> field.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderablePrimitiveBase.IsReceivingShadow">
            <summary>
            IsReceivingShadow specifies if this object receives shadow.
            This property gets or set the flag from <see cref="F:Ab3d.DirectX.RenderablePrimitiveBase.RenderingFlags" /> field.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.Material">
            <summary>
            Material
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.OverrideMaterial">
            <summary>
            OverrideMaterial can be set to override the Material when rendering but still preserve the original Material.
            It can be set by some other object that wanted to change the rendering behavior of this RenderablePrimitiveBase.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.WorldMatrix">
            <summary>
            The world matrix
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.WorldInverseTransposeMatrix">
            <summary>
            The world matrix that is inversed and transposed (normals are multiplied with this matrix)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.MaterialFlags">
            <summary>
            MaterialFlags can be used by Materials to add some values that could be used to improve performance.
            Currently they are used by StandardEffect (DirectionalLightShader and SuperShader) to mark which constant buffer values are the same as in the previous RenderablePrimitiveBase.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderablePrimitiveBase.OriginalObject">
            <summary>
            The original object that was used to create this RenderablePrimitiveBase.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitiveBase.#ctor(Ab3d.DirectX.Material)">
            <summary>
            Initializes a new instance of the RenderablePrimitiveBase class.
            </summary>
            <param name="material">material</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitiveBase.#ctor(Ab3d.DirectX.Material,System.Object)">
            <summary>
            Initializes a new instance of the RenderablePrimitiveBase class.
            </summary>
            <param name="material">material</param>
            <param name="originalObject">The original object that was used to create this RenderablePrimitiveBase</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitiveBase.RenderGeometry(Ab3d.DirectX.RenderingContext)">
            <summary>
            RenderGeometry renders the geometry (executes draw calls but does not apply material settings)
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderablePrimitiveBase.CalculateWorldInverseTransposeMatrix">
            <summary>
            Calculates the WorldInverseTransposeMatrix from the World matrix
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.ScreenSpaceLineMesh">
            <summary>
            ScreenSpaceLineMesh class prepares the low level DirectX objects (Index and Vertex buffers) for rendering screen-space 3D lines.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ScreenSpaceLineMesh.Positions">
            <summary>
            Positions array that form 3D lines.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ScreenSpaceLineMesh.IsLineStrip">
            <summary>
            If true than the <see cref="P:Ab3d.DirectX.ScreenSpaceLineMesh.Positions" /> define connected lines, if false than lines are not connected and each line is defined by two positions.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ScreenSpaceLineMesh.CreateDynamicVertexBuffer">
            <summary>
            Gets or sets a Boolean that specifies if the vertex buffer is created as a dynamic buffer.
            This can provide slightly better performance for cases when vertex buffer is updated very often.
            Default value is false.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineMesh.#ctor(SharpDX.Vector3[],System.Boolean,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="positions">positions array that form 3D lines</param>
            <param name="isLineStrip">if true than the lines are connected, if false than lines are not connected and each line is defined by two positions</param>
            <param name="name">optional name</param>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineMesh.#ctor(SharpDX.Vector3[],System.Boolean,SharpDX.BoundingBox,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="positions">positions array that form 3D lines</param>
            <param name="isLineStrip">if true than the lines are connected, if false than lines are not connected and each line is defined by two positions</param>
            <param name="boundingBox">boundingBox</param>
            <param name="name">optional name</param>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineMesh.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineMesh.RecreateMesh">
            <summary>
            Creates the VertexBuffers from the specified positions.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineMesh.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.SimpleMesh`1">
            <summary>
            SimpleMesh class is used to create Index and Vertex buffers from a list of structs which type is defined by the type T.
            For example the following struct SimpleMesh&lt;PositionTexture&gt; is used to define a mesh from a List of PositionTexture structs.
            </summary>
            <typeparam name="T">struct that holds data for one vertex - for example Ab3d.DirectX.PositionNormalTexture</typeparam>
        </member>
        <member name="P:Ab3d.DirectX.SimpleMesh`1.VertexBufferArray">
            <summary>
            Gets or sets an array of T structs that define the vertex buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SimpleMesh`1.IndexBufferArray">
            <summary>
            Gets or sets an array that is used to define the index buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SimpleMesh`1.ArrayStride">
            <summary>
            Gets or sets an integer that specifies how many VertexBufferArray elements define one Vertex. Default value is 1. See remarks for more info.
            </summary>
            <remarks>
                <para>
                    <b>ArrayStride</b> gets or sets an integer that specifies how many VertexBufferArray elements define one Vertex.
            </para>
                <para>
            When SimpleMesh is created with standard vertex buffer structs like <see cref="T:Ab3d.DirectX.PositionNormalTexture" />, then the ArrayStride should be set to 1
            because on PositionNormalTexture element (one element in array) defines all the data needed to describe one Vertex.
            </para>
                <para>
            When SimpleMesh is created with basic types like float or byte, then more then one array element is needed to define one Vertex.
            For example if SimpleMesh is defined as SimpleMesh&lt;float&gt; (with float values) and one Vertex data contains position, normal and texture, then the ArrayStride should be 3 + 3 + 2 = 8 (8 float values represent one Vertex).
            When using byte, the ArrayStride should be set to (3 + 3 + 2) * 4 = 32 (32 bytes for one Vertex; 1 float = 4 bytes)
            </para>
                <para>
            This value must be changed before the SimpleMesh is initialized. If the value is changed after that, the <see cref="M:Ab3d.DirectX.SimpleMesh`1.RecreateMesh(System.Boolean,System.Boolean,System.Boolean)" /> must be called.
            </para>
                <para>
            Default value is 1.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.SimpleMesh`1.CreateDynamicVertexBuffer">
            <summary>
            Gets or sets a Boolean that specifies if the vertex buffer is created as a dynamic buffer.
            This can provide slightly better performance for cases when vertex buffer is updated very often.
            Default value is false.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SimpleMesh`1.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name</param>
        </member>
        <member name="M:Ab3d.DirectX.SimpleMesh`1.#ctor(`0[],System.Int32[],Ab3d.DirectX.InputLayoutType,System.String,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="vertexBufferArray">array of T structs that define the vertex buffer</param>
            <param name="indexBufferArray">array that is used to define the index buffer</param>
            <param name="inputLayoutType">InputLayoutType</param>
            <param name="name">name</param>
            <param name="createDynamicVertexBuffer">when true the vertex buffer is created as a dynamic buffer (can provide slightly better performance for cases when vertex buffer is updated very often)</param>
        </member>
        <member name="M:Ab3d.DirectX.SimpleMesh`1.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.SimpleMesh`1.RecreateMesh(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            RecreateMesh disposes the existing VertexBuffers and IndexBuffer and recreates the buffers.
            </summary>
            <param name="recreateVertexBuffer">when true the vertex buffer is re-created (or updated in case of dynamic vertex buffer)</param>
            <param name="recreateIndexBuffer">when true the index buffer is re.created</param>
            <param name="updateBounds">when true the bounds are re-calculated</param>
        </member>
        <member name="M:Ab3d.DirectX.SimpleMesh`1.CalculateBounds(System.Boolean)">
            <summary>
            Calculates and updates Bounds from the specified VertexBufferArray.
            The method can calculate bounds only when VertexBufferArray is of type PositionNormalTexture and PositionNormal.
            </summary>
            <param name="throwExceptionWhenUnsupported">when true (by default) the method will throw exception when the format of VertexBufferArray is not supported; when false the method will return false in case of unsupported format</param>
            <returns>true if the bounds were calculated (false if the format of VertexBufferArray is not supported)</returns>
        </member>
        <member name="M:Ab3d.DirectX.SimpleMesh`1.GetClosestHitResult(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.SimpleMesh`1.GetNextHitResult(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext,Ab3d.DirectX.DXRayHitTestResult)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.SimpleMesh`1.HitTest(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            HitTest method test the triangles defined in this mesh for hitting with the specified ray.
            When getOnlyNextHitTest is false, then the closest hit result is returned, else the next hit result is returned.
            When no hit is found, null is returned.
            </summary>
            <remarks>
                <para>
            HitTest method test the triangles defined in this mesh for hitting with the specified ray.
            When getOnlyNextHitTest is false, then the closest hit result is returned, else the next hit result is returned.
            When no hit is found, null is returned.
            </para>
                <para>
            SimpleMesh can be created with any type of vertex buffer.
            The HitTest method support only vertex buffer arrays with the following types:<br />
            PositionNormalTexture<br />
            PositionNormal<br />
            PositionTexture<br />
            Vector3
            </para>
                <para>
            In case of those type this method will call the appropriate method in the <see cref="T:Ab3d.DirectX.HitTester" /> class.
            </para>
                <para>
            Other types will always return null or throw a NotSupportedException when throwExceptionWhenUnsupported parameter is true (false by default).
            </para>
            </remarks>
            <param name="localRay">SharpDX.Ray in local SceneNode coordinate system</param>
            <param name="hitTestContext">DXHitTestContext</param>
            <param name="startTriangleIndex">triangle index where to start looking for hit. Note that this is not an index in the triangle indices array (index buffer) but triangle index - index in triangle indices array is get by multiplying this value by 3.</param>
            <param name="getOnlyNextHitTest">When getOnlyNextHitTest is false, then the closest hit result is returned, else the next hit result is returned.</param>
            <param name="throwExceptionWhenUnsupported">when true an exception is thrown in case an unsupported vertex buffer type is used (supported types: PositionNormalTexture, PositionNormal, PositionTexture, Vector3). Default value is false.</param>
            <returns>DXRayHitTestResult when hit is found or null when no hit is found</returns>
        </member>
        <member name="M:Ab3d.DirectX.SimpleMesh`1.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.SubMesh">
            <summary>
            SubMesh is part of the <see cref="T:Ab3d.DirectX.MeshBase" /> that uses the same vertex and index buffers as the MeshBase but use its own Material, StartIndexLocation and IndexCount.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SubMesh.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SubMesh.MaterialIndex">
            <summary>
            Gets or sets an index of the material defined in the parent's Mesh Materials collection.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SubMesh.IndexBuffer">
            <summary>
            If IndexBuffer is set than this index buffer is used to render this SubMesh. If not set, than parent's Mesh IndexBuffer is used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SubMesh.StartIndexLocation">
            <summary>
            start index in IndexBuffer used in DrawIndexed method
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SubMesh.IndexCount">
            <summary>
            number of indices to render 
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SubMesh.Bounds">
            <summary>
            Bounds of this SubMesh. When null, then Bounds of parent Mesh are used.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SubMesh.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">optional name</param>
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.BlackAndWhitePostProcess">
            <summary>
            BlackAndWhitePostProcess is a simple <see cref="T:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess" /> that converts the scene into black and white scene.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.BlackAndWhitePostProcess.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.BlackAndWhitePostProcess" /> class.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.DownSamplePostProcess">
            <summary>
            DownSamplePostProcess is a post process that can down-sample a bigger texture to a smaller texture.
            It is using linear sampler on the graphics card to combine multiple pixels into one final pixel.
            To use a down-sampler with advanced filter use <see cref="T:Ab3d.DirectX.PostProcessing.DownSampleWithFilerPostProcess" />.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.DownSamplePostProcess.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.DownSamplePostProcess" /> class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.DownSamplePostProcess.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.DownSamplePostProcess" /> class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.DownSamplePostProcess.GetSamplerState(Ab3d.DirectX.RenderingContext)">
            <summary>
            Gets a sampler state that will be used to sample the input texture (CommonStates.LinearClamp by default)
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <returns>sampler state that will be used to sample the input texture</returns>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.DownSamplePostProcess.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.DownSampleWithFilerPostProcess">
            <summary>
            DownSampleWithFilerPostProcess is a post process that can down-sample a bigger texture to a smaller texture.
            It is using a special slightly rotated pattern (filter) to sample the pixels on a bigger texture in such a way that
            colors from many pixels are read. This produces better results that simple linear filter that is used in <see cref="T:Ab3d.DirectX.PostProcessing.DownSamplePostProcess" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.DownSampleWithFilerPostProcess.CenterPixelWeight">
            <summary>
            Gets or sets weight from 0 to 1 of the center pixel. Bigger values means that center pixel will get more weight in the final pixel. Default value is 0.28.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.DownSampleWithFilerPostProcess.TexelOffsetsScale">
            <summary>
            Multiplies the texel offset by this factor. It is used to down-sample from bigger textures so that offsets reach bigger area.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.DownSampleWithFilerPostProcess.FilterType">
            <summary>
            Type of filter to use for down-sampling.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.DownSampleWithFilerPostProcess.#ctor(Ab3d.DirectX.SupersamplingResolveFilterType)">
            <summary>
            Constructor
            </summary>
            <param name="filterType">SupersamplingResolveFilterType</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.DownSampleWithFilerPostProcess.FillOffsetsAndWeights(Ab3d.DirectX.RenderingContext,System.Boolean,SharpDX.Vector2[],System.Single[])">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.ExpandPostProcess">
            <summary>
            ExpandPostProcess renders an outline in a two pass (horizontal and vertical) post process.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PostProcessing.ExpandPostProcess.MaxExpansionWidth">
            <summary>
            Max value for <see cref="P:Ab3d.DirectX.PostProcessing.ExpandPostProcess.ExpansionWidth" />.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PostProcessing.ExpandPostProcess.DefaultOffsets">
            <summary>
            Default Offsets value
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PostProcessing.ExpandPostProcess.DefaultFactors">
            <summary>
            Default Factors value
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.ExpandPostProcess.IsVerticalRenderingPass">
            <summary>
            Gets or sets a boolean that specifies if vertical rendering pass is applied. if false than horizontal rendering pass is applied. 
            Note that in order to get full expand effect then two ExpandPostProcess must be used - one with horizontal and one with vertical rendering pass.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.ExpandPostProcess.ExpansionWidth">
            <summary>
            Gets or sets the width of the expansion (the distance in pixels that are checked away from the current pixel).
            ExpansionWidth values can be between 1 (zero is not allowed) and 16 (ExpandPostProcess.MaxExpansionWidth).
            Bigger numbers mean that more pixels will be sampled in pixel shader and will therefore require more time to execute the post process.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.ExpandPostProcess.TextureSize">
            <summary>
            Gets or sets the size of the texture.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.ExpandPostProcess.BackgroundColor">
            <summary>
            The color of the background - only colors that are not the same as background will be expanded.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.ExpandPostProcess.Offsets">
            <summary>
            Gets or sets a Vector4 that specifies RGBA values that are added to each rendered pixel. Default value is (0, 0, 0, 0)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.ExpandPostProcess.Factors">
            <summary>
            Gets or sets a Vector4 that specifies RGBA values that are multiplied with each rendered pixel. Default value is (1, 1, 1, 1)
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.ExpandPostProcess.#ctor(System.Boolean,System.Int32,SharpDX.Color4)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.ExpandPostProcess" /> class.
            </summary>
            <param name="isVerticalRenderingPass">if set to <c>true</c> the ExpandPostProcess will render the vertical pass; otherwise a horizontal pass is rendered.</param>
            <param name="expansionWidth">width of the expansion</param>
            <param name="backgroundColor">The color of the background - only colors that are not the same as background will be expanded</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.ExpandPostProcess.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this PostProcess.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.ExpandPostProcess.ApplyCustomResources(Ab3d.DirectX.RenderingContext)">
            <summary>
            ApplyResources method can be overriden to set up constant buffers or additional textures.
            Note that the sampler state should be set with overriding the GetSamplerState.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.ExpandPostProcess.GetSamplerState(Ab3d.DirectX.RenderingContext)">
            <summary>
            Gets a sampler state that will be used to sample the input texture (CommonStates.LinearClamp by default)
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <returns>sampler state that will be used to sample the input texture</returns>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.ExpandPostProcess.Render(Ab3d.DirectX.RenderingContext,SharpDX.Direct3D11.ShaderResourceView)">
            <summary>
            Render renders the post process with using the sourceShaderResourceView as the source texture.
            It rendered the output to the CurrentRenderTargetView defined in the renderingContext.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="sourceShaderResourceView">ShaderResourceView that defines the source texture - the texture that is read and changed by this post process</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.ExpandPostProcess.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.GammaCorrectionPostProcess">
            <summary>
            GammaCorrectionPostProcess is a post process that can apply a custom gamma correction to the rendered image.<br />
            The following operation is executed in the shader: finalColor = float4(pow(color.rgb, 1.0 / Gamma), color.a)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.GammaCorrectionPostProcess.Gamma">
            <summary>
            Gamma value (2.2 by default)
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.GammaCorrectionPostProcess.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.GammaCorrectionPostProcess" /> class.
            </summary>
            <param name="gamma">Gamma value (2.2 by default)</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.GammaCorrectionPostProcess.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this PostProcess.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.GammaCorrectionPostProcess.ApplyCustomResources(Ab3d.DirectX.RenderingContext)">
            <summary>
            ApplyResources method can be overriden to set up constant buffers or additional textures.
            Note that the sampler state should be set with overring the GetSamplerState.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.GammaCorrectionPostProcess.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.GaussianBlurPostProcess">
            <summary>
            GaussianBlurPostProcess applies horizontal or vertical gaussian blur post process.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.GaussianBlurPostProcess.BlurStandardDeviation">
            <summary>
            Gets or sets a standard deviation value that is used to calculate the gaussian values. Default value is 2.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.GaussianBlurPostProcess.#ctor(System.Boolean,System.Single,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.GaussianBlurPostProcess" /> class.
            </summary>
            <param name="isVerticalBlur">if set to <c>true</c> the GaussianBlurPostProcess will render the vertical pass; otherwise a horizontal pass is rendered.</param>
            <param name="blurStandardDeviation">blur standard deviation (default value is 2)</param>
            <param name="filterSize">number of pixels to read to produce the blurred color (possible values: 5, 7, 9, 11, 13, 15; 15 by default). When using smaller filer size, the blurStandardDeviation also needs to be reduced (for example use 0.5 for filterSize=5)</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.GaussianBlurPostProcess.FillOffsetsAndWeights(Ab3d.DirectX.RenderingContext,System.Boolean,SharpDX.Vector2[],System.Single[])">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.PostProcessBase">
            <summary>
            PostProcessBase is a base class for all post processes in DXEngine.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.PostProcessBase.Render(Ab3d.DirectX.RenderingContext,SharpDX.Direct3D11.ShaderResourceView)">
            <summary>
            Render renders the post process
            </summary>
            <param name="renderingContext">renderingContext</param>
            <param name="sourceShaderResourceView">sourceShaderResourceView</param>
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess">
            <summary>
             SeparableKernelPostProcess applies horizontal or vertical gaussian post process.
             It uses array of offsets and weights to define how the pixels are processed (size of the arrays is defined by the filterSize specified in the constructor - max value is 15).
             This post process usually needs to be rendered in two passes - one vertical and one horizontal.
             </summary>
            <remarks>
                <para>
             SeparableKernelPostProcess applies horizontal or vertical gaussian blur post process.
             It uses array of offsets and weights to define how the pixels are processed.
             </para>
                <para>
             Offsets define how far from the texture coordinate we sample pixel.
             Weights define how much weight this pixel has in the final color.
             </para>
                <para>
             The following pixel shader is used for this post process:
             </para>
                <code>
             float4 output = (float4)0.0f;
            
             for (int i = 0; i &lt; 15; i++)
                 output += gTexture.Sample(gSampler, psIn.textCoord + gOffsets[i]) * gWeights[i];
            	
             return output;
             </code>
            </remarks>
        </member>
        <member name="F:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.MaxFilterSize">
            <summary>
            MaxFilterSize defines the maximum filter size that is supported by this post-process.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.isConstantBufferDirty">
            <summary>
            True when the properties of this post post process has changed and the constant buffer needs to be changed.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.FilterSize">
            <summary>
            Gets the size of the filter - number of pixels that are read to get the color produces by this post-process.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.IsVerticalPass">
            <summary>
            Gets a boolean that specifies if vertical rendering pass is applied. If false than horizontal pass is applied. This value is set in constructor.
            Note that in order to render this post process fully, it needs to run in two passes - once as vertical and once as horizontal post process.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.TextureSize">
            <summary>
            Gets or sets the size of the texture.
            </summary>
            <value>
            The size of the texture.
            </value>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess" /> class.
            </summary>
            <param name="filterSize">size of the filter - number of pixels that are read to get the color produces by this post-process (max value is 15; 15 by default)</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.#ctor(System.Boolean,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess" /> class.
            </summary>
            <param name="isVerticalBlur">if set to <c>true</c> than this post process will render the vertical pass; otherwise a horizontal pass is rendered.</param>
            <param name="filterSize">size of the filter - number of pixels that are read to get the color produces by this post-process (max value is 15; 15 by default)</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this PostProcess.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.Render(Ab3d.DirectX.RenderingContext,SharpDX.Direct3D11.ShaderResourceView)">
            <summary>
            Render renders the post process with using the sourceShaderResourceView as the source texture.
            It rendered the output to the CurrentRenderTargetView defined in the renderingContext.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="sourceShaderResourceView">ShaderResourceView that defines the source texture - the texture that is read and changed by this post process</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.ApplyCustomResources(Ab3d.DirectX.RenderingContext)">
            <summary>
            ApplyResources method can be overridden to set up constant buffers or additional textures.
            Note that the sampler state should be set with overriding the GetSamplerState.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.FillOffsetsAndWeights(Ab3d.DirectX.RenderingContext,System.Boolean,SharpDX.Vector2[],System.Single[])">
            <summary>
            FillOffsetsAndWeights fulls the specified offsets and weights arrays with values that are used
            in hsls shader to render this post process.
            Offsets define how far from the texture coordinate we sample pixel.
            Weights define how much weight this pixel has in the final color.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="isVerticalPass">true when we need to prepare values for vertical pass; otherwise horizontal pass will be used.</param>
            <param name="offsets">array of offsets</param>
            <param name="weights">array of weights</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.GetSamplerState(Ab3d.DirectX.RenderingContext)">
            <summary>
            Gets a sampler state that will be used to sample the input texture (CommonStates.LinearClamp by default)
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <returns>sampler state that will be used to sample the input texture</returns>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SeparableKernelPostProcess.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.SimpleBlurPostProcess">
            <summary>
            SimpleBlurPostProcess applies horizontal or vertical simple blur post process.
            This blur simply set the color of each pixel with equally averaging its color with the neighboring colors.
            Number of neighboring colors is define by FilterWidth property.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.SimpleBlurPostProcess.IsVerticalBlur">
            <summary>
            Gets or sets a boolean that specifies if vertical blur is applied. if false than horizontal blur is applied. 
            Note that in order to get full blur two SimpleBlurPostProcess must be used - one with horizontal and one with vertical blur.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.SimpleBlurPostProcess.FilterWidth">
            <summary>
            Gets or sets the width of the filter (how much pixels are used to calculate the average pixel color). Default value is 5.
            </summary>
            <value>
            The width of the filter.
            </value>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.SimpleBlurPostProcess.TextureSize">
            <summary>
            Gets or sets the size of the texture.
            </summary>
            <value>
            The size of the texture.
            </value>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimpleBlurPostProcess.#ctor(System.Boolean,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.SimpleBlurPostProcess" /> class.
            </summary>
            <param name="isVerticalBlur">if set to <c>true</c> the SimpleBlurPostProcess will render the vertical pass; otherwise a horizontal pass is rendered.</param>
            <param name="filterWidth">width of the filter (default value is 5)</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimpleBlurPostProcess.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this PostProcess.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimpleBlurPostProcess.ApplyCustomResources(Ab3d.DirectX.RenderingContext)">
            <summary>
            ApplyResources method can be overriden to set up constant buffers or additional textures.
            Note that the sampler state should be set with overriding the GetSamplerState.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimpleBlurPostProcess.GetSamplerState(Ab3d.DirectX.RenderingContext)">
            <summary>
            Gets a sampler state that will be used to sample the input texture (CommonStates.LinearClamp by default)
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <returns>sampler state that will be used to sample the input texture</returns>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimpleBlurPostProcess.Render(Ab3d.DirectX.RenderingContext,SharpDX.Direct3D11.ShaderResourceView)">
            <summary>
            Render renders the post process with using the sourceShaderResourceView as the source texture.
            It rendered the output to the CurrentRenderTargetView defined in the renderingContext.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="sourceShaderResourceView">ShaderResourceView that defines the source texture - the texture that is read and changed by this post process</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimpleBlurPostProcess.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess">
            <summary>
            SimplePixelShaderPostProcess class defines post process effects that use a pixel shader to render the post process.
            The SimplePixelShaderPostProcess is derived from the <see cref="T:Ab3d.DirectX.PostProcessing.StandardPostProcess" /> that defines the vertex shader that prepares the full screen quad used by the pixel shader.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess.pixelShaderResourceName">
            <summary>
            The pixel shader resource name
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess" /> class.
            </summary>
            <param name="pixelShaderResourceName">Name of the pixel shader resource.</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess.ChangePixelShader(System.String)">
            <summary>
            Changes the pixel shader. If InitializeResources was already called, then the new pixel shader is also loaded. Otherwise it will be loaded when InitializeResources is called.
            </summary>
            <param name="newPixelShaderResourceName"></param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this PostProcess.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess.GetPixelShader(Ab3d.DirectX.DXDevice)">
            <summary>
            GetPixelShader method returns the PixelShader as shared resource.
            The pixel shader is get from EffectsManager and defined by the pixelShaderResourceName used in the constructor of this class.
            The method can be overridden to provide its own way to get the pixel shader. 
            </summary>
            <param name="dxDevice">DXDevice used for ths pixel shader</param>
            <returns>PixelShader as shared resource</returns>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess.Render(Ab3d.DirectX.RenderingContext,SharpDX.Direct3D11.ShaderResourceView)">
            <summary>
            Render renders the post process with using the sourceShaderResourceView as the source texture.
            It rendered the output to the CurrentRenderTargetView defined in the renderingContext.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="sourceShaderResourceView">ShaderResourceView that defines the source texture - the texture that is read and changed by this post process</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess.GetSamplerState(Ab3d.DirectX.RenderingContext)">
            <summary>
            Gets a sampler state that will be used to sample the input texture (CommonStates.LinearClamp by default)
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <returns>sampler state that will be used to sample the input texture</returns>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess.ApplyCustomResources(Ab3d.DirectX.RenderingContext)">
            <summary>
            ApplyResources method can be overriden to set up constant buffers or additional textures.
            Note that the sampler state should be set with overring the GetSamplerState.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.SoberEdgeDetectionPostProcess">
            <summary>
            SoberEdgeDetectionPostProcess is a post process that can be used to find the edges of the object.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PostProcessing.SoberEdgeDetectionPostProcess.isConstantBufferDirty">
            <summary>
            True when the properties of this post post process has changed and the constant buffer needs to be changed.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.SoberEdgeDetectionPostProcess.TextureSize">
            <summary>
            Gets or sets the size of the texture.
            </summary>
            <value>
            The size of the texture.
            </value>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.SoberEdgeDetectionPostProcess.EdgeThreshold">
            <summary>
            Gets or sets a float value that specifies the edge threshold that is needed to decide how big the color difference need to be to render an edge.
            Smaller values produce more edges, bigger values less edges. Default value is 0.05f.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.SoberEdgeDetectionPostProcess.MultiplyWithCurrentColor">
            <summary>
            Gets or sets a Boolean value that specifies if the edge color defined by this post-process is multiplied with the existing pixel color - this way the edges are added to the existing rendering.
            When false then only the edges are preserved and the original rendering is not visible any more. Default value is true.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SoberEdgeDetectionPostProcess.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.SoberEdgeDetectionPostProcess" /> class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SoberEdgeDetectionPostProcess.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this PostProcess.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SoberEdgeDetectionPostProcess.Render(Ab3d.DirectX.RenderingContext,SharpDX.Direct3D11.ShaderResourceView)">
            <summary>
            Render renders the post process with using the sourceShaderResourceView as the source texture.
            It rendered the output to the CurrentRenderTargetView defined in the renderingContext.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="sourceShaderResourceView">ShaderResourceView that defines the source texture - the texture that is read and changed by this post process</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SoberEdgeDetectionPostProcess.ApplyCustomResources(Ab3d.DirectX.RenderingContext)">
            <summary>
            ApplyResources method can be overridden to set up constant buffers or additional textures.
            Note that the sampler state should be set with overriding the GetSamplerState.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SoberEdgeDetectionPostProcess.GetSamplerState(Ab3d.DirectX.RenderingContext)">
            <summary>
            Gets a sampler state that will be used to sample the input texture (CommonStates.LinearClamp by default)
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <returns>sampler state that will be used to sample the input texture</returns>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.SoberEdgeDetectionPostProcess.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.StandardPostProcess">
            <summary>
            StandardPostProcess class is a base abstract class for all post process effects that are created by rendering a full screen quad (rectangle with two triangles)
            and have the post process login in pixel shader that is defined by the derived classes.
            The StandardPostProcess by default uses the PostProcessingVertexShader.vs vertex shader that prepares the quad for the pixel shader.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PostProcessing.StandardPostProcess.vertexShaderSharedResource">
            <summary>
            VertexShader shared resource
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PostProcessing.StandardPostProcess.inputLayoutSharedResource">
            <summary>
            InputLayout shared resource
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PostProcessing.StandardPostProcess.fullScreenQuadRenderableMeshPrimitive">
            <summary>
            RenderableMeshPrimitive that represents the full screen quad (rectangle with two triangles)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PostProcessing.StandardPostProcess.Viewport">
            <summary>
            Gets or sets a part of the screen that will be affected by this PostProcess.
            The coordinates are defined in NDC space (Normalized Device Coordinates) that means that the full screen post process will be defined as (0,0,1,1).
            This is also a default value for Viewport;
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.StandardPostProcess.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.StandardPostProcess" /> class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.StandardPostProcess.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes this PostProcess.
            </summary>
            <param name="dxDevice">parent DXDevice</param>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.StandardPostProcess.CreateQuad">
            <summary>
            Creates the SimpleMesh that defines the full screen quad.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.StandardPostProcess.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.ToNonPremultipliedAlphaPostProcess">
            <summary>
            ToNonPremultipliedAlphaPostProcess is a simple <see cref="T:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess" /> that converts texture rendered with pre-multiplied alpha to a texture without pre-multiplied alpha.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.ToNonPremultipliedAlphaPostProcess.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.ToNonPremultipliedAlphaPostProcess" /> class.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.PostProcessing.ToonShadingPostProcess">
            <summary>
            ToonShadingPostProcess is a simple <see cref="T:Ab3d.DirectX.PostProcessing.SimplePixelShaderPostProcess" /> that reduces the amount of colors in the scene (combining similar colors into one color)
            and creating a look like the scene would be rendered for a cartoon.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PostProcessing.ToonShadingPostProcess.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PostProcessing.ToonShadingPostProcess" /> class.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.ChangeBackBufferRenderingStep">
            <summary>
            ChangeBackBufferRenderingStep can be used to change the current BackBuffer, RenderTargetView, DepthStencilView or Viewport.
            To set the new back buffer values use the <see cref="M:Ab3d.DirectX.ChangeBackBufferRenderingStep.SetNewBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32)" /> method. To set the new Viewport value set the <see cref="P:Ab3d.DirectX.ChangeBackBufferRenderingStep.NewViewport" /> property.
            When this rendering step is executed, the OutputMerger targets are chenged (if SetNewBackBuffer was called) and properties related to current back buffer in RenderingContext are changed.
            If NewViewport is set then also the Viewport in the RenderingContext and in Rasterizer are changed.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ChangeBackBufferRenderingStep.NewBackBuffer">
            <summary>
            Gets the BackBuffer as Texture2D that will be used in the further rendering steps.
            This value is set with <see cref="M:Ab3d.DirectX.ChangeBackBufferRenderingStep.SetNewBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ChangeBackBufferRenderingStep.NewBackBufferDescription">
            <summary>
            Gets sets the description of the BackBuffer.
            This value is set with <see cref="M:Ab3d.DirectX.ChangeBackBufferRenderingStep.SetNewBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ChangeBackBufferRenderingStep.NewRenderTargetView">
            <summary>
            Gets the RenderTargetView that will be used in the further rendering steps.
            This value is set with <see cref="M:Ab3d.DirectX.ChangeBackBufferRenderingStep.SetNewBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ChangeBackBufferRenderingStep.NewDepthStencilView">
            <summary>
            Gets the DepthStencilView that will be used in the further rendering steps.
            This value is set with <see cref="M:Ab3d.DirectX.ChangeBackBufferRenderingStep.SetNewBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ChangeBackBufferRenderingStep.NewSuperSamplingCount">
            <summary>
            Gets the super-sampling count of the <see cref="P:Ab3d.DirectX.ChangeBackBufferRenderingStep.NewBackBuffer" /></summary>
        </member>
        <member name="P:Ab3d.DirectX.ChangeBackBufferRenderingStep.NewViewport">
            <summary>
            Gets or sets the viewport that will be used in the further rendering steps.
            If this property is not set, the Viewport in RenderingContext will not be changed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ChangeBackBufferRenderingStep.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.ChangeBackBufferRenderingStep.SetNewBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32)">
            <summary>
            Sets the BackBuffer its RenderTargetView and DepthStencilView that will be set changed by this RenderingStep.
            </summary>
            <param name="backBuffer">Texture2D of the back buffer</param>
            <param name="backBufferDescription">Texture2DDescription of the back buffer</param>
            <param name="renderTargetView">RenderTargetView of the back buffer</param>
            <param name="depthStencilView">DepthStencilView for the back buffer</param>
            <param name="superSamplingCount">super-sampling count (1 for no super-sampling)</param>
        </member>
        <member name="M:Ab3d.DirectX.ChangeBackBufferRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.ChangeBackBufferRenderingStep.SaveExecutionTimeStatistics(System.Double,Ab3d.DirectX.RenderingStatistics)">
            <summary>
            SaveExecutionTimeStatistics is called when we are collecting statistics.
            The implementation of the method should save or add the elapsedMilliseconds to the corresponding property in the RenderingStatistics class.
            </summary>
            <param name="stepExecutionTimeInMilliseconds">time in milliseconds to execute this rendering step</param>
            <param name="renderingStatistics">RenderingStatistics</param>
        </member>
        <member name="M:Ab3d.DirectX.ChangeBackBufferRenderingStep.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.CompleteRenderingStep">
            <summary>
            CompleteRendering is the last rendering step. It Presents SwapChain (if used) or prepares the output buffer that can be send to WPF or CPU memory.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.CompleteRenderingStep.DeviceContextFlushTimeoutMs">
            <summary>
            Time in milliseconds that is used as timeout when waiting until the DirectX completes the rendering of an image and before the rendered image is sent to WPF or main memory. 
            This timeout is not used when using SwapChain. Default value is 5000 (5 seconds).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.CompleteRenderingStep.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.CompleteRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.CompleteRenderingStep.SaveExecutionTimeStatistics(System.Double,Ab3d.DirectX.RenderingStatistics)">
            <summary>
            SaveExecutionTimeStatistics is called when we are collecting statistics.
            The implementation of the method should save or add the elapsedMilliseconds to the corresponding property in the RenderingStatistics class.
            </summary>
            <param name="stepExecutionTimeInMilliseconds">time in milliseconds to execute this rendering step</param>
            <param name="renderingStatistics">RenderingStatistics</param>
        </member>
        <member name="M:Ab3d.DirectX.CompleteRenderingStep.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.CustomActionRenderingStep">
            <summary>
            CustomActionRenderingStep can be used to execute custom method as part of rendering process.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.CustomActionRenderingStep.CustomActionHandler">
            <summary>
            Delegate that defined the CustomAction used by CustomActionRenderingStep.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="P:Ab3d.DirectX.CustomActionRenderingStep.CustomAction">
            <summary>
            Gets or sets a delegate that will be called when this rendering step is executed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.CustomActionRenderingStep.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.CustomActionRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="T:Ab3d.DirectX.CustomRenderingContext">
            <summary>
            CustomRenderingContext is the same as it base <see cref="T:Ab3d.DirectX.RenderingContext" /> class, except that this class has two additional public methods: <see cref="M:Ab3d.DirectX.CustomRenderingContext.SetPerFrameData(System.Int32,Ab3d.DirectX.DXScene.ChangeNotifications)" /> and <see cref="M:Ab3d.DirectX.CustomRenderingContext.SetFinalBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)" />.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderingContext.#ctor(Ab3d.DirectX.DXScene,SharpDX.Direct3D11.DeviceContext,Ab3d.DirectX.ContextStatesManager)">
            <summary>
            Constructor
            </summary>
            <param name="dxScene">DXScene</param>
            <param name="deviceContext">DeviceContext</param>
            <param name="contextStatesManager">ContextStatesManager</param>
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderingContext.SetPerFrameData(System.Int32,Ab3d.DirectX.DXScene.ChangeNotifications)">
            <summary>
            SetPerFrameData
            </summary>
            <param name="frameNumber">frameNumber</param>
            <param name="renderReason">ChangeNotifications flags that were set on DXScene with NotifyChange method and describe the changes that lead to render</param>
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderingContext.SetFinalBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)">
            <summary>
            SetFinalBackBuffer - a back buffer that will get the final rendering of the rendering process.
            </summary>
            <param name="finalBackBuffer">finalBackBuffer</param>
            <param name="finalBackBufferDescription">finalBackBufferDescription</param>
            <param name="finalRenderTargetView">finalRenderTargetView</param>
        </member>
        <member name="T:Ab3d.DirectX.InitializeRenderingStep">
            <summary>
            InitializeRendering is the first rendering step. It sets up the RenderingContext with current RenderTargets, resets statistics, etc.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.InitializeRenderingStep.IsInitializingFromDXScene">
            <summary>
            Gets or sets a Boolean that specifies if this InitializeRenderingStep sets BackBuffers, BackBuffer views, CurrentViewport and UsedCamera from DXScene.
            Default value is true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.InitializeRenderingStep.IsSortingRenderingQueues">
            <summary>
            Gets or sets a Boolean that specifies if this InitializeRenderingStep calls Sort method on all RenderingQueues that support sorting.
            Default value is true. It can be set to false to disable sorting RenderingQueues or manually sort RenderingQueues in some other rendering step.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.InitializeRenderingStep.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.InitializeRenderingStep" /> class.
            </summary>
            <param name="name">name</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.InitializeRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.InitializeRenderingStep.UpdatedResolveBackBufferRenderingStep(Ab3d.DirectX.DXScene,System.Int32)">
            <summary>
            UpdatedResolveBackBufferRenderingStep method updates the <see cref="P:Ab3d.DirectX.DXScene.DefaultResolveBackBufferRenderingStep" /> and based on the specified supersamplingCount
            sets the recommended TexelOffsetsScale, ResolveFilter and CenterPixelWeight.
            </summary>
            <param name="dxScene">DXScene</param>
            <param name="supersamplingCount">supersamplingCount</param>
        </member>
        <member name="M:Ab3d.DirectX.InitializeRenderingStep.SaveExecutionTimeStatistics(System.Double,Ab3d.DirectX.RenderingStatistics)">
            <summary>
            SaveExecutionTimeStatistics is called when we are collecting statistics.
            The implementation of the method should save or add the elapsedMilliseconds to the corresponding property in the RenderingStatistics class.
            </summary>
            <param name="stepExecutionTimeInMilliseconds">time in milliseconds to execute this rendering step</param>
            <param name="renderingStatistics">RenderingStatistics</param>
        </member>
        <member name="T:Ab3d.DirectX.PreparePostProcessingRenderingStep">
            <summary>
            PreparePostProcessingRenderingStep prepares Shader resources and Render targets for <see cref="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.RenderPostProcessingRenderingStep" />.
            </summary>
            <remarks>
                <para>
                    <b>PreparePostProcessingRenderingStep</b> prepares Shader resources and Render targets for <see cref="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.RenderPostProcessingRenderingStep" />.
            </para>
                <para>
            The purpose of having separate <b>PreparePostProcessingRenderingStep</b> and <see cref="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.RenderPostProcessingRenderingStep" /> is to allow you to 
            use custom rendering step that prepares some other buffers for post process rendering or to use the buffers perpared in this step for custom post process rendering.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.PostProcessingBuffer1">
            <summary>
            Gets the first Texture2D buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.PostProcessingBufferDescription1">
            <summary>
            Gets the description of the first Texture2D buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.PostProcessingRenderTargetView1">
            <summary>
            Gets the first RenderTargetView
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.PostProcessingShaderResourceView1">
            <summary>
            Gets the first ShaderResourceView
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.PostProcessingBuffer2">
            <summary>
            Gets the second Texture2D buffer (used when rendering more than one post process)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.PostProcessingBufferDescription2">
            <summary>
            Gets the description of the second Texture2D buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.PostProcessingRenderTargetView2">
            <summary>
            Gets the second RenderTargetView (used when rendering more than one post process)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.PostProcessingShaderResourceView2">
            <summary>
            Gets the second ShaderResourceView (used when rendering more than one post process)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.DestinationBackBuffer">
            <summary>
            DestinationBackBuffer gets the Texture2D that will get the finally rendered image from the last post-process.
            This value can be set by <see cref="M:Ab3d.DirectX.PreparePostProcessingRenderingStep.SetCustomDestinationBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)" /> method. When null, the <see cref="P:Ab3d.DirectX.RenderingContext.FinalBackBuffer" /> is used as destination back buffer.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.DestinationBackBufferDescription">
            <summary>
            DestinationBackBufferDescription gets the description of the <see cref="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.DestinationBackBuffer" />.
            This value can be set by <see cref="M:Ab3d.DirectX.PreparePostProcessingRenderingStep.SetCustomDestinationBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)" /> method. When null, the <see cref="P:Ab3d.DirectX.RenderingContext.FinalBackBufferDescription" /> is used as destination back buffer.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.DestinationRenderTargetView">
            <summary>
            DestinationRenderTargetView gets the RenderTargetView of the <see cref="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.DestinationBackBuffer" />.
            This value can be set by <see cref="M:Ab3d.DirectX.PreparePostProcessingRenderingStep.SetCustomDestinationBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)" /> method. When null, the <see cref="P:Ab3d.DirectX.RenderingContext.FinalRenderTargetView" /> is used as destination back buffer.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PreparePostProcessingRenderingStep.RenderPostProcessingRenderingStep">
            <summary>
            Gets the RenderPostProcessingRenderingStep that will be initialized from this PreparePostProcessingRenderingStep.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PreparePostProcessingRenderingStep.#ctor(Ab3d.DirectX.RenderPostProcessingRenderingStep,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PreparePostProcessingRenderingStep" /> class.
            </summary>
            <param name="renderPostProcessingRenderingStep">The render post processing rendering step.</param>
            <param name="name">The name.</param>
            <param name="description">The description.</param>
            <exception cref="T:System.ArgumentNullException">renderPostProcessingRenderingStep</exception>
        </member>
        <member name="M:Ab3d.DirectX.PreparePostProcessingRenderingStep.SetCustomDestinationBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)">
            <summary>
            Sets the destination back buffer that will get the finally rendered image from the last post-process.
            </summary>
            <param name="destinationBackBuffer">destination BackBuffer</param>
            <param name="destinationBackBufferDescription">destination BackBufferDescription</param>
            <param name="destinationRenderTargetView">destination RenderTargetView</param>
        </member>
        <member name="M:Ab3d.DirectX.PreparePostProcessingRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.PreparePostProcessingRenderingStep.SaveExecutionTimeStatistics(System.Double,Ab3d.DirectX.RenderingStatistics)">
            <summary>
            SaveExecutionTimeStatistics is called when we are collecting statistics.
            The implementation of the method should save or add the elapsedMilliseconds to the corresponding property in the RenderingStatistics class.
            </summary>
            <param name="stepExecutionTimeInMilliseconds">time in milliseconds to execute this rendering step</param>
            <param name="renderingStatistics">RenderingStatistics</param>
        </member>
        <member name="M:Ab3d.DirectX.PreparePostProcessingRenderingStep.Dispose(System.Boolean)">
            <summary>
            Dispose any resources that are created in RenderingStep.
            </summary>
            <param name="isDisposing">isDisposing</param>
        </member>
        <member name="T:Ab3d.DirectX.PrepareRenderTargetsRenderingStep">
            <summary>
            PrepareRenderTargets is a rendering step that is usually called before objects are rendered.
            This step also calls DXScene's AfterFrameInitialized event.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PrepareRenderTargetsRenderingStep.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.PrepareRenderTargetsRenderingStep" /> class.
            </summary>
            <param name="name">name</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.PrepareRenderTargetsRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.PrepareRenderTargetsRenderingStep.SaveExecutionTimeStatistics(System.Double,Ab3d.DirectX.RenderingStatistics)">
            <summary>
            SaveExecutionTimeStatistics is called when we are collecting statistics.
            The implementation of the method should save or add the elapsedMilliseconds to the corresponding property in the RenderingStatistics class.
            </summary>
            <param name="stepExecutionTimeInMilliseconds">time in milliseconds to execute this rendering step</param>
            <param name="renderingStatistics">RenderingStatistics</param>
        </member>
        <member name="T:Ab3d.DirectX.RenderingContext">
            <summary>
            RenderingContext defines the context of the current rendering pass.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.Name">
            <summary>
            Gets the name the this RenderingContext (usually indicates a background or main thread)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderingContext.DXScene">
            <summary>
            Parent DXScene
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderingContext.DXDevice">
            <summary>
            Used DXDevice
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderingContext.DeviceContext">
            <summary>
            Currently used DeviceContext
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderingContext.ContextStatesManager">
            <summary>
            Currently used DeviceContext
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderingContext.CommonStates">
            <summary>
            Currently used CommonStates
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.CurrentRenderingStep">
            <summary>
            Gets currently executing RenderingStep
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.FinalBackBuffer">
            <summary>
            Gets the Texture2D that represents the BackBuffer that will contain the finally rendered image.
            FinalBackBuffer must not use multisampling and should not be a staging buffer. 
            When you need to copy the FinalBackBuffer to the main memory, set <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBuffer" />.
            FinalBackBuffer can be set with <see cref="M:Ab3d.DirectX.RenderingContext.SetFinalBackBufferInternal(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)" /> method that can be available from a class derived from RenderingContext - for example <see cref="T:Ab3d.DirectX.CustomRenderingContext" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.FinalBackBufferDescription">
            <summary>
            Gets the description of the <see cref="P:Ab3d.DirectX.RenderingContext.FinalBackBuffer" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.FinalRenderTargetView">
            <summary>
            Gets the RenderTargetView of the <see cref="P:Ab3d.DirectX.RenderingContext.FinalBackBuffer" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.SwapChain">
            <summary>
            Gets the SwapChain when DXEngine is using SwapChain or null when SwapChain is not used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.CurrentBackBuffer">
            <summary>
            Gets the currently used BackBuffer as Texture2D.
            The value of CurrentBackBuffer is initialized from DXScene.BackBuffer or DXScene.MSAABackBuffer (when multisampling is used) in the InitializeRenderingStep.
            The value can be changed with the <see cref="M:Ab3d.DirectX.RenderingContext.SetBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32,System.Boolean)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.CurrentBackBufferDescription">
            <summary>
            Gets the description of the currently used BackBuffer.
            The value of CurrentBackBufferDescription is initialized from DXScene.BackBufferDescription or DXScene.MSAABackBufferDescription (when multisampling is used) in the InitializeRenderingStep.
            The value can be changed with the <see cref="M:Ab3d.DirectX.RenderingContext.SetBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32,System.Boolean)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.CurrentRenderTargetView">
            <summary>
            Gets the currently used RenderTargetView.
            The value of CurrentRenderTargetView is initialized from DXScene.RenderTargetView in the InitializeRenderingStep.
            The value can be changed with the <see cref="M:Ab3d.DirectX.RenderingContext.SetBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32,System.Boolean)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.CurrentDepthStencilView">
            <summary>
            Gets the currently used DepthStencilView.
            The value of CurrentDepthStencilView is initialized from DXScene.DepthStencilView in the InitializeRenderingStep.
            The value can be changed with the <see cref="M:Ab3d.DirectX.RenderingContext.SetBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32,System.Boolean)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.CurrentViewport">
            <summary>
            Gets or sets the current Viewport that is used for the next DrawCall. 
            The value of CurrentViewport is initialized from DXScene.Viewport in the InitializeRenderingStep.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.CurrentSupersamplingCount">
            <summary>
            Gets a super-sampling count that is used by the current BackBuffer (how much more pixels are rendered for each final pixel). Value 1 indicates no super-sampling.
            This value is set by the <see cref="M:Ab3d.DirectX.RenderingContext.SetBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32,System.Boolean)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.CurrentSupersamplingFactor">
            <summary>
            Gets the factor by which width and height are multiplied because of the used super-sampling. This value is calculated by using Sqrt function of the <see cref="P:Ab3d.DirectX.RenderingContext.CurrentSupersamplingCount" /> value.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.UsedCamera">
            <summary>
            Gets or sets a camera that will be used to view the scene.
            Usually UsedCamera is set in the InitializeRenderingStep from the DXScene's Camera property.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.FrameNumber">
            <summary>
            Current frame number
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.RenderReason">
            <summary>
            Gets or sets ChangeNotifications flags that were set on DXScene with NotifyChange method and describe the changes that lead to render 
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.VirtualRealityContext">
            <summary>
            Gets the current VirtualRealityContext that is set when DXDEngine is using rendering for virtual reality (different images for left and right eye).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.StagingBackBuffer">
            <summary>
            StagingBackBuffer is used to allow coping the FinalBackBuffer to the main memory. 
            This is done in the <see cref="T:Ab3d.DirectX.CompleteRenderingStep" /> where the FinalBackBuffer is first copied to StagingBackBuffer and then
            the StagingBackBuffer is mapped so that it can be accessed by the CPU and copied to main memory.
            The StagingBackBuffer is set with <see cref="M:Ab3d.DirectX.RenderingContext.RegisterBackBufferMapping(Ab3d.DirectX.BackBufferReadyEventHandler)" /> or <see cref="M:Ab3d.DirectX.RenderingContext.RegisterBackBufferMapping(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,Ab3d.DirectX.BackBufferReadyEventHandler)" /> methods.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.StagingBackBufferDescription">
            <summary>
            Gets the description of the <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBuffer" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.StagingBackBufferMappedCallbacks">
            <summary>
            Get a list of BackBufferReadyEventHandler delegate that are called when the <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBuffer" /> has been mapped and is ready to be copied from GPU memory to the main memory.
            A delagate is added to this list with <see cref="M:Ab3d.DirectX.RenderingContext.RegisterBackBufferMapping(Ab3d.DirectX.BackBufferReadyEventHandler)" /> or <see cref="M:Ab3d.DirectX.RenderingContext.RegisterBackBufferMapping(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,Ab3d.DirectX.BackBufferReadyEventHandler)" /> methods.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.SSAABackBuffer">
            <summary>
            Gets super-sampled back buffer that is used for super-sampling. This property is set by <see cref="M:Ab3d.DirectX.RenderingContext.SetSupersamplingBackBuffers(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.RenderTargetView)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.SSAAShaderResourceView">
            <summary>
            Gets super-sampled back buffer ShaderResourceView that is used for super-sampling. This property is set by <see cref="M:Ab3d.DirectX.RenderingContext.SetSupersamplingBackBuffers(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.RenderTargetView)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.SSAARenderTargetView">
            <summary>
            Gets super-sampled back buffer RenderTargetView that is used for super-sampling. This property is set by <see cref="M:Ab3d.DirectX.RenderingContext.SetSupersamplingBackBuffers(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.RenderTargetView)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingContext.IsCollectingBackBufferChanges">
            <summary>
             Gets or sets a Boolean that specifies if all changes to BackBuffer are collected and can be get with calling the <see cref="M:Ab3d.DirectX.RenderingContext.GetBackBufferChangesReport" /> method.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingContext.#ctor(Ab3d.DirectX.DXScene,SharpDX.Direct3D11.DeviceContext,Ab3d.DirectX.ContextStatesManager,SharpDX.DXGI.SwapChain,System.String)">
            <summary>
            Constructor (with SwapChain)
            </summary>
            <param name="dxScene">DXScene</param>
            <param name="deviceContext">DeviceContext</param>
            <param name="contextStatesManager">ContextStatesManager</param>
            <param name="swapChain">SwapChain or null if no SwapChain is used</param>
            <param name="name">name of this RenderingContext (usually indicates RenderingContext for background threads)</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingContext.#ctor(Ab3d.DirectX.DXScene,SharpDX.Direct3D11.DeviceContext,Ab3d.DirectX.ContextStatesManager,System.String)">
            <summary>
            Constructor (without SwapChain)
            </summary>
            <param name="dxScene">DXScene</param>
            <param name="deviceContext">DeviceContext</param>
            <param name="contextStatesManager">ContextStatesManager</param>
            <param name="name">name of this RenderingContext (usually indicates RenderingContext for background threads)</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingContext.SetBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32,System.Boolean)">
            <summary>
            Changes the current BackBuffer and its RenderTargetView and DepthStencilView.
            With setting bindNewRenderTargetsToDeviceContext to true, it is also possible to call SetRenderTargets method on the DeviceContext.OutputMerger and change the currently bind RenderTargetView and DepthStencilView.
            The specified back buffer will be used for the following rendering steps. 
            If the specified back buffer is different from the <see cref="P:Ab3d.DirectX.RenderingContext.FinalBackBuffer" />, then the back buffer will be copied or resolved (in case of MSAA back buffer) into FinalBackBuffer at the end of rendering.
            </summary>
            <param name="backBuffer">Texture2D of the back buffer</param>
            <param name="backBufferDescription">Texture2DDescription of the back buffer</param>
            <param name="renderTargetView">RenderTargetView of the back buffer</param>
            <param name="depthStencilView">DepthStencilView for the back buffer</param>
            <param name="currentSupersamplingCount">currently used super-sampling count in the specified back buffers</param>
            <param name="bindNewRenderTargetsToDeviceContext">if false, then only the properties of this RenderingContext are changed; if true, then the newly set renderTargetView and depthStencilView will be bind to the DeviceContext - the following line will be executed: DeviceContext.OutputMerger.SetRenderTargets(depthStencilView, renderTargetView)</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingContext.SetSupersamplingBackBuffers(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.RenderTargetView)">
            <summary>
            Sets the CurrentSupersamplingCount and the super-sampled back buffer and its ShaderResourceView.
            </summary>
            <param name="ssaaBackBuffer">super-sampled back buffer or null to clear the SSAABackBuffer</param>
            <param name="ssaaShaderResourceView">super-sampled back buffer ShaderResourceView</param>
            <param name="ssaaRenderTargetView">super-sampled back buffer RenderTargetView</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingContext.RegisterBackBufferMapping(Ab3d.DirectX.BackBufferReadyEventHandler)">
            <summary>
            RegisterBackBufferMapping method is used to register a specified callback delegate that is called only once when the next frame is rendered.
            The render frame is also rendered into a special staging back buffer and that buffer is mapped so it can be accessed by the CPU (copied into main memory).
            This method creates an ad-hoc staging back buffer that is disposed after the stagingBackBufferMappedCallback is called.
            If you want to get multiple frames or specify your own staging back buffer the use the <see cref="M:Ab3d.DirectX.RenderingContext.RegisterBackBufferMapping(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,Ab3d.DirectX.BackBufferReadyEventHandler)" /> method.
            </summary>
            <remarks>
                <para>
                    <b>RegisterBackBufferMapping</b> method is used to register a specified callback delegate that is called only once when the next frame is rendered.
            The render frame is also rendered into a special staging back buffer and that buffer is mapped so it can be accessed by the CPU (copied into main memory).
            </para>
                <para>
            This method creates an ad-hoc staging back buffer that is disposed after the stagingBackBufferMappedCallback is called.
            </para>
                <para>
            If you want to get multiple frames or specify your own staging back buffer the use the <see cref="M:Ab3d.DirectX.RenderingContext.RegisterBackBufferMapping(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,Ab3d.DirectX.BackBufferReadyEventHandler)" /> method.
            </para>
                <para>
            If the method is called with null value for delegate, then this cancels the previously registered delegate and disposes all created buffers.
            </para>
                <para>
            The following example shows how to render the current scene to a WriteableBitmap (taken from Ab3d.DirectX.Client.Diagnostics project from DiagnosticsWindow.xaml.cs):
            </para>
                <example>
            // _renderedBitmap is a field of type WriteableBitmap and is used in the SaveRenderedBitmap (not shown here)
            // to save the rendered bitmap.
            
            DXView.DXScene.RenderingContext.RegisterBackBufferMapping(delegate (object sender, BackBufferReadyEventArgs e)
            {
                // We will copy rendered image into a new WriteableBitmap
                _renderedBitmap = new WriteableBitmap(e.Width, e.Height, 96, 96, PixelFormats.Bgra32, null);
            
                // delegate used by RenderToBitmap method - it is called when the scene is rendered to back buffer and it is available in main CPU memory
                _renderedBitmap.Lock();
            
                var viewportRect = new Int32Rect(0, 0, e.Width, e.Height);
            
                // Copy bitmap from e.Data.DataPointer to writeableBitmap
                _renderedBitmap.WritePixels(viewportRect, e.Data.DataPointer, e.Data.SlicePitch, e.Data.RowPitch);
            
                _renderedBitmap.AddDirtyRect(viewportRect);
                _renderedBitmap.Unlock();
            
                // We do not want to show SaveFileDialog inside a rendering pipeline.
                // So once we have the image in main memory in WriteableBitmap, we delay the invoke of saving bitmap and exit this callback 
                Dispatcher.BeginInvoke(DispatcherPriority.Normal, new Action(SaveRenderedBitmap));
            });
            
            // After we have subscribed to capture next frame, we can force rendering that frame
            DXView.Refresh();
            </example>
            </remarks>
            <param name="stagingBackBufferMappedCallback">Delegate that is called when the staging back buffer has been mapped and is ready to be copied from GPU memory to the main memory</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingContext.RegisterBackBufferMapping(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,Ab3d.DirectX.BackBufferReadyEventHandler)">
            <summary>
            RegisterBackBufferMapping registers the FinalBackBuffer to be accessable to the main memory.
            This is done with specifying the stagingBackBuffer that is used as intermediate buffer that can be mapped and then accessed by the CPU.
            The stagingBackBuffer must be created with Usage set to Staging and CpuAccessFlags set to Read.
            When the stagingBackBuffer is ready to be accessed (is mapped), the stagingBackBufferMappedCallback delegate is called.
            </summary>
            <remarks>
                <para>
                    <b>RegisterBackBufferMapping</b> registers the <see cref="P:Ab3d.DirectX.RenderingContext.FinalBackBuffer" /> to be accessable to the main memory.
            </para>
                <para>
            This is done with specifying the stagingBackBuffer that is used as intermediate buffer that can be mapped and then accessed by the CPU.
            The stagingBackBuffer must be created with Usage set to Staging and CpuAccessFlags set to Read.
            </para>
                <para>
            After the rendering is completed and the <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBuffer" /> is specified with this method,
            the <see cref="T:Ab3d.DirectX.CompleteRenderingStep" /> first copies the <see cref="P:Ab3d.DirectX.RenderingContext.FinalBackBuffer" /> into the <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBuffer" />
            and then maps it. This makes it accessable to the CPU. When this is done, the stagingBackBufferMappedCallback delegate is called.
            </para>
                <para>
            It is possible to register multiple callback delegates with calling RegisterBackBufferMapping multiple times.
            But each call to RegisterBackBufferMapping must use the same StagingBackBuffer.
            To use another StagingBackBuffer, unregister the currently registered callbacks with <see cref="M:Ab3d.DirectX.RenderingContext.UnregisterBackBufferMapping(Ab3d.DirectX.BackBufferReadyEventHandler)" /> before registering a new StagingBuffer.
            </para>
                <para>
            To unregister back buffer mapping do one of the following:<br />
            - set the <see cref="P:Ab3d.DirectX.BackBufferReadyEventArgs.IsRegisteredForBackBufferMapping" /> property to false in the BackBufferReadyEventHandler callback parameter or<br />
            - call the <see cref="M:Ab3d.DirectX.RenderingContext.UnregisterBackBufferMapping(Ab3d.DirectX.BackBufferReadyEventHandler)" /> method.<br /></para>
                <para>        
            After all the delegates are unregistered, the <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBuffer" /> will be set to null.
            </para>
            </remarks>
            <param name="stagingBackBuffer">Texture2D that specifies a StagingBackBuffer created with Usage set to Staging and CpuAccessFlags set to Read</param>
            <param name="stagingBackBufferDescription">Texture2DDescription of the stagingBackBuffer</param>
            <param name="stagingBackBufferMappedCallback">Delegate that is called when the <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBuffer" /> has been mapped and is ready to be copied from GPU memory to the main memory</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingContext.UnregisterBackBufferMapping(Ab3d.DirectX.BackBufferReadyEventHandler)">
            <summary>
            Unregisters the stagingBackBufferMappedCallback delegate that was registered with the <see cref="M:Ab3d.DirectX.RenderingContext.RegisterBackBufferMapping(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,Ab3d.DirectX.BackBufferReadyEventHandler)" /> method.
            When all the callbacks are unregistered the <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBuffer" /> and <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBufferMappedCallbacks" /> are set to null and
            <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBufferDescription" /> is reset to empty values.
            </summary>
            <remarks>
                <para>
                    <b>UnregisterBackBufferMapping</b> unregisters the stagingBackBufferMappedCallback delegate that was registered with the <see cref="M:Ab3d.DirectX.RenderingContext.RegisterBackBufferMapping(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,Ab3d.DirectX.BackBufferReadyEventHandler)" /> method.
            </para>
                <para>
            When all the callbacks are unregistered the <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBuffer" /> and <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBufferMappedCallbacks" /> are set to null and
            <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBufferDescription" /> is reset to empty values.
            </para>
                <para>
            It is also possible to unregister by setting the <see cref="P:Ab3d.DirectX.BackBufferReadyEventArgs.IsRegisteredForBackBufferMapping" /> property to false in the BackBufferReadyEventHandler callback parameter.<br /></para>
                <para>
            It is also possible to unregister all registered callbacks with <see cref="M:Ab3d.DirectX.RenderingContext.UnregisterAllBackBufferMappings" /> method.
            </para>
            </remarks>
            <param name="stagingBackBufferMappedCallback">BackBufferReadyEventHandler that was used in the RegisterBackBufferMapping call</param>
            <returns>true if there are no more callbacks registered after this call (StagingBackBuffer was set to null), false if there are still some other callbacks registered.</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingContext.UnregisterAllBackBufferMappings">
            <summary>
            Unregisters all delegates that were registered with the <see cref="M:Ab3d.DirectX.RenderingContext.RegisterBackBufferMapping(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,Ab3d.DirectX.BackBufferReadyEventHandler)" /> methods.
            The method also sets the <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBuffer" /> to null and resets the <see cref="P:Ab3d.DirectX.RenderingContext.StagingBackBufferDescription" /> to empty values.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingContext.GetBackBufferChangesReport">
            <summary>
            GetBackBufferChangesReport returns a string that contains all the BackBuffer changes and the RenderingStep names.
            To get results first set <see cref="P:Ab3d.DirectX.RenderingContext.IsCollectingBackBufferChanges" /> to true, render the scene again and then call this method.
            DebugName for DirectX resources need to be set to see any meaningful reports.
            </summary>
            <returns>return string with BackBuffer changes report</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingContext.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingContext.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.RenderingStepBase">
            <summary>
            RenderingStepBase is an abstract base class that implements IRenderingStep. It does not define any rendering logic but provides handling BeforeRunningStep and AfterRunningStep event handling.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStepBase.Description">
            <summary>
            Gets a description of this rendering step.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStepBase.IsEnabled">
            <summary>
            Gets or sets a boolean that specifies if this rendering step is enabled. Note that if the step is not enabled than the step events will also not be triggered.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStepBase.PreviousRenderingStep">
            <summary>
            Gets the previous RenderingStep.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStepBase.NextRenderingStep">
            <summary>
            Gets the next RenderingStep.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.RenderingStepBase.BeforeRunningStep">
            <summary>
            BeforeRunningStep is raised before this rendering step is run.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.RenderingStepBase.AfterRunningStep">
            <summary>
            AfterRunningStep is raised after this rendering step is run.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.Run(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.OnBeforeRunningStep(Ab3d.DirectX.RenderingContext)">
            <summary>
            OnBeforeRunningStep
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.OnAfterRunningStep(Ab3d.DirectX.RenderingContext)">
            <summary>
            OnAfterRunningStep
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.OnIsEnabledChanged">
            <summary>
            OnIsEnabledChanged is called when the IsEnabled is changed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.OnLoaded">
            <summary>
            OnLoaded is called when this rendering step is added to the RenderingStepsList.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.OnUnloaded">
            <summary>
            OnUnloaded is called when this rendering step is removed from the RenderingStepsList.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.SaveExecutionTimeStatistics(System.Double,Ab3d.DirectX.RenderingStatistics)">
            <summary>
            SaveExecutionTimeStatistics is called when we are collecting statistics.
            The implementation of the method should save or add the elapsedMilliseconds to the corresponding property in the RenderingStatistics class.
            </summary>
            <param name="stepExecutionTimeInMilliseconds">time in milliseconds to execute this rendering step</param>
            <param name="renderingStatistics">RenderingStatistics</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.GetLastRenderingStep(Ab3d.DirectX.RenderingStepBase)">
            <summary>
            Returns the last rendering step that is found with starting with startRenderingStep and then advancing to following rendering steps.
            Returns null if start rendering step is null.
            </summary>
            <param name="startRenderingStep">RenderingStepBase that will be the start rendering step</param>
            <returns>last rendering step</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.GetFirstRenderingStep(Ab3d.DirectX.RenderingStepBase)">
            <summary>
            Returns the first rendering step that is found with starting with startRenderingStep and then advancing to previous rendering steps.
            Returns null if start rendering step is null.
            </summary>
            <param name="startRenderingStep">RenderingStepBase that will be the start rendering step</param>
            <returns>first rendering step</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.IsRenderingStepConnected(Ab3d.DirectX.RenderingStepBase,Ab3d.DirectX.RenderingStepBase,System.Boolean,System.Boolean)">
            <summary>
            Returns true if the renderingStepToFind is find with searching the renderings steps connected to startRenderingStep.
            </summary>
            <param name="renderingStepToFind">rendering step to find (must not be null)</param>
            <param name="startRenderingStep">rendering step that will be the start of the seach (must not be null)</param>
            <param name="searchGroupChildRenderingSteps">if true then also the child rendering steps in the RenderingStepsGroup will be checked (true by default)</param>
            <param name="searchOnlyForward">if true then the search is done only in forward direction; if false the the previous steps are also checked (false by default)</param>
            <returns>true if the renderingStepToFind is find with searching the renderings steps connected to startRenderingStep</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepBase.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Ab3d.DirectX.RenderingStepsFlowControl">
            <summary>
            RenderingStepsFlowControl is a class that defines a RenderingStep that can control the flow of rendering steps execution with dynamically changing the rendering step that will be exected next.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsFlowControl.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsFlowControl.GetNextExecutedRenderingStep">
            <summary>
            Returns the RenderingStepBase that will be executed after this rendering step.
            This method is called after the OnRun method is called.
            </summary>
            <returns>RenderingStepBase that will be executed after this rendering step</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsFlowControl.OnRenderingStepsListChanged">
            <summary>
            OnRenderingStepsListChanged method is called each time after the RenderingSteps list is changed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsFlowControl.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Ab3d.DirectX.RenderingStepsGroup">
            <summary>
            RenderingStepsGroup is a rendering step that can group multiple rendering steps inside its <see cref="P:Ab3d.DirectX.RenderingStepsGroup.Children" /> list of rendering steps.
            </summary>
            <remarks>
                <para>
                    <b>RenderingStepsGroup</b> is a rendering step that can group multiple rendering steps inside its <see cref="P:Ab3d.DirectX.RenderingStepsGroup.Children" /> list of rendering steps.
            </para>
                <para>
            RenderingStepsGroup differences from other rendering steps:<br />
            - The <see cref="M:Ab3d.DirectX.RenderingStepsGroup.OnRun(Ab3d.DirectX.RenderingContext)" /> method is never called for RenderingStepsGroup<br />
            - The event <see cref="E:Ab3d.DirectX.RenderingStepBase.BeforeRunningStep" /> is called before the first child is executed.<br />
            - The event <see cref="E:Ab3d.DirectX.RenderingStepBase.AfterRunningStep" /> is called after the last child is executed.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStepsGroup.Children">
            <summary>
            Gets RenderingStepsList that holds the child rendering steps.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsGroup.#ctor(System.String,Ab3d.DirectX.RenderingStepsList,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name</param>
            <param name="parentRenderingStepsList">parentRenderingStepsList</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsGroup.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsGroup.Dispose(System.Boolean)">
            <summary>
            Dispose this rendering step and all child rendering steps
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsGroup.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Ab3d.DirectX.RenderingStepsList">
            <summary>
            RenderingStepsList is a collection of rendering steps. It provides additional methods to add rendering steps before and after specific rendering step.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStepsList.Name">
            <summary>
            Gets name of this RenderingStepsList.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStepsList.Count">
            <summary>
            Gets number of rendering steps
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStepsList.FirstRenderingStep">
            <summary>
            Gets first rendering step
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStepsList.LastRenderingStep">
            <summary>
            Gets last rendering step
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.RenderingStepsList.RenderingStepsListChanged">
            <summary>
            RenderingStepsListChanged event is triggered each time this RenderingStepsList is changed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.#ctor(Ab3d.DirectX.DXScene,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="parentDXScene">parent DXScene</param>
            <param name="name">name of this rendering step (null by default)</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.Add(Ab3d.DirectX.RenderingStepBase)">
            <summary>
            Adds rendering step after the last rendering step
            </summary>
            <param name="renderingStepToAdd">rendering step to add</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.AddAfter(Ab3d.DirectX.RenderingStepBase,Ab3d.DirectX.RenderingStepBase)">
            <summary>
            Adds rendering step (renderingStepToAdd) after the specified rendering step (existingRenderingStep)
            </summary>
            <param name="existingRenderingStep">rendering step after which the renderingStepToAdd will be added</param>
            <param name="renderingStepToAdd">rendering step that will be added after the existingRenderingStep</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.AddBefore(Ab3d.DirectX.RenderingStepBase,Ab3d.DirectX.RenderingStepBase)">
            <summary>
            Adds rendering step (renderingStepToAdd) before the specified rendering step (existingRenderingStep)
            </summary>
            <param name="existingRenderingStep">rendering step before which the renderingStepToAdd will be added</param>
            <param name="renderingStepToAdd">rendering step that will be added before the existingRenderingStep</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.Add(Ab3d.DirectX.RenderingStepBase[])">
            <summary>
            Adds multiple rendering steps after the last rendering step
            </summary>
            <param name="renderingStepsToAdd">rendering steps to add</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.AddAfter(Ab3d.DirectX.RenderingStepBase,Ab3d.DirectX.RenderingStepBase[])">
            <summary>
            Adds multiple rendering steps after the specified rendering step (existingRenderingStep)
            </summary>
            <param name="existingRenderingStep">rendering step after which the renderingStepToAdd will be added</param>
            <param name="renderingStepsToAdd">rendering steps that will be added after the existingRenderingStep</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.AddBefore(Ab3d.DirectX.RenderingStepBase,Ab3d.DirectX.RenderingStepBase[])">
            <summary>
            Adds multiple rendering steps before the specified rendering step (existingRenderingStep)
            </summary>
            <param name="existingRenderingStep">rendering step before which the renderingStepToAdd will be added</param>
            <param name="renderingStepsToAdd">rendering steps that will be added before the existingRenderingStep</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.Clear">
            <summary>
            Removes all rendering steps
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.Contains(Ab3d.DirectX.RenderingStepBase)">
            <summary>
            Returns true if the specified rendering step exist in this RenderingStepList. 
            </summary>
            <param name="renderingStep">rendering step</param>
            <returns>true if the specified rendering step exist in this RenderingStepList</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.Remove(Ab3d.DirectX.RenderingStepBase)">
            <summary>
            Removes the specified rendering step from this list
            </summary>
            <param name="renderingStep">rendering step to remove</param>
            <returns>true if rendering step was removed; false if rendering step did not exist in this list</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.RemoveFirst">
            <summary>
            Removes the rendering list that is the first in this list
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.RemoveLast">
            <summary>
            Removes the rendering list that is the last in this list
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.CopyTo(Ab3d.DirectX.RenderingStepBase[],System.Int32)">
            <summary>
            Copies all rendering steps from this list into the specified array.
            The array must be preallocated to the number of elements in this list.
            </summary>
            <param name="renderingStepsArray">rendering steps array whose items will be set with rendering steps from this list</param>
            <param name="index">start index in the target array</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.FindFirst(System.String,System.Boolean)">
            <summary>
            Returns the first RenderingStep with the specified specified name. If the RenderingStep is not found, then null is returned.
            </summary>
            <param name="renderingStepName">name of the rendering step to find.</param>
            <param name="searchInChildRenderingSteps">if true the method will also search in each child rendering step in the RenderingStepsGroup. Default value is false</param>
            <returns>first RenderingStep with the specified specified name</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.FindFirst``1(System.Boolean)">
            <summary>
            Returns the first RenderingStep of the specified T type. If the RenderingStep is not found, then null is returned.
            </summary>
            <param name="searchInChildRenderingSteps">if true the method will also search in each child rendering step in the RenderingStepsGroup. Default value is false</param>
            <typeparam name="T">type of RenderingStep</typeparam>
            <returns>first RenderingStep of the specified T type</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.FindFirst``1(System.String,System.Boolean)">
            <summary>
            Returns the first RenderingStep of the specified T type and specified name. If the RenderingStep is not found, then null is returned.
            </summary>
            <param name="renderingStepName">name of the rendering step to find (null if name is not important).</param>
            <param name="searchInChildRenderingSteps">if true the method will also search in each child rendering step in the RenderingStepsGroup. Default value is false</param>
            <typeparam name="T">type of RenderingStep</typeparam>
            <returns>first RenderingStep of the specified T type</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.FindLast(System.String,System.Boolean)">
            <summary>
            Returns the last RenderingStep with the specified specified name. If the RenderingStep is not found, then null is returned.
            </summary>
            <param name="renderingStepName">name of the rendering step to find.</param>
            <param name="searchInChildRenderingSteps">if true the method will also search in each child rendering step in the RenderingStepsGroup. Default value is false</param>
            <returns>last RenderingStep with the specified specified name</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.FindLast``1(System.Boolean)">
            <summary>
            Returns the last RenderingStep of the specified T type. If the RenderingStep is not found, then null is returned.
            </summary>
            <param name="searchInChildRenderingSteps">if true the method will also search in each child rendering step in the RenderingStepsGroup. Default value is false</param>
            <typeparam name="T">type of RenderingStep</typeparam>
            <returns>last RenderingStep of the specified T type</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.FindLast``1(System.String,System.Boolean)">
            <summary>
            Returns the last RenderingStep of the specified T type and specified name. If the RenderingStep is not found, then null is returned.
            </summary>
            <param name="renderingStepName">name of the rendering step to find (null if name is not important).</param>
            <param name="searchInChildRenderingSteps">if true the method will also search in each child rendering step in the RenderingStepsGroup. Default value is false</param>
            <typeparam name="T">type of RenderingStep</typeparam>
            <returns>last RenderingStep of the specified T type</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.ForEach(System.Action{Ab3d.DirectX.RenderingStepBase},System.Boolean)">
            <summary>
            ForEach executes the action for each rendering step and passes the rendering step as an argument to the action.
            </summary>
            <param name="action">Action that will be executed for each rendering step</param>
            <param name="executeInChildRenderingSteps">if true the action will be also executed for each child rendering step in the RenderingStepsGroup. Default value is false</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Ab3d.DirectX.RenderingStepsList.Enumerator">
            <summary>
            Enumerator for enumerating RenderingStepBase
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderingStepsList.Enumerator.Current">
            <summary>
            Current
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.Enumerator.MoveNext">
            <summary>
            Move next
            </summary>
            <returns>true if next item exist</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsList.Enumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Ab3d.DirectX.RenderingStepsLoop">
            <summary>
            RenderingStepsLoop can be used to create loops in RenderingsSteps list.
            The loop is created with specifiying the beginLoopRenderingStep that is the first RenderingStep in the loop.
            The beginLoopRenderingStep is executed when the loopPredicate returns true. 
            When the loopPredicate returns false, the execution will continue on the rendering step after this RenderingStepsLoop.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsLoop.#ctor(System.String,Ab3d.DirectX.RenderingStepBase,System.Predicate{Ab3d.DirectX.RenderingContext},System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name</param>
            <param name="beginLoopRenderingStep">RenderingStep that will be the executed when the loopPredicate condition is true</param>
            <param name="loopPredicate">Predicate that returns true when the loop should continue with executing beginLoopRenderingStep; false result will continue execution on the rendering step after this RenderingStepsLoop</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsLoop.GetNextExecutedRenderingStep">
            <summary>
            Returns the RenderingStepBase that will be executed after this rendering step.
            This method is called after the OnRun method is called.
            </summary>
            <returns>RenderingStepBase that will be executed after this rendering step</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsLoop.OnLoaded">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsLoop.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderingStepsLoop.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Ab3d.DirectX.RenderObjectsRenderingStep">
            <summary>
            RenderObjects renders the objects
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderObjectsRenderingStep.MinObjectsPerThread">
            <summary>
            MinObjectsPerThread is a static integer value that specifies minimum number of objects that are required to create a new thread.
            For example if multi-threading is enabled and there are 320 objects to render and MinObjectsPerThread is set to 100 (by default),
            then 3 threads will be created to render all the objects (if not limited by number of actual processors or <see cref="P:Ab3d.DirectX.DXScene.MaxBackgroundThreadsCount" />).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderObjectsRenderingStep.MinObjectsForCachedCommandLists">
            <summary>
            MinObjectsForCachedCommandLists is a static integer value that specifies minimum number of objects that are required to
            start using cached command lists (when enabled with <see cref="P:Ab3d.DirectX.DXScene.IsCachingCommandLists" /> from DXScene).
            Default value is 400.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderObjectsRenderingStep.MainThreadWaitTimeoutMs">
            <summary>
            MainThreadWaitTimeoutMs specifies a timeout that is used in main thread to wait for all background threads to finish preparing command lists.
            Note that the UI thread is also executing the same task (preparing rendering or preparing the command list)
            so theoretically it should take the same amount of time on UI and background threads and therefore the default value of 2 seconds should be more then enough.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderObjectsRenderingStep.IsCachingCommandLists">
            <summary>
            Gets or sets a boolean that specifies if this instance of RenderObjectsRenderingStep can cache command lists (record then in one frame and reuse the command lists in the following frames).
            By default this value is set to true, but to use command lists then also the <see cref="P:Ab3d.DirectX.DXScene.IsCachingCommandLists" /> from DXScene must be set to true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderObjectsRenderingStep.AllowMultipassRendering">
            <summary>
            Gets or sets a boolean that specifies if multipass rendering is used when number of light is bigger than
            the number of lights that can be rendered in one rendering pass. Default value is true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderObjectsRenderingStep.OverrideEffect">
            <summary>
            When OverrideEffect is set, than it renders all objects with this effect; else the effect defined by the object's material is used
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderObjectsRenderingStep.OverrideStandardEffect">
            <summary>
            When OverrideStandardEffect is set, than the materials that does not have any specific effect specified will be rendered with it renders all objects with OverrideStandardEffect; otherwise the DXDevice.EffectsManager.GetStandardEffect() method will be used to get the standard effect.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderObjectsRenderingStep.OverrideBlendState">
            <summary>
            When OverrideBlendState is set, the specified BlendState will be used to render all the objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderObjectsRenderingStep.OverrideDepthStencilState">
            <summary>
            When OverrideDepthStencilState is set, the specified DepthStencilState will be used to render all the objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderObjectsRenderingStep.OverrideRasterizerState">
            <summary>
            When OverrideRasterizerState is set, the specified RasterizerState will be used to render all the objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderObjectsRenderingStep.FilterRenderingQueuesFunction">
            <summary>
            Gets or sets a filter function that can be used to filter RenderingQueue that will be rendered (returning false for RenderingQueue that are not rendered).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderObjectsRenderingStep.FilterObjectsFunction">
            <summary>
            Gets or sets a filter function that can be used to filter the objects that will be rendered (returning false for object that are not rendered).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderObjectsRenderingStep.FilterLightsFunction">
            <summary>
            Gets or sets a filter function that can be used to filter lights used by this RenderObjectsRenderingStep - the function should return a List{ILight}
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderObjectsRenderingStep.UseMultiThreading">
            <summary>
            Gets or sets a nullable Boolean that specifies if rendering objects in this rendering step can be done in multiple threads (when also enabled by <see cref="P:Ab3d.DirectX.DXScene.MaxBackgroundThreadsCount" />).
            Default value is true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderObjectsRenderingStep.BackgroundThreadsManager">
            <summary>
            Gets or sets a BackgroundThreadsManager that is used by this RenderObjectsRenderingStep.
            If this value is not manually set by the user, then it is set from the <see cref="P:Ab3d.DirectX.DXScene.BackgroundThreadsManager" /> or <see cref="P:Ab3d.DirectX.DXDevice.BackgroundThreadsManager" />.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderObjectsRenderingStep.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderObjectsRenderingStep" /> class.
            </summary>
            <param name="name">name</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderObjectsRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderObjectsRenderingStep.SaveExecutionTimeStatistics(System.Double,Ab3d.DirectX.RenderingStatistics)">
            <summary>
            SaveExecutionTimeStatistics is called when we are collecting statistics.
            The implementation of the method should save or add the elapsedMilliseconds to the corresponding property in the RenderingStatistics class.
            </summary>
            <param name="stepExecutionTimeInMilliseconds">time in milliseconds to execute this rendering step</param>
            <param name="renderingStatistics">RenderingStatistics</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderObjectsRenderingStep.ToString">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.RenderObjectsRenderingStep.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.RenderPostProcessingRenderingStep">
            <summary>
            RenderPostProcessing renders the post processing effects.
            </summary>
            <remarks>
                <para>
                    <b>RenderPostProcessing</b> renders the post processing effects that are defined in the <see cref="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.PostProcesses" /> list.
            </para>
                <para>
            Before using the RenderPostProcessingRenderingStep, the PostProcesses list must be set to the list of post processes.
            Also the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForSinglePostProcess(SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> or the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> method must be called to set the resources required to run the post processes.
            </para>
                <para>
            The PostProcesses list and the resources are usually automatically set in the <see cref="T:Ab3d.DirectX.PreparePostProcessingRenderingStep" /> that sets the resources based on the <see cref="P:Ab3d.DirectX.DXScene.PostProcesses" /> list on the <see cref="T:Ab3d.DirectX.DXScene" /> object.
            </para>
                <para>
            The RenderPostProcessingRenderingStep can be also used without <see cref="T:Ab3d.DirectX.PreparePostProcessingRenderingStep" />. In this case the resources must be manually set.
            </para>
                <para>
            When rendering <b>only one post process</b>, the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForSinglePostProcess(SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> can be called.
            This method requires only sourceShaderResourceView, destinationBackBuffer, destinationBackBufferDescription and destinationRenderTargetView.
            In this case the sourceShaderResourceView is rendered directly to the destinationBackBuffer.
            </para>
                <para>
            When having <b>more than one post process</b> the RenderPostProcessingRenderingStep much more resources that must be initialized with <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> method.
            This method can be also used for only one post process.
            </para>
                <para>
            The first post process will use <see cref="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.SourceShaderResourceView" /> and will render to <see cref="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.AdditionalRenderTargetView" /> (from source buffer to additional buffer).
            Than <see cref="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.AdditionalShaderResourceView" /> will be used as source and the next post process will render to <see cref="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.SourceRenderTargetView" /> (from additional buffer to source buffer).
            Than the source and destination will change after each post process. Except last post process that is always rendered to <see cref="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.DestinationRenderTargetView" />.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.SourceBackBuffer">
            <summary>
            Gets a source BackBuffer.
            This value can be set with the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.SourceBackBufferDescription">
            <summary>
            Gets a Description of the sourceBackBuffer.
            This value can be set with the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.SourceRenderTargetView">
            <summary>
            Gets a RenderTargetView for the SourceBackBuffer.
            This value can be set with the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.SourceShaderResourceView">
            <summary>
            Gets a ShaderResourceView for the SourceBackBuffer.
            This value can be set with the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForSinglePostProcess(SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> or <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> methods.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.AdditionalBackBuffer">
            <summary>
            Gets an additional BackBuffer that is used when more than one post process is rendered.
            This value can be set with the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.AdditionalBackBufferDescription">
            <summary>
            Gets a Description of the AdditionalBackBuffer.
            This value can be set with the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.AdditionalRenderTargetView">
            <summary>
            Gets a RenderTargetView for the AdditionalBackBuffer.
            This value can be set with the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.AdditionalShaderResourceView">
            <summary>
            Gets a ShaderResourceView for the AdditionalBackBuffer.
            This value can be set with the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.DestinationBackBuffer">
            <summary>
            Gets a destination BackBuffer.
            This value can be set with the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForSinglePostProcess(SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> or <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> methods.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.DestinationBackBufferDescription">
            <summary>
            Gets a Description of the DestinationBackBuffer.
            This value can be set with the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForSinglePostProcess(SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> or <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> methods.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.DestinationRenderTargetView">
            <summary>
            Gets a RenderTargetView for the DestinationBackBuffer.
            This value can be set with the <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForSinglePostProcess(SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> or <see cref="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)" /> methods.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.SuperSamplingCount">
            <summary>
            Gets the super-sampling count of the buffers used for processing steps.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.PostProcesses">
            <summary>
            Gets or sets the post processes that will be rendered by this RenderPostProcessingRenderingStep.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderPostProcessingRenderingStep.RestoreOriginalRenderTargets">
            <summary>
            When true the render targets that were used before starting post processes are restored (this may require additional copying of back buffers).
            When false (by default) then new render targets (without MSAA) and bound without depth stencil buffer may be set after post processes are executed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderPostProcessingRenderingStep" /> class.
            </summary>
            <param name="name">The name.</param>
            <param name="description">The description.</param>
            <exception cref="T:System.ArgumentNullException">postProcesses</exception>
        </member>
        <member name="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.#ctor(System.String,System.Collections.Generic.IList{Ab3d.DirectX.PostProcessing.PostProcessBase},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.RenderPostProcessingRenderingStep" /> class.
            </summary>
            <param name="name">The name.</param>
            <param name="postProcesses">IList of post processes</param>
            <param name="description">The description.</param>
            <exception cref="T:System.ArgumentNullException">postProcesses</exception>
        </member>
        <member name="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForSinglePostProcess(SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)">
            <summary>
            Initializes resources for rendering one PostProcess.
            Rendering one post process required much less resources then rendering multiple post processes.
            </summary>
            <param name="sourceShaderResourceView">ShaderResourceView of the source Texture2D</param>
            <param name="destinationBackBuffer">destination BackBuffer as Texture2D</param>
            <param name="destinationBackBufferDescription">description of destinationBackBuffer</param>
            <param name="destinationRenderTargetView">RenderTargetView of the destinationBackBuffer</param>
            <param name="superSamplingCount">super-sampling count of the destination buffer</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.InitializeResourcesForMultiplePostProcesses(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.ShaderResourceView,SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,System.Int32)">
            <summary>
            Initializes resources for rendering multiple PostProcesses.
            To render multiple post processes we need additional BackBuffer that is used as intermediate buffer.
            </summary>
            <param name="sourceBackBuffer">source BackBuffer as Texture2D</param>
            <param name="sourceBackBufferDescription">description of sourceBackBuffer</param>
            <param name="sourceRenderTargetView">RenderTargetView of the sourceBackBuffer</param>
            <param name="sourceShaderResourceView">ShaderResourceView of the sourceBackBuffer</param>
            <param name="additionalBackBuffer">additional BackBuffer as Texture2D</param>
            <param name="additionalBackBufferDescription">description of additionalBackBuffer</param>
            <param name="additionalRenderTargetView">RenderTargetView of the additionalBackBuffer</param>
            <param name="additionalShaderResourceView">ShaderResourceView of the additionalBackBuffer</param>
            <param name="destinationBackBuffer">destination BackBuffer as Texture2D</param>
            <param name="destinationBackBufferDescription">description of destinationBackBuffer</param>
            <param name="destinationRenderTargetView">RenderTargetView of the destinationBackBuffer</param>
            <param name="superSamplingCount">super-sampling count of the buffers</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.ClearBackBuffers">
            <summary>
            Clears all set back buffers
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.OnInitializeResources(Ab3d.DirectX.DXScene)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.SaveExecutionTimeStatistics(System.Double,Ab3d.DirectX.RenderingStatistics)">
            <summary>
            SaveExecutionTimeStatistics is called when we are collecting statistics.
            The implementation of the method should save or add the elapsedMilliseconds to the corresponding property in the RenderingStatistics class.
            </summary>
            <param name="stepExecutionTimeInMilliseconds">time in milliseconds to execute this rendering step</param>
            <param name="renderingStatistics">RenderingStatistics</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderPostProcessingRenderingStep.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.RenderTextureRenderingStep">
            <summary>
            RenderTextureRenderingStep is a rendering step that can render the specified <see cref="P:Ab3d.DirectX.RenderTextureRenderingStep.SourceTexture" /> (as ShaderResourceView)
            to a part of the screen specified with the <see cref="P:Ab3d.DirectX.RenderTextureRenderingStep.TargetViewport" />.
            Rendering of the colors can be adjusted with setting the <see cref="P:Ab3d.DirectX.RenderTextureRenderingStep.Offsets" /> and <see cref="P:Ab3d.DirectX.RenderTextureRenderingStep.Factors" />.
            It is also possible to specify a <see cref="P:Ab3d.DirectX.RenderTextureRenderingStep.CustomBlendState" /> and <see cref="P:Ab3d.DirectX.RenderTextureRenderingStep.CustomDepthStencilState" />.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.RenderTextureRenderingStep.TextureChannelsCount">
            <summary>
            TextureChannelsCount enum defines how many channels (colors) will be rendered with the RenderTextureRenderingStep.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderTextureRenderingStep.TextureChannelsCount.Undefined">
            <summary>
            Undefined
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderTextureRenderingStep.TextureChannelsCount.OneChannel">
            <summary>
            Only red channel will be read from the source texture
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderTextureRenderingStep.TextureChannelsCount.TwoChannels">
            <summary>
            Only red and green channels will be read from the source texture
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderTextureRenderingStep.TextureChannelsCount.ThreeChannels">
            <summary>
            Only red, green and blue channels will be read from the source texture
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderTextureRenderingStep.TextureChannelsCount.FourChannels">
            <summary>
            All four channels (red, green, blue and alpha) will be read from the source texture
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderTextureRenderingStep.SourceTexture">
            <summary>
            Gets or sets a ShaderResourceView that will be rendered with this rendering step.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderTextureRenderingStep.Offsets">
            <summary>
            Gets or sets a Vector4 that specifies RGBA values that are added to each color displayed with this post process. Default value is (0, 0, 0, 1)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderTextureRenderingStep.Factors">
            <summary>
            Gets or sets a Vector4 that specifies RGBA values that are multiplied with each color displayed with this post process. Default value is (1, 1, 1, 0)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderTextureRenderingStep.CustomDepthStencilState">
            <summary>
            Gets or sets a DepthStencilState that is used to render the texture. When null (by default) the <see cref="P:Ab3d.DirectX.CommonStates.DepthNone" /> is used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderTextureRenderingStep.CustomBlendState">
            <summary>
            Gets or sets a CustomBlendState that is used to render the texture. When null (by default) the <see cref="P:Ab3d.DirectX.CommonStates.Opaque" /> is used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.RenderTextureRenderingStep.TargetViewport">
            <summary>
            Gets or sets a part of the screen that will be affected by this PostProcess.
            The coordinates are defined in NDC space (Normalized Device Coordinates) that means that the full screen post process will be defined as (0, 0, 1, 1); upper left quarter is (0, 0, 0.5f, 0.5f).
            The default value is (0, 0, 1, 1).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderTextureRenderingStep.#ctor(Ab3d.DirectX.RenderTextureRenderingStep.TextureChannelsCount,System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="textureChannelsCount">how many channels (colors) will be rendered with the RenderTextureRenderingStep</param>
            <param name="name">optional rendering step name</param>
            <param name="description">optional description</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderTextureRenderingStep.#ctor(SharpDX.Direct3D11.ShaderResourceView,System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="sourceTexture">ShaderResourceView that will be rendered with this rendering step</param>
            <param name="name">optional rendering step name</param>
            <param name="description">optional description</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderTextureRenderingStep.#ctor(SharpDX.Direct3D11.ShaderResourceView,SharpDX.DXGI.Format,System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="sourceTexture">ShaderResourceView that will be rendered with this rendering step</param>
            <param name="sourceTextureFormat">Format of the texture to render</param>
            <param name="name">optional rendering step name</param>
            <param name="description">optional description</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderTextureRenderingStep.#ctor(SharpDX.Direct3D11.ShaderResourceView,Ab3d.DirectX.RenderTextureRenderingStep.TextureChannelsCount,System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="sourceTexture">ShaderResourceView that will be rendered with this rendering step</param>
            <param name="textureChannelsCount">how many channels (colors) will be rendered with the RenderTextureRenderingStep</param>
            <param name="name">optional rendering step name</param>
            <param name="description">optional description</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderTextureRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderTextureRenderingStep.RenderTexture(Ab3d.DirectX.RenderingContext,SharpDX.Direct3D11.ShaderResourceView,SharpDX.ViewportF)">
            <summary>
            RenderTexture static method rendered the specified sourceShaderResourceView to the viewport and on the current render targets in the renderingContext.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="sourceShaderResourceView">ShaderResourceView that will be rendered</param>
            <param name="viewport">the target position where the texture will be rendered (in NDC space - (0, 0, 1, 1) represents the whole scree)</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderTextureRenderingStep.RenderTexture(Ab3d.DirectX.RenderingContext,SharpDX.Direct3D11.ShaderResourceView,SharpDX.ViewportF,SharpDX.Vector4,SharpDX.Vector4,SharpDX.Direct3D11.BlendState,SharpDX.Direct3D11.DepthStencilState)">
            <summary>
            RenderTexture static method rendered the specified sourceShaderResourceView to the viewport and on the current render targets in the renderingContext.
            This method also allows changing the colors in the source texture with using offsets and factors parameters.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <param name="sourceShaderResourceView">ShaderResourceView that will be rendered</param>
            <param name="viewport">the target position where the texture will be rendered (in NDC space - (0, 0, 1, 1) represents the whole scree)</param>
            <param name="offsets">specifies RGBA values that are added to each color displayed with this post process</param>
            <param name="factors">specifies RGBA values that are multiplied with each color</param>
            <param name="customBlendState">when set (not null) it provides a BlendState that is used to render a texture</param>
            <param name="customDepthStencilState">when set (not null) it provides a DepthStencilState that is used to render a texture</param>
        </member>
        <member name="M:Ab3d.DirectX.RenderTextureRenderingStep.GetTextureChannelsCount(SharpDX.Direct3D11.ShaderResourceView,System.Boolean)">
            <summary>
            GetTextureChannelsCount returns number of channels (colors) that are used by the specified sourceTexture.
            </summary>
            <param name="sourceTexture">sourceTexture as ShaderResourceView</param>
            <param name="throwException">true when an exception is throw when the number of channels cannot be determined</param>
            <returns>number of channels (colors) that are used by the specified sourceTexture</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderTextureRenderingStep.ConvertFormatToTextureChannelsCount(SharpDX.DXGI.Format)">
            <summary>
            ConvertFormatToTextureChannelsCount gets the number of channels (colors) from the specified texture format.
            </summary>
            <param name="textureFormat">textureFormat</param>
            <returns>the number of channels (colors)</returns>
        </member>
        <member name="M:Ab3d.DirectX.RenderTextureRenderingStep.Dispose(System.Boolean)">
            <summary>
            Dispose any resources that are created in RenderingStep.
            </summary>
            <param name="isDisposing">isDisposing</param>
        </member>
        <member name="T:Ab3d.DirectX.ResolveBackBufferRenderingStep">
            <summary>
            ResolveBackBufferRenderingStep resolves the multi-sampled back buffer (MSAA) and down-samples the super-samples back buffer (SSAA) into a back buffer without multi-sampling.
            The source buffer is get from the renderingContext.CurrentBackBuffer.
            The destination buffer can be customized by calling <see cref="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.SetCustomDestinationBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)" />.
            When this method is not called, then the renderingContext.FinalBackBuffer is used for destination buffer.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ResolveBackBufferRenderingStep.ResolveMultisampledBackBuffer">
            <summary>
            Gets or sets a Boolean that specifies if this ResolveBackBufferRenderingStep resolves a multi-sampled back buffer (when multi-sampling is used). Default value is true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ResolveBackBufferRenderingStep.ResolveSuperSampledBackBuffer">
            <summary>
            Gets or sets a Boolean that specifies if this ResolveBackBufferRenderingStep resolves a super-sampled back buffer (when super-sampling is used). Default value is true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ResolveBackBufferRenderingStep.DestinationBuffer">
            <summary>
            Gets a Buffer (Texture2D) that will get the down-sampled buffer. 
            If null, then renderingContext.FinalBackBuffer is used for destination buffer.
            This property is set by the <see cref="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.SetCustomDestinationBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ResolveBackBufferRenderingStep.DestinationBufferDescription">
            <summary>
            Gets the Texture2DDescription for the <see cref="P:Ab3d.DirectX.ResolveBackBufferRenderingStep.DestinationBuffer" />. 
            This property is set by the <see cref="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.SetCustomDestinationBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ResolveBackBufferRenderingStep.DestinationRenderTargetView">
            <summary>
            Gets the RenderTargetView for the <see cref="P:Ab3d.DirectX.ResolveBackBufferRenderingStep.DestinationBuffer" />. 
            This property is set by the <see cref="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.SetCustomDestinationBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ResolveBackBufferRenderingStep.ResolveFilter">
            <summary>
            Gets or sets the type of down-sampling filter that is used when resolving the super-sampled texture. Default value is <see cref="F:Ab3d.DirectX.SupersamplingResolveFilterType.RotatedFilterSize5" />.
            Using a filter results in generally smoother at the cost of a blurrier final result.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ResolveBackBufferRenderingStep.CenterPixelWeight">
            <summary>
            Gets or sets weight from 0 to 1 of the center pixel. Bigger values means that center pixel will get more weight in the final pixel. Default value is 0.28.
            This value is used only when <see cref="P:Ab3d.DirectX.ResolveBackBufferRenderingStep.ResolveFilter" /> is not None;
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ResolveBackBufferRenderingStep.TexelOffsetsScale">
            <summary>
            Multiplies the texel offset by this factor. It is used to downsample from bigger textures so that offsets reach bigger area.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.ResolveBackBufferRenderingStep" /> class.
            </summary>
            <param name="name">name</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.SetCustomDestinationBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)">
            <summary>
            Sets custom destination buffer that will get the down-sampled texture.
            </summary>
            <param name="destinationBuffer">destinationBuffer</param>
            <param name="destinationBufferDescription">Texture2DDescription for the destinationBuffer</param>
            <param name="destinationRenderTargetView">destination RenderTargetView</param>
        </member>
        <member name="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.ClearCustomDestinationBuffer">
            <summary>
            Clears the custom destination buffer. RenderingContext.FinalBackBuffer will be used as destination buffer.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.SaveExecutionTimeStatistics(System.Double,Ab3d.DirectX.RenderingStatistics)">
            <summary>
            SaveExecutionTimeStatistics is called when we are collecting statistics.
            The implementation of the method should save or add the elapsedMilliseconds to the corresponding property in the RenderingStatistics class.
            </summary>
            <param name="stepExecutionTimeInMilliseconds">time in milliseconds to execute this rendering step</param>
            <param name="renderingStatistics">RenderingStatistics</param>
        </member>
        <member name="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.CustomRenderableNode">
            <summary>
            CustomRenderableNode is a SceneNode that can be used to fully customize the rendering process.
            This can be done with creating the CustomRenderableNode object with a Func that create a custom RenderablePrimitiveBase object that is then added to the rendering queue.
            The CustomRenderableNode object can be also created with a custom Action that is called when this SceneNode needs to be rendered (this creates <see cref="T:Ab3d.DirectX.CustomRenderablePrimitive" /> object and adds it to the rendering queue).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.CustomRenderableNode.OriginalObject">
            <summary>
            OriginalObject that was used to create this CustomRenderablePrimitive (can be null).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CustomRenderableNode.InitializeResourcesAction">
            <summary>
            Gets or sets an Action that is called when DXEngine's resources that are used by this CustomRenderableNode need to be created.
            The Action is called with two parameters: this CustomRenderableNode and DXScene
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CustomRenderableNode.UpdateAction">
            <summary>
            Gets or sets an Action that is called when the Update method is called on this SceneNode. The action is called with this CustomRenderableNode as parameter.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderableNode.#ctor(System.Action{Ab3d.DirectX.RenderingContext,Ab3d.DirectX.CustomRenderableNode,System.Object},Ab3d.DirectX.Bounds,System.Object,Ab3d.DirectX.Material)">
            <summary>
            Constructor that takes custom Action as parameter. The action is called to provide custom rendering logic.
            </summary>
            <param name="renderAction">Action takes RenderingContext and object and is called when this object needs to be rendered</param>
            <param name="bounds">Bounding box of the 3D object (without applied transformation from Transform property)</param>
            <param name="originalObject">Optional object that is set to the <see cref="F:Ab3d.DirectX.CustomRenderableNode.OriginalObject" /> field</param>
            <param name="material">material that is used to render this CustomRenderableNode (usually <see cref="T:Ab3d.DirectX.Materials.EffectMaterial" />). Can be null.</param>
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderableNode.#ctor(Ab3d.DirectX.RenderablePrimitiveBase,Ab3d.DirectX.Bounds,System.Object)">
            <summary>
            Constructor that takes custom RenderablePrimitiveBase as parameter.
            </summary>
            <param name="renderablePrimitive">RenderablePrimitiveBase object that is added to the rendering queue and provides logic to render this SceneNode</param>
            <param name="bounds">Bounding box of the 3D object (without applied transformation from Transform property)</param>
            <param name="originalObject">Optional object that is send as parameter to the renderAction (null by default)</param>
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderableNode.OnInitializeResources(Ab3d.DirectX.DXScene)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderableNode.Update">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderableNode.OnWorldMatrixChanged">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderableNode.UpdateBounds(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderableNode.CollectRenderableObjects">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.CustomRenderableNode.OnIsVisibleChanged(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.DXScene">
            <summary>
            DXScene is the main object in the DXEngine rendering engine. 
            It defines the 3D scene in a hierarchical tree hat starts with the <see cref="P:Ab3d.DirectX.DXScene.RootNode" />. 
            It updates the SceneNodes and renders them.
            </summary>
            <remarks>
                <para>
            DXScene has the following tasks in the DXEngine:<br />
            - it represents a viewport that shows the scene (has a render target, buffers and other DirectX objects that are used to render the scene to)<br />
            - it has the camera<br />
            - it holds the hierarchical tree of the 3d objects<br />
            - it creates lists of used materials and effects<br />
            - it creates list of RenderQueues. Each RenderQueue is filled with IRenderable objects. List of RenderQueues is than passed to DXDevice that renderer the objects to the render targets specified by this DXScene.<br />
            - it can get change notifications from 3d objects and updates the lists of materials, effects, and RenderQueues accordingly. It also triggers rendering when needed.
            </para>
            </remarks>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.Logger">
            <summary>
            Logger is not used in release build and is always null
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.MasterDXScene">
            <summary>
            Gets a DXScene that is set when this DXScene is rendered a 3D scene that is defined in a MasterDXScene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.HardwareAccelerate3DLines">
            <summary>
            Gets or sets a boolean that specifies if rendering 3D lines is hardware accelerated by DXEngine.
            </summary>
            <remarks>
                <para>
                    <b>HardwareAccelerate3DLines</b> gets or sets a boolean that specifies if rendering 3D lines is hardware accelerated by DXEngine.
            Default value is true.
            </para>
                <para>
            When set to false, then 3D lines are rendered by Ab3d.PowerToys or by some other custom engine.
            </para>
                <para>
            NOTE:<br />
            When setting HardwareAccelerate3DLines to false, this must be done before the 3D objects are initialized
            (after the DXScene was created; when using DXSceneView it is recommended to change the value of this property in DXSceneDeviceCreated event handler).
            The following examples shows how to do that when using DXViewportView (named MainDXViewportView):
            </para>
                <example>
                    <code>
            MainDXViewportView.DXSceneDeviceCreated += delegate(object sender, EventArgs args)
            {
                // Called after DXScene and DXDevice were initialized and before SceneNodes are created
                if (MainDXViewportView.DXScene != null) // DXScene can be null in case of WPF rendering
                    MainDXViewportView.DXScene.HardwareAccelerate3DLines = false;
            };
            </code>
                </example>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.RenderConnectedLinesAsDisconnected">
            <summary>
            Gets or sets a boolean that specifies if all connected 3D lines (polylines, line arc, rectangle, etc.) are rendered as disconnected 3D lines (separate lines).
            Default value is false.
            </summary>
            <remarks>
                <para>
                    <b>RenderConnectedLinesAsDisconnected</b> gets or sets a boolean that specifies if all connected 3D lines (polylines, line arc, rectangle, etc.) are rendered as disconnected 3D lines (separate lines).
            Default value is false.
            </para>
                <para>
            Connected 3D lines are 3D lines where the end point of one line is the start point of the next line and where the connection between the lines is "smoothed".
            In Ab3d.PowerToys library the connected 3D lines are created with the following objects: PolyLineVisual3D, LineArcVisual3D, RectangleVisual3D, MultiPolyLineVisual3D, TextVisual3D, LineWithTextVisual3D, CenteredTextVisual3D.
            </para>
                <para>
            Disconnected 3D lines are simple 3D lines are not connected to each other. 
            In Ab3d.PowerToys library the connected 3D lines are created with the following objects: LineVisual3D, MultiLineVisual3D, WireBoxVisual3D, WireCrossVisual3D, WireGridVisual3D, WireframeVisual3D.
            </para>
                <para>
            This property was used before DXEngine v2.3 where connected 3D lines were not hardware accelerated and with using this property connected lines can be rendered as disconnected and hardware accelerated.
            From this version on, the DXEngine supports full hardware rendering of connected 3D lines and therefore this property can be used only to achieve some special effects.
            </para>
                <para>
            NOTE:<br />
            RenderConnectedLinesAsDisconnected property
            must be set before the 3D lines are initialized and after the DXScene object is created and.
            This can be done in the DXSceneDeviceCreated event (here the DXScene and DXDevice are already created).
            </para>
                <example>
                    <code>
            MainDXViewportView.DXSceneDeviceCreated += delegate(object sender, EventArgs args)
            {
               if (DXViewportView1.DXScene != null) // DXScene is null in case of WPF 3D rendering
               {
                   // Here the values are set to the default values - you can change them if you want.
                   DXViewportView1.DXScene.RenderConnectedLinesAsDisconnected = false;
               }
            };
            </code>
                </example>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.RenderConnectedLinesAsDisconnectedLinesThicknessLimit">
            <summary>
            Gets or sets the LineThickness value that will limit rendering connected 3D lines (polylines, line arc, rectangle, etc.),  as disconnected 3D lines (fully hardware accelerated).
            The connected 3D lines that have lower or equal LineThickness then the value of this property will be rendered as disconnected 3D line; 
            other connected lines will still be generated on the CPU by Ab3d.PowerToys library. Default value is 3.
            </summary>
            <remarks>
                <para>
                    <b>RenderConnectedLinesAsDisconnectedLinesThicknessLimit</b> gets or sets the LineThickness value that will limit rendering connected 3D lines (polylines, line arc, rectangle, etc.),  as disconnected 3D lines (fully hardware accelerated).
            </para>
                <para>
            RenderConnectedLinesAsDisconnectedLinesThicknessLimit is not used when <see cref="P:Ab3d.DirectX.DXScene.RenderConnectedLinesAsDisconnected" /> is set to true.
            </para>
                <para>
            Default value is 3 which means that if connected line has LineThickness less or equal to 3, it will be rendered as disconnected 3D line.
            </para>
                <para>
            Connected 3D lines are 3D lines where the end point of one line is the start point of the next line and where the connection between the lines is "smoothed".
            In Ab3d.PowerToys library the connected 3D lines are created with the following objects: PolyLineVisual3D, LineArcVisual3D, RectangleVisual3D, MultiPolyLineVisual3D, TextVisual3D, LineWithTextVisual3D, CenteredTextVisual3D.
            </para>
                <para>
            Disconnected 3D lines are simple 3D lines are not connected to each other. 
            In Ab3d.PowerToys library the connected 3D lines are created with the following objects: LineVisual3D, MultiLineVisual3D, WireBoxVisual3D, WireCrossVisual3D, WireGridVisual3D, WireframeVisual3D.
            </para>
                <para>
            One simple 3D line can be rendered with rendering a rectangle where rectangle's height would be set to LineThickness and its length to line length.
            A rectangle can be rendered on the graphics card with creating two triangles. This can be easily done on the graphics card in the geometry shader.
            </para>
                <para>
            But when connected lines are rendered, this also require to render additional triangle that will smooth the line connections and fill the gap between the lines.
            This is a moch more complicated operation and is not done on the graphics card. Therefore the MeshGeometry3D for connected lines needs to be prepared on the CPU.
            </para>
                <para>
            Because the connection triangle that is rendered between two connected lines is hardly visible when LineThickness is less or equal to 3,
            the DXEngine by default renders all connected lines with LineThickness is less or equal to 3 as disconnected lines.
            This value can be adjusted by changing the <see cref="P:Ab3d.DirectX.DXScene.RenderConnectedLinesAsDisconnectedLinesThicknessLimit" /> value.
            Also, setting the <see cref="P:Ab3d.DirectX.DXScene.RenderConnectedLinesAsDisconnected" /> property to true will render all connected lines as disconnected.
            </para>
                <para>
            Note that lines with arrows are never rendered with full hardware accelerated DXEngine.
            </para>
                <para>
            NOTE:<br />
            RenderConnectedLinesAsDisconnectedLinesThicknessLimit and RenderConnectedLinesAsDisconnected properties
            must be set before the 3D lines are initialized and after the DXScene object is created and.
            This can be done in the DXSceneDeviceCreated event (here the DXScene and DXDevice are already created).
            </para>
                <example>
                    <code>
            MainDXViewportView.DXSceneDeviceCreated += delegate(object sender, EventArgs args)
            {
               if (DXViewportView1.DXScene != null) // DXScene is null in case of WPF 3D rendering
               {
                   // Here the values are set to the default values - you can change them if you want.
                   DXViewportView1.DXScene.RenderConnectedLinesAsDisconnected = false;
                   DXViewportView1.DXScene.RenderConnectedLinesAsDisconnectedLinesThicknessLimit = 2;
               }
            };
            </code>
                </example>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.UseGeometryShaderFor3DLines">
            <summary>
            Gets or sets a boolean that specifies if 3D lines are rendered with using GeometryShader that can create thick lines.
            If false, then all 3D lines will be rendered as simple DirectX lines with thickness 1. Default value is true.
            </summary>
            <remarks>
                <para>
                    <b>UseGeometryShaderFor3DLines</b> gets or sets a boolean that specifies if 3D lines are rendered with using GeometryShader that can create thick lines.
            If false, then all 3D lines will be rendered as simple DirectX lines with thickness 1. Default value is true.
            </para>
                <para>
            Setting UseGeometryShaderFor3DLines to false can increase performance when showing many 3D lines.
            </para>
                <para>
            NOTE<br />
            UseGeometryShaderFor3DLines must be set before the 3D objects are initialized
            (after the DXScene was created; when using DXSceneView it is recommended to change the value of this property in DXSceneDeviceCreated event handler).
            The following examples shows how to do that when using DXViewportView (named MainDXViewportView):
            </para>
                <example>
                    <code>
            MainDXViewportView.DXSceneDeviceCreated += delegate(object sender, EventArgs args)
            {
                // Called after DXScene and DXDevice were initialized and before SceneNodes are created
                if (MainDXViewportView.DXScene != null) // DXScene can be null in case of WPF rendering
                    MainDXViewportView.DXScene.UseGeometryShaderFor3DLines = true;
            };
            </code>
                </example>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.RenderAntialiased3DLines">
            <summary>
            When false and <see cref="P:Ab3d.DirectX.DXScene.UseGeometryShaderFor3DLines" /> is also false, the 3D lines are rendered without antialiasing them.
            This greatly improves rendering performance. Default value is true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.IsAutomaticallyUpdatingBeforeEachRender">
            <summary>
            Gets or sets a Boolean that specifies if Update method is automatically called before each rendering of the scene (if it was not yet manually called).
            Default value is true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.VirtualRealityProvider">
            <summary>
            Gets a virtual reality provider that is currently used by this DXScene. This property can be set by calling <see cref="M:Ab3d.DirectX.DXScene.InitializeVirtualRealityRendering(Ab3d.DirectX.VirtualRealityProviderBase)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.ShadowRenderingProvider">
            <summary>
            Gets a ShadowRenderingProvider that is currently used by this DXScene to render shadows. This property can be set by calling <see cref="M:Ab3d.DirectX.DXScene.InitializeShadowRendering(Ab3d.DirectX.ShadowRenderingProviderBase)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.RenderingQueues">
            <summary>
            RenderingQueues is a read only collection of rendering queues that represent queues of low lever objects that are prepared to be rendered with DirectX.
            RenderingQueue are rendered in the same order as in the RenderingQueues list.
            The rendering is done in the <see cref="T:Ab3d.DirectX.RenderObjectsRenderingStep" /> rendering step.
            </summary>
            <remarks>
                <para>
                    <b>RenderingQueues</b> is a read only collection of rendering queues that represent queues of low lever objects that are prepared to be rendered with DirectX.
            </para>
                <para>
            RenderingQueue are rendered in the same order as in the RenderingQueues list. The rendering is done in the <see cref="T:Ab3d.DirectX.RenderObjectsRenderingStep" /> rendering step.
            </para>
                <para>
            NOTE: A new RenderingQueues instance is created each time a new RenderingQueue is added to removed to this collection. So do not store an instance of this collection locally.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.BackgroundRenderingQueue">
            <summary>
            Gets a RenderingQueue that is rendered first. Objects in this queue are not sorted and are rendered in the same order as they are added to the queue.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.ComplexGeometryRenderingQueue">
            <summary>
            Gets a RenderingQueue that contains opaque and very complex 3D objects that are expected to take a lot of GPU time to render and should therefore start rendering as soon as possible.
            Usually this queue contains instanced objects, big point cloud objects or standard objects with many triangles.
            Objects in this queue are not sorted and are rendered in the main thread (no multi-threading rendering) and in the same order as they are added to the queue.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.LineGeometryRenderingQueue">
            <summary>
            Gets a RenderingQueue that contains opaque and single-colored 3D line objects that are rendered with <see cref="T:Ab3d.DirectX.Effects.ThickLineEffect" />.
            Objects in this queue are not sorted but are rendered with using multi-threading.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.OtherGeometryRenderingQueue">
            <summary>
            Gets a RenderingQueue that contains opaque objects that cannot be rendered with <see cref="T:Ab3d.DirectX.Effects.StandardEffect" />.
            Usually this queue contains pixels, objects with physically based rendering material and other objects with non-standard effect (for example vertex colored materials).
            The objects in this queue are not rendered with using multi-threading.
            Objects in this queue are sorted so that they are grouped by material to minimize state changes.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.StandardGeometryRenderingQueue">
            <summary>
            Gets a RenderingQueue that contains standard opaque objects that can be rendered with <see cref="T:Ab3d.DirectX.Effects.StandardEffect" /> (all objects with <see cref="T:Ab3d.DirectX.Materials.StandardMaterial" /> or objects that are created from WPF 3D objects).
            Objects in this queue are sorted so that they are grouped by material to minimize state changes and are also rendered with using multi-threading.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.GeometryRenderingQueue">
            <summary>
            OBSOLETE: GeometryRenderingQueue is obsolete because it was slit into ComplexGeometryRenderingQueue, LineGeometryRenderingQueue, OtherGeometryRenderingQueue and StandardGeometryRenderingQueue. Please add your objects to any of those RenderingQueues. For Backwards compatibility the GeometryRenderingQueue is assigned to the OtherGeometryRenderingQueue.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.ForegroundRenderingQueue">
            <summary>
            Gets a RenderingQueue that is rendered after standard GeometryRenderingQueue but before TransparentRenderingQueue. Objects in this queue are not sorted and are rendered in the same order as they are added to the queue.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.TransparentRenderingQueue">
            <summary>
            Gets a RenderingQueue that contains transparent objects. Objects in this queue are sorted by their distance to the camera - farthest objects are rendered first. 
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.OverlayRenderingQueue">
            <summary>
            Gets a RenderingQueue that is rendered last. Objects in this queue are not sorted and are rendered in the same order as they are added to the queue.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.MeshTriangleIndicesCountRequiredForComplexGeometry">
            <summary>
            TriangleIndicesCountRequiredForComplexGeometry specifies the number of triangles that are required to put the objects rendered with WpfGeometryModel3DNode into the ComplexGeometryRenderingQueue (sending it to GPU as fast as possible) instead of into the StandardGeometryRenderingQueue.
            Default value is 100000.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.LinesCountRequiredForComplexGeometry">
            <summary>
            LinesCountRequiredForComplexGeometry specifies the number of 3D lines that are required to put the objects rendered with ScreenSpaceLineNode into the ComplexGeometryRenderingQueue (sending it to GPU as fast as possible) instead of into the LineGeometryRenderingQueue.
            Default value is 20000.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.RenderingSteps">
            <summary>
            Gets a RenderingStepsList that represents the rendering steps that are executed to render the 3D scene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DefaultInitializeRenderingStep">
            <summary>
            Gets a default <see cref="T:Ab3d.DirectX.InitializeRenderingStep" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DefaultPrepareRenderTargetsRenderingStep">
            <summary>
            Gets a default <see cref="T:Ab3d.DirectX.PrepareRenderTargetsRenderingStep" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DefaultRenderObjectsRenderingStep">
            <summary>
            Gets a default <see cref="T:Ab3d.DirectX.RenderObjectsRenderingStep" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DefaultResolveBackBufferRenderingStep">
            <summary>
            Gets a default <see cref="T:Ab3d.DirectX.ResolveBackBufferRenderingStep" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DefaultCompleteRenderingStep">
            <summary>
            Gets a default <see cref="T:Ab3d.DirectX.CompleteRenderingStep" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DefaultRenderPostProcessingRenderingStepsGroup">
            <summary>
            Gets a default <see cref="T:Ab3d.DirectX.RenderingStepsGroup" /> that groups PreparePostProcessing and RenderPostProcessing rendering steps.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DefaultRenderPostProcessingRenderingStep">
            <summary>
            Gets a default <see cref="T:Ab3d.DirectX.RenderPostProcessingRenderingStep" />. This rendering step is defined in the DefaultRenderPostProcessingRenderingStepsGroup.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DefaultPreparePostProcessingRenderingStep">
            <summary>
            Gets a default <see cref="T:Ab3d.DirectX.PreparePostProcessingRenderingStep" />.  This rendering step is defined in the DefaultRenderPostProcessingRenderingStepsGroup.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.IsMaterialSortingEnabled">
            <summary>
            Gets or sets a Boolean that specified if sorting objects by their materials is enabled.
            Sorting objects usually improves rendering performance because objects with same materials are rendered one after another and this reduces the required DirectX state changes.
            Objects are sorted by their material hash value only when they are in the <see cref="T:Ab3d.DirectX.MaterialSortedRenderingQueue" /> (usually all standard and opaque geometry objects).
            But sometimes user wants to have full control of the order in which the objects are sorted. In this case it is possible to disable material sorting.
            Default value is true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.IsTransparencySortingEnabled">
            <summary>
            Gets or sets a Boolean that specifies if sorting transparent objects by their distance to the camera is enabled.
            Default value is false.
            See remarks for more info.
            </summary>
            <remarks>
                <para>
            IsTransparencySortingEnabled gets or sets a Boolean that specifies if sorting transparent objects by their distance to the camera is enabled.
            </para>
                <para>
            When rendering transparent and semi-transparent objects with using alpha blending (standard technique to render transparent objects),
            then the objects behind transparent objects needs to be rendered before the transparent objects.
            Otherwise the depth clipping will prevent them to be rendered and therefore they will not be visible through the transparent objects.
            This means that for correct rendering of transparent objects, then need to be rendered so that those farther away from the camera are rendered first and
            then objects closer to the camera are rendered.
            </para>
                <para>
            Setting this value sets the <see cref="P:Ab3d.DirectX.SortedRenderablePrimitiveRenderingQueue.IsSortingEnabled" /> property on the <see cref="T:Ab3d.DirectX.CameraDistanceSortedRenderingQueue" />.
            </para>
                <para>
            Default value is false.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.RenderingContext">
            <summary>
            Gets the RenderingContext that defines the context information that are used during scene rendering.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.UseSharedWpfTexture">
            <summary>
            Gets or sets a nullable Boolean that is used only when using BackBuffer without SwapChain and specifies if DXScene is using a shared resources (texture) that can be used by both DirectX 11 (DXEngine) and DirectX 9 (WPF).
            Using shared resources improves performance because the texture that is used to render the DirectX 11 image is shader with WPF composition engine.
            This means that the texture is not copied to main CPU memory and than back to GPU by WPF. 
            When the value is not set by the user (is null), then the value is set in the DXScene initialization.
            It is set to true when DXEngine is using the same graphics card (adapter) then WPF. Otherwise the value is set to false.
            </summary>
            <remarks>
                <para>
                    <b>UseSharedWpfTexture</b> gets or sets a nullable Boolean that is used only when using BackBuffer without SwapChain and specifies if DXScene is using a shared resources (texture) that can be used by both DirectX 11 (DXEngine) and DirectX 9 (WPF).
            </para>
                <para>
            Using shared resources improves performance because the texture that is used to render the DirectX 11 image is shader with WPF composition engine. This means that the texture is not copied to main CPU memory and than back to GPU by WPF. 
            </para>
                <para>
            When the value is not set by the user (is null), then the value is set in the DXScene initialization.
            It is set to true when DXEngine is using the same graphics card (adapter) then WPF. Otherwise the value is set to false.
            </para>
            </remarks>
            <example>
                <para>
            If you want to set the value of UseSharedWpfTexture to false, this needs to be done before the DirectX buffers and other resources are created.
            The best place to set the value is in the DXSceneDeviceCreated event handler.
            </para>
                <code>
            MainDXViewportView.DXSceneDeviceCreated += delegate(object sender, EventArgs e)
            {
                if (MainDXViewportView.DXScene != null) // DXScene can be null in case of WPF rendering
                    MainDXViewportView.DXScene.UseSharedWpfTexture = false;
            };
            </code>
            </example>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.PostProcesses">
            <summary>
            Gets a collection of post processes that will be applied after rendering the 3D scene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.Device">
            <summary>
            Gets a DirectX device that is used by this DXScene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.IsInitialized">
            <summary>
            Gets a Boolean that is set to true when this DXScene is initialized - DXDevice are created and also required objects and collections are created: RenderingContext, RenderingQueues, PostProcessing.
            Also the SwapChain is created when the DXScene in initialized with InitializeSwapChain method (though the size of SwapChain buffers might not be final yet).
            Note that when IsInitialized is set to true, the DirectX buffers are initialized only when the size of viewport is already known.
            To see if buffers are initialized check the <see cref="P:Ab3d.DirectX.DXScene.BuffersInitialized" /> property.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.BuffersInitialized">
            <summary>
            Gets a Boolean that specifis if SwapChain and buffers are created.
            This property can be false when DXScene is initialized with zero width and height.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.IsSwapChainCreated">
            <summary>
            Gets a Boolean that specifis if DXScene will be using SwapChain to render the scene and if SwapChain is already created. 
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DXDevice">
            <summary>
            Gets a DXDevice that was used to initialize this DXScene.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.DXScene.AfterFrameInitialized">
            <summary>
            AfterFrameInitialized event is triggered after the RenderTargets have been set and cleared, Viewports have been set and default Rasterizer state has been set.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.DXScene.AfterObjectsRendered">
            <summary>
            AfterObjectsRendered event is triggered after all the objects have been rendered and before rendered objects are "sent to the screen" (Present method on SwapChain is called or the render target is prepared for D3DImage)
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.DXScene.AfterUpdated">
            <summary>
            AfterUpdated event is triggered after the SceneNode objects have been updated and before the decision is made to render the next frame or not.
            Subscriber to this event can prevent rendering frame or force rendering it with changing the <see cref="P:Ab3d.DirectX.UpdateStatusEventArgs.IsRenderNeeded" /> property in the event args.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.DXScene.AfterFrameRendered">
            <summary>
            AfterFrameRendered event is triggered after all the rendering activities for one frame have been finished.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.DXScene.BackBufferReady">
            <summary>
            BackBufferReady event is triggered when the rendered image is ready to be copied from graphic to main memory.
            This is used when DirectXImage presentation type is used and when DXEngine is using software rendering or when <see cref="P:Ab3d.DirectX.DXScene.UseSharedWpfTexture" /> is set to true.
            In those cases the DXEngine is rendering the image to a so called staging buffer and when the image in staging buffer is ready 
            the BackBufferReady is triggered. The event arguments contain the size of the image, its format and the mapped subresource.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.DXScene.DeviceRemoved">
            <summary>
            DeviceRemoved event is triggered when the DirectX device is removed or reset (for example when the DirectX driver is updated; but not when computer goes to sleep).
            The event handler can handle this case with saving the current state of the 3D scene, dispose the current DirectX objects and recreate the 3D scene.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.DXScene.SizeChanged">
            <summary>
            SizeChanged event is trigger after the <see cref="M:Ab3d.DirectX.DXScene.Resize(System.Int32,System.Int32,System.Single,System.Single)" /> method is called.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.BackgroundColor">
            <summary>
            Gets or sets a Color4 that represents a background color for the scene. 
            The color values must be alpha premultiplied - each red, green and blue value must be multiplied with alpha value (for example a fully transparent value is (0, 0, 0, 0) and not (0, 255, 255, 255) as in WPF.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.Width">
            <summary>
            Gets an integer that represents a width of the Viewport
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.Height">
            <summary>
            Gets an integer that represents a height of the Viewport
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.Viewport">
            <summary>
            Gets or sets a Viewport that defines the area where the scene will be rendered.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.BackBuffer">
            <summary>
            Gets the BackBuffer as Texture2D
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.BackBufferDescription">
            <summary>
            Gets the Description of the BackBuffer 
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.BackBufferRenderTargetView">
            <summary>
            Gets the RenderTargetView of the BackBuffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DepthStencilView">
            <summary>
            Gets the DepthStencilView
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.MSAABackBuffer">
            <summary>
            Gets the MSAA BackBuffer as Texture2D (set if multisampling is used)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.MSAABackBufferDescription">
            <summary>
            Gets the Description of the MSAABackBuffer 
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.MSAABackBufferRenderTargetView">
            <summary>
            Get the RenderTargetView of the MSAA BackBuffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.SSAABackBuffer">
            <summary>
            Gets the super-sampled BackBuffer as Texture2D (set if super-sampling is used)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.SSAABackBufferDescription">
            <summary>
            Gets the Description of the super-sampled BackBuffer 
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.SSAABackBufferRenderTargetView">
            <summary>
            Get the RenderTargetView of the super-sampled BackBuffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.SSAABackBufferShaderResourceView">
            <summary>
            Get the ShaderResourceView of the super-sampled BackBuffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.StagingBackBuffer">
            <summary>
            Gets the StagingBackBuffer that is used when the final rendered image needs to be copied to main memory.
            This can be done only from staging buffer. When final render image in not copied to main memory the StagingBackBuffer is null.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.StagingBackBufferDescription">
            <summary>
            Gets the Description of the StagingBackBuffer 
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.CreateBackBufferShaderResourceView">
            <summary>
            When true and when swap chain is not used, then a <see cref="P:Ab3d.DirectX.DXScene.BackBufferShaderResourceView" /> is created from BackBuffer. Default value is false.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.BackBufferShaderResourceView">
            <summary>
            ShaderResourceView that is created from BackBuffer.
            Created when DXScene is initialized with <see cref="P:Ab3d.DirectX.DXScene.CreateBackBufferShaderResourceView" /> property set to true and when swap chain is not used.
            The created ShaderResourceView can be copied to another ShaderResourceView that is used as a texture in some other 3D scene when the DirectX device is shared between both 3D scenes.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.SwapChain">
            <summary>
            Gets the SwapChain or null if SwapChain is not used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.UsedSwapChainEffect">
            <summary>
            Gets the SwapEffect that was used to create the SwapChain.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DpiScaleX">
            <summary>
            Gets or sets a float that represents a DPI scale factor in X direction: 1 means 96 DPI, 1.5 means 144 DPI, etc. 
            This value is used in line and pixel rendering and scales the line thickness or size of pixels.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DpiScaleY">
            <summary>
            Gets or sets a float that represents a DPI scale factor in Y direction: 1 means 96 DPI, 1.5 means 144 DPI, etc. 
            This value is used in line and pixel rendering and scales the line thickness or size of pixels.        
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.ShaderQuality">
            <summary>
            Gets or sets a quality settings that specifies the type of shader that should be used to render the scene.
            If DXScene is used with DXViewportView, then this value is set from used GraphicsProfile.
            NOTE: Changing this property after the DXDevice is initialized will have no effect.
            </summary>
            <remarks>
                <para>
                    <b>ShaderQuality</b> gets or sets a quality settings that specifies the type of shader that should be used to render the scene.
            </para>
                <para>
            If DXScene is used with DXViewportView, then this value is set from used GraphicsProfile.
            </para>
                <para>
            ShaderQuality can be set to any value defined in the <see cref="P:Ab3d.DirectX.DXScene.ShaderQuality" /> enum.
            </para>
                <para>
            By default ShaderQuality is set to Normal value. This values tries to use per pixel lighting calculations.
            When ShaderQuality is set to Low, than per vertex lighting calculations are used.
            This increases performance because lighting is calculated only for each vertex (instead of each pixel) but reduces the rendering quality.
            </para>
                <para>
            When using shaders that come with DXDevice, the High quality value does not have any effect because DXDevice does not have any additional higher quality shaders but this setting can be used for custom shaders (for example for normal mapping shader that would also require additional mesh data).
            </para>
                <para>
            Changing ShaderQuality after the DXDevice is initialized will have no effect.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.ExecutePixelShaderPerSample">
            <summary>
            ExecutePixelShaderPerSample is obsolete. Use <see cref="P:Ab3d.DirectX.DXScene.SupersamplingCount" /> instead.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DepthStencilBufferFormat">
            <summary>
            Gets or sets a depth stencil buffer format that is used in rendering the scene.
            Default value is D32_Float (32 bit depth buffer, no stencil buffer).
            If this value is changed, a new depth stencil buffer will be created in the next call to <see cref="T:Ab3d.DirectX.PrepareRenderTargetsRenderingStep" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.MaxBackgroundThreadsCount">
            <summary>
            Gets or sets an integer that specifies the maximum number of background threads that can be used for multi-threaded operations.
            Value 0 means that no background thread will be used and that all rendering will be performed on the main thread.
            Value 4 means that besides the main thread up to four additional background threads can be used for rendering.
            The actually used number of threads can be lower if there is not a lot of objects to render.
            Default value is set to Environment.ProcessorCount minus 1 but 7 is the maximum value. See remarks for more info.
            </summary>
            <remarks>
                <para>
                    <b>MaxBackgroundThreadsCount</b> gets or sets an integer that specifies the maximum number of background threads that can be used for multi-threaded operations.
            </para>
                <para>
            Examples:
            Value 0 means that no background thread will be used and that all rendering will be performed on the main thread.
            Value 4 means that besides the main thread up to four additional background threads can be used for rendering.
            </para>
                <para>
            Default value for MaxBackgroundThreadsCount is set as following:<br />
            When we have only 1 processor (Environment.ProcessorCount), then MaxBackgroundThreadsCount is set to 0 - no multi-threading.<br />
            When we have less or equal to 8 processors, then use all the processors - one for main thread and (ProcessorCount minus 1) for background threads.<br />
            When we have more then 8 processors, MaxBackgroundThreadsCount is by default set to 7 (using one main thread and 7 background threads). When using more threads then the gains are very small compared with additional overhead of multiple threads.
            </para>
                <para></para>
                <para>
                    <b>Overview of multi-threading in Ab3d.DXEngine</b>
                </para>
                <para>
            In DXEngine all the SceneNodes and RenderingQueue objects are created on the same thread as the DXScene object is created (usually the UI thread).
            This ensures that all the memory write operations are correct.
            </para>
                <para>
            After RenderingQueues are created, the RenderableObjects in the queues are immutable (cannot be changed) and this means that rendering the objects
            (setting up ConstantBuffers, DirectX states and issuing DirectX draw calls) can be done on multiple threads.
            </para>
                <para>
            Still, the DXEngine's Effect that is used to render the object needs to support background rendering.
            In the current version of the DXEngine only the <see cref="T:Ab3d.DirectX.Effects.StandardEffect" /> supports background thread rendering.
            This effect is the most commonly used effect because it is used to render all WPF objects (using WpfMaterial) and all objects with <see cref="T:Ab3d.DirectX.Materials.StandardMaterial" />.
            But 3D lines, objects that use instancing, per-vertex color material or some other effect are not rendered on the background thread.
            Those objects are always rendered on the main thread. 
            </para>
                <para>
            This may seem as not optimal. But for most cases this approach provides an advantage where complex objects (instancing, 3D lines)
            are immediately sent to the GPU from the main thread. While those objects are already processed by the graphics card,
            the DXEngine can create command lists to render standard objects in the background threads.
            </para>
                <para>
            Also, all the transparent objects are always rendered on the main thread.
            This is needed because the order in which the transparent objects are rendered needs to be preserved.
            </para>
                <para>
            The maximum number of used background threads is defined by the MaxBackgroundThreadsCount property.
            </para>
                <para>
            The used number of threads is also determined by the number of objects to render (by default at least 100 objects per thread - defined by <see cref="F:Ab3d.DirectX.RenderObjectsRenderingStep.MinObjectsPerThread" />).
            This means that the actually used number of thread can be lower then MaxBackgroundThreadsCount when only smaller number of objects need to be rendered.
            </para>
                <para>
            For example if there are 320 objects to render and MaxBackgroundThreadsCount is set to 7 and MinObjectsPerThread is set to 100 (by default),
            then only 2 background threads (and one main thread) will be used to render all the objects.
            </para>
                <para>
            It is also possible to fine tune the use of multi-treading with setting the RenderObjectsRenderingStep.<see cref="P:Ab3d.DirectX.RenderObjectsRenderingStep.UseMultiThreading" /> (enable or disable multi-threading in the specified <see cref="T:Ab3d.DirectX.RenderObjectsRenderingStep" />) or
            RenderingQueue.<see cref="F:Ab3d.DirectX.RenderingQueue.UseMultiThreading" /> (enable or disable multi-threading in the specified RenderingQueue) properties.
            </para>
                <para>
            DXEngine does not use .Net Tasks for multi-threading. The reason is that Task object cannot be reused once it was completed.
            This means that if Tasks were used in DXEngine, each frame new Task objects would need to be created for each thread.
            This would create a significant amount of new objects. Therefore DXEngine uses its own thread manager (<see cref="P:Ab3d.DirectX.DXScene.BackgroundThreadsManager" />).
            A BackgroundThreadsManager is set to the DXDevice.<see cref="P:Ab3d.DirectX.DXDevice.BackgroundThreadsManager" /> property and
            is used by all DXScene objects that use that DXDevice (the same threads are used to render the objects).
            But if you want that DXScene uses its own threads for background rendering, it is possible to specify a BackgroundThreadsManager to the <see cref="P:Ab3d.DirectX.DXScene.BackgroundThreadsManager" /> property (null by default - in this case BackgroundThreadsManager from DXDevice is used).
            </para>
                <para>
            BackgroundThreadsManager creates background threads and executes rendering actions there.
            It is always possible to get the number of created threads by checking its <see cref="P:Ab3d.DirectX.Threading.BackgroundThreadsManager.ThreadsCount" /> property.
            Because number of used threads is also determined by the number of shown objects and because that number can change,
            the BackgroundThreadsManager does not immediately abort a thread when it is not required anymore.
            Instead it waits for one second (by default) and if the thread is still not needed then it aborts it.
            </para>
                <para></para>
                <para>
            Performance gains from using multi-threaded rendering can be awesome - in some cases it is possible to render more the 4 times the number of objects in the same time.
            </para>
                <para>
            The multi-threading works best when your rendering process is CPU bound.
            This means that to render a 3D scene CPU needs to work for longer then GPU - most of the time is spent to issue draw command to the graphics card.
            An example of such 3D scene is rendering many simple meshes (note that when the meshes are the same, you will get even faster performance when object instancing is used).
            </para>
                <para>
            Another factor that significantly affect the performance gains get by multi-threading is the value of the PresentationType parameter in DXViewportView.
            When DirectXOverlay is used then DXEngine does not need to wait until the graphics card finishes rendering the scene.
            This means that if the drawing process (sending DirectX commands to the graphics card - measured by the <see cref="P:Ab3d.DirectX.RenderingStatistics.DrawRenderTimeMs" /> in rendering statistics) is 4 times faster because of multi-threading,
            the DXEngine will be able to render 4 times that much objects in the same time (when having a graphic card that is fast enough).
            But when DirectXImage is used (by default), the results are not that awesome. The reason is that in this case the DXEngine needs to wait until the image is fully rendered by the GPU.
            Because of multi-threading the drawing process can still be significantly lower, but with DirectXImage
            the waiting for the GPU (<see cref="P:Ab3d.DirectX.RenderingStatistics.CompleteRenderTimeMs" />) can be much longer (compared to no multi-threading).
            Anyway, multi-threading can still provides significant performance gains even with DirectXImage.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.IsCachingCommandLists">
            <summary>
            Gets or sets a Boolean that specifies if Ab3d.DXEngine records all DirectX commands into DirectX CommandLists and
            reuses the command lists on next frame if only camera and light properties have changed.
            See remarks for more info. Default value is false.
            </summary>
            <remarks>
                <para>
            IsCachingCommandLists a Boolean that specifies if Ab3d.DXEngine records all DirectX commands into DirectX CommandLists.
            </para>
                <para>
            When IsCachingCommandLists is set to true, then Ab3d.DXEngine records all DirectX commands into DirectX CommandLists and
            reuses the command lists on next frame if only camera and light properties have changed.
            In this case only the new camera data is loaded into the graphics card and then all the previously rendered CommandLists are replayed.
            This way the rendering performance is greatly improved because the render time is almost zero (this is the time to prepare and process the DirectX commands by the Ab3d.DXEngine and by the DirectX and drives).
            </para>
                <para>
            Note that command list caching works only for objects in <see cref="P:Ab3d.DirectX.DXScene.StandardGeometryRenderingQueue" /> - that rendering queue contains only standard geometry objects with WpfMaterial or StandardMaterial.
            </para>
                <para>
            In cases when the frame is rendered because of some other changes (for example change in material or transformation),
            then caching CommandLists slightly decreases performance because the actual rendering needs to wait until the CommandLists are prepared
            (otherwise the rendering on the main thread starts immediately - the DirectX commands are immediately sent to the graphics card).
            What is more the multi-threaded distribution of work is not so granular and does use the cores so good based on their performance.
            </para>
                <para>
            A general rule is that if your scene is not changed a lot and most of times the new frames are rendered because the camera is changing,
            then the performance benefits of caching CommandLists are much bigger then slight slowdown when rendering a changed scene.
            </para>
                <para>
            Note that actual CommandLists caching starts when number of objects to render is bigger then the threshold value defined in the static <see cref="F:Ab3d.DirectX.RenderObjectsRenderingStep.MinObjectsForCachedCommandLists" /> field from the RenderObjectsRenderingStep (400 by default).
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.BackgroundThreadsManager">
            <summary>
            Gets or sets a BackgroundThreadsManager that is used instead of BackgroundThreadsManager defined in DXDevice.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.IsRendering">
            <summary>
            Returns true when DXScene is currently executing object rendering (is inside RenderScene method).
            This property can be checked from a background thread.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.Lights">
            <summary>
            Gets a list of lights that are used in this DXScene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.UsedMultisamplingDescription">
            <summary>
            Gets a SampleDescription that describes what level of multisampling is used by the current DXScene.
            Multisampling is used to create antialiased images with rendering the multiple samples of the same pixel.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.MultisampleCount">
            <summary>
            Gets an integer that represents a used multisample count (used for anti-aliasing)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.SupersamplingCount">
            <summary>
            Gets the super-sampling count that describes how much more pixels are rendered for each final pixel.
            The rendering is done on a scaled texture that is bigger for the amount specified by SupersamplingCount.
            At the end of rendering this texture is down-sampled into the texture with the final size.
            Valid values are 1 (no super-sampling), 4, 16 and 64. Value 4 means that width and height are multiplied by 2 and this produces a texture with 4 times as much pixels.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.SupersamplingFactor">
            <summary>
            Gets the factor by which width and height are multiplied because of the <see cref="P:Ab3d.DirectX.DXScene.SupersamplingCount" />.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.IsEnabled">
            <summary>
            Gets or sets if this DXScene is enabled and is rendering the scene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.OptimizeNearAndFarCameraPlanes">
            <summary>
            Gets or sets a boolean that specify if NearPlaneDistance and FarPlaneDistance are automatically set by scene bounds (true by default).
            This can prevent z-fighting problems. If you want that that NearPlaneDistance and FarPlaneDistance are set manually, this property must be set to false.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.MinNearPlaneDistance">
            <summary>
            When MinNearPlaneDistance is set to any positive value and <see cref="P:Ab3d.DirectX.DXScene.OptimizeNearAndFarCameraPlanes" /> is true, the calculated near plane distance is never smaller then the specified value.
            Default value is NaN.
            </summary>
            <remarks>
                <para>
            When MinNearPlaneDistance is set to any positive value and <see cref="P:Ab3d.DirectX.DXScene.OptimizeNearAndFarCameraPlanes" /> is true, the calculated near plane distance is never smaller then the specified value.
            </para>
                <para>
            This value defines how close to the camera the objects are still rendered - positions that are closer to the camera then the MinNearPlaneDistance are not rendered.
            Setting this value to a value that is bigger then the calculated NearPlaneDistance increase the resolution of depth buffer and can prevent z-fighting problems.
            </para>
                <para>
            Default value is NaN.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.MaxFarPlaneDistance">
            <summary>
            When MaxFarPlaneDistance is set to any positive value and <see cref="P:Ab3d.DirectX.DXScene.OptimizeNearAndFarCameraPlanes" /> is true, the calculated far plane distance is never bigger then the specified value.
            This value must be bigger then <see cref="P:Ab3d.DirectX.DXScene.MinNearPlaneDistance" /> or its value is not used.
            Default value is NaN.
            </summary>
            <remarks>
                <para>
            When MaxFarPlaneDistance is set to any positive value and <see cref="P:Ab3d.DirectX.DXScene.OptimizeNearAndFarCameraPlanes" /> is true, the calculated far plane distance is never bigger then the specified value.
            </para>
                <para>
            This value must be bigger then <see cref="P:Ab3d.DirectX.DXScene.MinNearPlaneDistance" /> or its value is not used.
            </para>
                <para>
            This value defines how far from the camera the objects are still rendered - positions that are farther away from the camera then the MaxFarPlaneDistance are not rendered.
            </para>
                <para>
            Default value is NaN.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.Camera">
            <summary>
            Gets or sets an ICamera that is used to show the scene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.FrameNumber">
            <summary>
            Gets an integer that represents the last rendered frame number (increased after each rendered frame)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.Statistics">
            <summary>
            Gets RenderingStatistics class that contains various rendering statistics.
            Statistics is collected only when <see cref="P:Ab3d.DirectX.DXDiagnostics.IsCollectingStatistics" /> is set to true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.RootNode">
            <summary>
            Gets or sets a root SceneNode - the first in the hierarchy.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.#ctor(Ab3d.DirectX.DXDevice,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="dxDevice">DXDevice</param>
            <param name="name">optional name</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.#ctor(Ab3d.DirectX.DXScene,System.Boolean,System.String)">
            <summary>
            Creates a child DXScene that will render the objects defined in the masterDXScene to the back buffer and with camera defined in this DXScene.
            </summary>
            <param name="masterDXScene">DXScene that defines the 3D objects and that will render the scene to this DXScene's back buffers</param>
            <param name="createRenderingSteps">when false, then RenderingSteps are not created because RenderingSteps from masterDXScene will be used</param>
            <param name="name">optional name</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.InitializeSwapChain(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            InitializeWithSwapChain
            </summary>
            <param name="hWnd">window handle</param>
            <param name="width">width (if 0, swap chain and buffers will be created on first Resize)</param>
            <param name="height">height (if 0, swap chain and buffers will be created on first Resize)</param>
            <param name="preferedMultisampleCount">multi-sample count that is used if supported by device</param>
            <param name="supersamplingCount">super-sampling count (1 for no super-sampling)</param>
            <param name="dpiScaleX">float that represents a DPI scale factor in X direction: 1 means 96 DPI, 1.5 means 144 DPI, etc.</param>
            <param name="dpiScaleY">float that represents a DPI scale factor in Y direction: 1 means 96 DPI, 1.5 means 144 DPI, etc.</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.InitializeBackBuffer(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            InitializeWithBackBuffer
            </summary>
            <param name="width">width that is already multiplied by dpiScaleX (if 0, swap chain and buffers will be created on first Resize)</param>
            <param name="height">height that is already multiplied by dpiScaleY (if 0, swap chain and buffers will be created on first Resize)</param>
            <param name="preferedMultisampleCount">multi-sample count that is used if supported by device</param>
            <param name="supersamplingCount">super-sampling count (possible values: 1 no super-sampling, 4, 16, 64)</param>
            <param name="dpiScaleX">float that represents a DPI scale factor in X direction: 1 means 96 DPI, 1.5 means 144 DPI, etc.</param>
            <param name="dpiScaleY">float that represents a DPI scale factor in Y direction: 1 means 96 DPI, 1.5 means 144 DPI, etc.</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.InitializeDevice">
            <summary>
            InitializeDevice is a virtual method that calls InitializeDevice on DXDevice if it was not yet initialized.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.InitializeSwapChain(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            InitializeSwapChain creates a SwapChain
            </summary>
            <param name="hWnd">handle to window that will be used by the SwapChain (must not be IntPtr.Zero)</param>
            <param name="width">width of the swap chain back buffer (if less or equal to 0, then 1 will be used)</param>
            <param name="height">height of the swap chain back buffer (if less or equal to 0, then 1 will be used)</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.InitializeBuffers(System.Int32,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            InitializeBuffers creates SwapChain (if needed) all required buffers and buffer views.
            </summary>
            <param name="width">width of the viewport</param>
            <param name="height">height of the viewport</param>
            <param name="superSamplingCount">super-sampling count (1 for no super-sampling)</param>
            <param name="dpiScaleX">X dpi scale (1.0 means 96 DPI)</param>
            <param name="dpiScaleY">Y dpi scale (1.0 means 96 DPI)</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.Resize(System.Int32,System.Int32)">
            <summary>
            Resize method resizes the buffers needed to render the DXScene (DpiScale values are preserved; to change or set DpiScale, call overloaded method that takes DpiScale parameters)
            </summary>
            <param name="newWidth">new width</param>
            <param name="newHeight">new height</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.Resize(System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Resize method resizes the buffers needed to render the DXScene
            </summary>
            <param name="newWidth">new width</param>
            <param name="newHeight">new height</param>
            <param name="dpiScaleX">dpiScaleX</param>
            <param name="dpiScaleY">dpiScaleY</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.Resize(System.Int32,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Resize method resizes the buffers needed to render the DXScene
            </summary>
            <param name="newWidth">new width</param>
            <param name="newHeight">new height</param>
            <param name="superSamplingCount">super-sampling count (1 for no super-sampling)</param>
            <param name="dpiScaleX">dpiScaleX</param>
            <param name="dpiScaleY">dpiScaleY</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.CreateAndUseStagingBuffer">
            <summary>
            CreateAndUseStagingBuffer creates a Staging buffer (used to copy the rendered back buffer to main memory) and set it to RenderingContext.
            </summary>
            <remarks>
                <para>
                    <b>CreateAndUseStagingBuffer</b> creates a Staging buffer (used to copy the rendered back buffer to main memory) and set it to RenderingContext.
            </para>
                <para>
            This method can be called when we initially wanted to use Shared texture, but D3DImage initialization failed.
            In this case we need to switch to staging buffer where the back buffer is copied to main memory and used in WPF from there.
            </para>
            </remarks>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.HandleDeviceRemoved(System.String,SharpDX.SharpDXException)">
            <summary>
            HandleDeviceRemoved is called when a DirectX device is removed or reset.
            The method gets device removed reason from DirectX API and then calls the <see cref="E:Ab3d.DirectX.DXScene.DeviceRemoved" /> event handler.
            If the event handler handles the event, then the method returns.
            Otherwise the method throws an DXEngineException with description from specified message and device removed reason.
            </summary>
            <param name="message">message that describes where the device removal happened</param>
            <param name="sharpDxException">SharpDXException with result code DeviceRemoved or DeviceReset</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.InitializeVirtualRealityRendering(Ab3d.DirectX.VirtualRealityProviderBase)">
            <summary>
            InitializeVirtualRealityRendering initializes virtual reality rendering with using the specified virtualRealityProvider.
            To dispose virtual reality rendering pass null as virtualRealityProvider parameter.
            </summary>
            <param name="virtualRealityProvider">VirtualRealityProviderBase</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.InitializeShadowRendering(Ab3d.DirectX.ShadowRenderingProviderBase)">
            <summary>
            InitializeShadowRendering initializes shadow rendering with using the specified shadowRenderingProvider.
            To dispose shadow rendering rendering pass null as shadowRenderingProvider parameter.
            </summary>
            <param name="shadowRenderingProvider">ShadowRenderingProviderBase</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.GetRayFromCamera(System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Returns SharpDX.Ray that goes into a direction that is calculated from the specified x and y position in screen coordinates.
            For perspective camera the ray starts at the current camera position.
            The ray can be used for hit testing from the mouse position defined by x and y (relative to this DXScene object).
            </summary>
            <remarks>
                <para>
            Returns SharpDX.Ray that goes into a direction that is calculated from the specified x and y position in screen coordinates.
            For perspective camera the ray starts at the current camera position.
            The ray can be used for hit testing from the mouse position defined by x and y (relative to this DXScene object).
            </para>
                <para>
            When the adjustForDpiScale parameter is set to true (by default), the x and y positions are multiplied by 
            the <see cref="P:Ab3d.DirectX.DXScene.DpiScaleX" /> and <see cref="P:Ab3d.DirectX.DXScene.DpiScaleY" />. 
            This should be used when x and y are get from mouse location on the DXViewportView object. 
            When x any y are from the DXScene.Width and DXScene.Height, then this parameter needs to be false.
            For example: when DpiScale is 1.5 (144 DPI) and the width of the DXViewportView is 1000, then the DXScene.Width is 1500. To correctly use the x from DXViewportView on the DXScene, the x value needs to be multiplied by the DpiScale (1.5).
            </para>
                <para>
            The difference between the ray that is returned from this method and the ray from the <see cref="M:Ab3d.DirectX.DXScene.GetRayFromNearPlane(System.Int32,System.Int32,System.Boolean,System.Boolean)" /> method is that
            in case of perspective camera the position of the ray from this method is set to the position of the camera. 
            The position of the ray from <see cref="M:Ab3d.DirectX.DXScene.GetRayFromNearPlane(System.Int32,System.Int32,System.Boolean,System.Boolean)" /> method is set to a position on the camera's near plane.
            Both rays can be get for hit-testing. The difference is only in the distance from the hit origin in the hit test result.
            </para>
            </remarks>
            <seealso cref="M:Ab3d.DirectX.DXScene.GetRayFromNearPlane(System.Int32,System.Int32,System.Boolean,System.Boolean)" />
            <param name="x">x position in the viewport of this DXScene</param>
            <param name="y">y position in the viewport of this DXScene</param>
            <param name="adjustForDpiScale">when true (by default) the x and y positions are multiplied by the <see cref="P:Ab3d.DirectX.DXScene.DpiScaleX" /> and <see cref="P:Ab3d.DirectX.DXScene.DpiScaleY" />. This should be used when x and y are get from mouse location on the DXViewportView object. When x any y are from the DXScene.Width and DXScene.Height, then this parameter needs to be false.</param>
            <param name="adjustForSupersamplingFactor">when true (by default) the x and y positions are multiplied by the <see cref="P:Ab3d.DirectX.DXScene.SupersamplingFactor" />. This should be used when x and y are get from mouse location on the DXViewportView object. When x any y are from the DXScene.Width and DXScene.Height, then this parameter needs to be false.</param>
            <returns>SharpDX.Ray in world coordinates that is defined from x and y screen positions (the ray stars at camera's position)</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.GetRayFromNearPlane(System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Returns SharpDX.Ray that starts at the camera's near plane and goes into a direction that is calculated from the specified x and y position in screen coordinates.
            The ray can be used for hit testing from the mouse position defined by x and y (relative to this DXScene object).
            </summary>
            <remarks>
                <para>
            Returns SharpDX.Ray that starts at the camera's near plane and goes into a direction that is calculated from the specified x and y position in screen coordinates.
            The ray can be used for hit testing from the mouse position defined by x and y (relative to this DXScene object).
            </para>
                <para>
            When the adjustForDpiScale parameter is set to true (by default), the x and y positions are multiplied by 
            the <see cref="P:Ab3d.DirectX.DXScene.DpiScaleX" /> and <see cref="P:Ab3d.DirectX.DXScene.DpiScaleY" />. 
            This should be used when x and y are get from mouse location on the DXViewportView object. 
            When x any y are from the DXScene.Width and DXScene.Height, then this parameter needs to be false.
            For example: when DpiScale is 1.5 (144 DPI) and the width of the DXViewportView is 1000, then the DXScene.Width is 1500. To correctly use the x from DXViewportView on the DXScene, the x value needs to be multiplied by the DpiScale (1.5).
            </para>
                <para>
            The difference between the ray that is returned from this method and the ray from the <see cref="M:Ab3d.DirectX.DXScene.GetRayFromCamera(System.Int32,System.Int32,System.Boolean,System.Boolean)" /> method is that
            the position of the ray from this method is set to a position on the camera's near plane. 
            The position of the ray from <see cref="M:Ab3d.DirectX.DXScene.GetRayFromCamera(System.Int32,System.Int32,System.Boolean,System.Boolean)" /> method is set to the position of the camera.
            Both rays can be get for hit-testing. The difference is only in the distance from the hit origin in the hit test result.
            </para>
            </remarks>
            <seealso cref="M:Ab3d.DirectX.DXScene.GetRayFromCamera(System.Int32,System.Int32,System.Boolean,System.Boolean)" />
            <param name="x">x position in the viewport of this DXScene</param>
            <param name="y">y position in the viewport of this DXScene</param>
            <param name="adjustForDpiScale">when true (by default) the x and y positions are multiplied by the <see cref="P:Ab3d.DirectX.DXScene.DpiScaleX" /> and <see cref="P:Ab3d.DirectX.DXScene.DpiScaleY" />. This should be used when x and y are get from mouse location on the DXViewportView object. When x any y are from the DXScene.Width and DXScene.Height, then this parameter needs to be false.</param>
            <param name="adjustForSupersamplingFactor">when true (by default) the x and y positions are multiplied by the <see cref="P:Ab3d.DirectX.DXScene.SupersamplingFactor" />. This should be used when x and y are get from mouse location on the DXViewportView object. When x any y are from the DXScene.Width and DXScene.Height, then this parameter needs to be false.</param>
            <returns>SharpDX.Ray in world coordinates that is defined from x and y screen positions (the ray stars at camera's near plane)</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.IsOnMainRenderThread">
            <summary>
            Returns true when the code is currently executing on main render thread (the thread that was used to create this DXScene).
            </summary>
            <returns>true when the code is currently executing on main render thread</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.CreateDefaultRenderingSteps">
            <summary>
            CreateDefaultRenderingSteps clears the current rendering step (<see cref="P:Ab3d.DirectX.DXScene.RenderingSteps" />) and adds the default rendering steps to the RenderingSteps list.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.OnAfterUpdated(Ab3d.DirectX.UpdateStatusEventArgs)">
            <summary>
            OnAfterFrameInitialized
            </summary>
            <param name="updateStatusEventArgs">RenderingReasonEventArgs</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.OnAfterFrameRendered(Ab3d.DirectX.RenderingEventArgs)">
            <summary>
            OnAfterFrameRendered
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.OnBackBufferReady(Ab3d.DirectX.BackBufferReadyEventArgs)">
            <summary>
            OnBackBufferReady
            </summary>
            <param name="backBufferReadyEventArgs">BackBufferReadyEventArgs</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.OnAfterFrameInitialized(Ab3d.DirectX.RenderingEventArgs)">
            <summary>
            OnAfterFrameInitialized
            </summary>
            <param name="renderingEventArgs">RenderingEventArgs</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.OnAfterObjectsRendered(Ab3d.DirectX.RenderingEventArgs)">
            <summary>
            OnAfterObjectsRendered
            </summary>
            <param name="renderingEventArgs">RenderingEventArgs</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.OnSizeChanged">
            <summary>
            OnSizeChanged
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.FindNode(System.String)">
            <summary>
            FindNode searches SceneNode hierarchy starting from RootNode and tries to find the SceneNode with the nodeName. Null is returned if SceneNode is not found.
            </summary>
            <param name="nodeName">name of the SceneNode to find</param>
            <returns>found SceneNode or null if not found</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.AddRenderingQueueAfter(Ab3d.DirectX.RenderingQueue,Ab3d.DirectX.RenderingQueue)">
            <summary>
            Adds the newRenderQueue after the already registered afterRenderQueue.
            If rendering queue is MaterialSortedRenderingQueue or CameraDistanceSortedRenderingQueue, then also its IsSortingEnabled property is set according to the current DXScene settings.
            </summary>
            <param name="newRenderingQueue">RenderingQueue to add</param>
            <param name="afterRenderingQueue">RenderingQueue that is already registered in the RenderingQueues collection; when null then newRenderingQueue is added as the first rendering queue</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.AddRenderingQueueBefore(Ab3d.DirectX.RenderingQueue,Ab3d.DirectX.RenderingQueue)">
            <summary>
            Adds the newRenderQueue before the already registered afterRenderQueue
            </summary>
            <param name="newRenderingQueue">RenderingQueue to add</param>
            <param name="beforeRenderingQueue">RenderingQueue that is already registered in the RenderingQueues collection</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.RemoveRenderingQueue(Ab3d.DirectX.RenderingQueue)">
            <summary>
            Adds the newRenderQueue before the already registered afterRenderQueue
            </summary>
            <param name="renderingQueueToRemove">RenderingQueue to add</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.CalculateCameraPlanes(Ab3d.DirectX.ICamera,System.Boolean,System.Single@,System.Single@)">
            <summary>
            CalculateCameraPlanes sets the zNear and zFar parameters to camera near plane distance and camera far plane distance.
            The values are calculated with using the bounding box of the current scene and specified camera.
            When adjustValues Boolean parameter is true, the zNear and zFar values are slightly adjusted to increase the distance between zNear and zFar (recommended).
            CalculateCameraPlanes returns false if the calculated values are not correct (are 0, NaN or Infinity). This can happen when camera's matrices are not set.
            </summary>
            <param name="camera">camera as ICamera</param>
            <param name="adjustValues">When adjustValues Boolean parameter is true, the zNear and zFar values are slightly adjusted to increase the distance between zNear and zFar (recommended)</param>
            <param name="zNear">out camera near plane distance</param>
            <param name="zFar">out camera far plane distance</param>
            <returns>returns false if the calculated values are not correct (are 0, NaN or Infinity). This can happen when camera's matrices are not set.</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.CalculateCameraPlanes(SharpDX.Matrix@,System.Boolean,System.Boolean,SharpDX.Vector3[],System.Boolean,System.Single@,System.Single@)">
            <summary>
            CalculateCameraPlanes sets the zNear and zFar parameters to camera near plane distance and camera far plane distance.
            When adjustValues Boolean parameter is true, the zNear and zFar values are slightly adjusted to increase the distance between zNear and zFar (recommended).
            CalculateCameraPlanes returns false if the calculated values are not correct (are 0, NaN or Infinity). This can happen when camera's matrices are not set.
            </summary>
            <param name="viewMatrix">viewMatrix</param>
            <param name="isOrthographicProjection">true if camera is using Orthographic projection, false for Perspective projection</param>
            <param name="isRightHandedCoordinateSystem">true when using right handed coordinate system (true for DXEngine)</param>
            <param name="boundingCorners">array of Vector3 elements that represents corner positions for BoundingBox (use BoundingBox.GetCorners to get this array)</param>
            <param name="adjustValues">When adjustValues Boolean parameter is true, the zNear and zFar values are slightly adjusted to increase the distance between zNear and zFar (recommended)</param>
            <param name="zNear">out camera near plane distance</param>
            <param name="zFar">out camera far plane distance</param>
            <returns>returns false if the calculated values are not correct (are 0, NaN or Infinity). This can happen when camera's matrices are not set.</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.GetRenderingQueuesDumpString(System.Boolean)">
            <summary>
            Returns string that contains details about all objects inside rendering queues.
            </summary>
            <param name="dumpEmptyRenderingQueues">when false (by default) the empty rendering queues are not written to the returned string</param>
            <returns>string that contains details about all objects inside rendering queues.</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.GetRenderingQueuesDumpString(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns string that contains details about all objects inside rendering queues.
            </summary>
            <param name="dumpEmptyRenderingQueues">when false (by default) the empty rendering queues are not written to the returned string</param>
            <param name="showOverview">when true, then first an overview of all RenderingQueues is shown with a number of items in each queue (optional; true by default)</param>
            <param name="showItemsInQueue">when true, then each item in each rendering queue is displayed (optional; true by default)</param>
            <returns>string that contains details about all objects inside rendering queues.</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.GetSceneNodesDumpString(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns string that contains details about all DXScene's SceneNodes and their hierarchy.
            </summary>
            <param name="showBounds">true to show object bounds</param>
            <param name="showTransform">true to show object transformation</param>
            <param name="showDirtyFlags">true to show dirty flags</param>
            <param name="showStatistics">true to show SceneNode statistics (how many SceneNodes there are)</param>
            <returns>string that contains details about all DXScene's SceneNodes and their hierarchy.</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.GetSceneNodesDumpString(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns string that contains details about all DXScene's SceneNodes and their hierarchy.
            </summary>
            <param name="showBounds">true to show object bounds</param>
            <param name="showTransform">true to show object transformation</param>
            <param name="showDirtyFlags">true to show dirty flags</param>
            <param name="showStatistics">true to show SceneNode statistics (how many SceneNodes there are)</param>
            <param name="showMaterialInfo">true to show material info</param>
            <param name="showMeshInfo">true to show mesh info</param>
            <returns>string that contains details about all DXScene's SceneNodes and their hierarchy.</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.LogUserMessage(System.String)">
            <summary>
            LogUserLabel can be used to add custom user message to DXEngine log file.
            This method work only with debug DXEngine build and with enabled logging. It added the "USER MESSAGE: " prefix to log entry.
            </summary>
            <param name="message">user message that will be added to log file</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.DumpRenderingQueues">
            <summary>
            Writes string that contains details about all objects inside rendering queues to the console (when the application is debugged in Visual Studio the string is written to Output window).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.DumpSceneNodes(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Writes string that contains details about all DXScene's SceneNodes and their hierarchy to the console (when the application is debugged in Visual Studio the string is written to Output window).
            </summary>
            <param name="showBounds">true to show object bounds</param>
            <param name="showTransform">true to show object transformation</param>
            <param name="showDirtyFlags">true to show dirty flags</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.DisposeBackBuffers">
            <summary>
            Disposes the back buffers and views that are defined in this DXScene
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.DXScene.DXHitTestOptions">
            <summary>
            DXHitTestOptions specifies hit testing parameters that are used with DXScene's hit testing.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.GetClosestHitObject(SharpDX.Ray,Ab3d.DirectX.SceneNode)">
            <summary>
            GetClosestHitObject method executes a hit testing on the SceneNodes in this DXScene (or when specified on rootSceneNode and its children) and returns a <see cref="T:Ab3d.DirectX.DXRayHitTestResult" /> object with the closest triangle hit by the specified ray.
            When no triangle is hit, null is returned.
            </summary>
            <remarks>
                <para>
            HitTest method executes a hit testing on the SceneNodes in this DXScene (or when specified on rootSceneNode and its children) and returns <see cref="T:Ab3d.DirectX.DXRayHitTestResult" /> object with the closest triangle hit by the specified ray.
            When no triangle is hit, null is returned.
            </para>
                <para>
            It is possible to adjust hit testing with changing the value in the <see cref="P:Ab3d.DirectX.DXScene.DXHitTestOptions" /> property.
            </para>
                <para>
            To get all hit results, use the <see cref="M:Ab3d.DirectX.DXScene.GetAllHitObjects(SharpDX.Ray,Ab3d.DirectX.SceneNode)" /> method.
            </para>
            </remarks>
            <param name="ray">SharpDX.Ray object that defines the ray that is used for hit testing</param>
            <param name="rootSceneNode">SceneNode where the hit testing begins and continues to SceneNode's children. When not set or null, then DXScene.RootNode is used (optional)</param>
            <returns>DXRayHitTestResult with the closest hit object or null if no object was hit</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.GetAllHitObjects(SharpDX.Ray,Ab3d.DirectX.SceneNode)">
            <summary>
            GetAllHitObjects method executes a hit testing on the SceneNodes in this DXScene (or when specified on rootSceneNode and its children) and returns a list of <see cref="T:Ab3d.DirectX.DXRayHitTestResult" /> objects sorted from the closest to the farthest object.
            When no object is hit, an empty list is returned.
            </summary>
            <remarks>
                <para>
            GetAllHitObjects method executes a hit testing on the SceneNodes in this DXScene (or when specified on rootSceneNode and its children) and returns a list of <see cref="T:Ab3d.DirectX.DXRayHitTestResult" /> objects sorted from the closest to the farthest object.
            When no triangle is hit, an empty list is returned.
            </para>
                <para>
            It is possible to adjust hit testing with changing the value in the <see cref="P:Ab3d.DirectX.DXScene.DXHitTestOptions" /> property.
            </para>
                <para>
            To get only the closest hit result, use the <see cref="M:Ab3d.DirectX.DXScene.GetClosestHitObject(SharpDX.Ray,Ab3d.DirectX.SceneNode)" /> method.
            </para>
            </remarks>
            <param name="ray">SharpDX.Ray object that defines the ray that is used for hit testing</param>
            <param name="rootSceneNode">SceneNode where the hit testing begins and continues to SceneNode's children. When not set or null, then DXScene.RootNode is used (optional)</param>
            <returns>a list of DXRayHitTestResult objects or an empty list when no object is hit</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.HitTestSceneNode(SharpDX.Ray,Ab3d.DirectX.SceneNode)">
            <summary>
            Returns DXRayHitTestResult if the specified ray hits the specified sceneNode. Otherwise null is returned.
            Child SceneNodes are not tested.
            </summary>
            <param name="ray">SharpDX.Ray object that defines the ray that is used for hit testing</param>
            <param name="sceneNode">tested SceneNode</param>
            <returns>DXRayHitTestResult if the specified ray hits the specified sceneNode. Otherwise null is returned</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.GetHitSceneNodeBounds(SharpDX.Ray,Ab3d.DirectX.SceneNode)">
            <summary>
            GetHitSceneNodeBounds returns a List of SceneNode objects where the ray intersects the BoundingBox of the SceneNode.
            </summary>
            <param name="ray">SharpDX.Ray object that defines the ray that is used for hit testing</param>
            <param name="rootSceneNode">SceneNode where the hit testing begins and continues to SceneNode's children. When not set or null, then DXScene.RootNode is used (optional)</param>
            <returns>a List of SceneNode objects where the ray intersects the BoundingBox of the SceneNode</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.TransformRay(SharpDX.Ray@,SharpDX.Matrix@)">
            <summary>
            Transforms the specified ray with the specified matrix.
            The transformation is done with transforming the ray's position and its direction (direction is transformed without translation).
            </summary>
            <param name="ray">Ray</param>
            <param name="matrix">Matrix</param>
            <returns>transformed ray</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.RenderScene(System.Boolean)">
            <summary>
            Renders the scene.
            If forceRenderAll is true, then the RenderingQueues are always regenerated and the scene is always rendered (use <see cref="M:Ab3d.DirectX.DXScene.RenderScene(System.Boolean,System.Boolean)" /> to control regeneration of rendering queues).
            </summary>
            <param name="forceRenderAll">when false the scene will not be rendered if there are no changes; when true the RenderingQueues are always regenerated and the scene is always rendered.</param>
            <returns>true if scene was rendered</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.RenderScene(System.Boolean,System.Boolean)">
            <summary>
            RenderScene rendered the scene.
            If forceRender is false then the scene is rendered only if there are any changes in the scene nodes.
            If forceUpdate is true then the RenderingQueues are always regenerated (otherwise RenderingQueues are regenerated only when this is required because of the changes).
            </summary>
            <param name="forceRender">if true than scene is rendered even if there are no scene changes</param>
            <param name="forceUpdate">if true then the RenderingQueues are always regenerated (otherwise RenderingQueues are regenerated only when this is required because of the changes)</param>
            <returns>true if scene was rendered</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.RenderScene(Ab3d.DirectX.RenderingContext,System.Boolean)">
            <summary>
            Renders the scene with using custom RenderingContext.
            This allows rendering to custom buffers and render targets.
            </summary>
            <param name="renderingContext">custom RenderingContext</param>
            <param name="forceUpdate">if true (by default) then the RenderingQueues are always regenerated (otherwise RenderingQueues are regenerated only when this is required because of the changes)</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.RenderScene(Ab3d.DirectX.DXScene,System.Boolean,System.Boolean)">
            <summary>
            Renders the scene to the back buffers and with using cameras defined in childDXScene.
            </summary>
            <param name="childDXScene">DXScene that defines the back buffers and cameras</param>
            <param name="forceRender">if true than scene is rendered even if there are no scene changes</param>
            <param name="forceUpdate">if true then the RenderingQueues are always regenerated (otherwise RenderingQueues are regenerated only when this is required because of the changes)</param>
            <remarks>true if scene was rendered</remarks>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.RenderToBitmap(System.Int32,System.Int32,System.Int32,Ab3d.DirectX.BackBufferReadyEventHandler)">
            <summary>
            RenderToBitmap renders the 3D scene to bitmap with specified width, height and multisampling count (used if possible).
            When the scene is rendered the renderedTextureReadyCallback delegate is called - here it is possible to read the memory with the rendered buffer.
            </summary>
            <param name="width">width of the rendered bitmap</param>
            <param name="height">height of the rendered bitmap</param>
            <param name="preferedMultisampling">multisampling count that is used to render the image (used if possible)</param>
            <param name="renderedTextureReadyCallback">Delegate that is called when the scene is rendered. In this delegate it is possible to read the memory with the rendered buffer.</param>
            <example>
                <para>
            The following code uses RenderToBitmap to render to WPF's WriteableBitmap:
            </para>
                <code>
            var writeableBitmap = new WriteableBitmap(width, height, 96, 96, PixelFormats.Bgra32, null);
            this.DXScene.RenderToBitmap(width, height, preferedMultisampling, delegate (object sender, BackBufferReadyEventArgs e)
            {
                // delegate used by RenderToBitmap method - it is called when the scene is rendered to back buffer and it is available in main CPU memory
                writeableBitmap.Lock();
            
                var viewportRect = new Int32Rect(0, 0, e.Width, e.Height);
            
                // Copy bitmap from e.Data.DataPointer to writeableBitmap
                writeableBitmap.WritePixels(viewportRect, e.Data.DataPointer, e.Data.SlicePitch, e.Data.RowPitch);
            
                writeableBitmap.AddDirtyRect(viewportRect);
                writeableBitmap.Unlock();
            });
            </code>
            </example>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.RenderToBitmap(System.Int32,System.Int32,System.Int32,System.Int32,Ab3d.DirectX.BackBufferReadyEventHandler)">
            <summary>
            RenderToBitmap renders the 3D scene to bitmap with specified width, height and multisampling count (used if possible).
            When the scene is rendered the renderedTextureReadyCallback delegate is called - here it is possible to read the memory with the rendered buffer.
            </summary>
            <param name="width">width of the rendered bitmap</param>
            <param name="height">height of the rendered bitmap</param>
            <param name="preferedMultisampling">multisampling count that is used to render the image (used if possible)</param>
            <param name="supersamplingCount">super-sampling count (possible values: 1 no super-sampling, 4, 16, 64)</param>
            <param name="renderedTextureReadyCallback">Delegate that is called when the scene is rendered. In this delegate it is possible to read the memory with the rendered buffer.</param>
            <example>
                <para>
            The following code uses RenderToBitmap to render to WPF's WriteableBitmap:
            </para>
                <code>
            var writeableBitmap = new WriteableBitmap(width, height, 96, 96, PixelFormats.Bgra32, null);
            this.DXScene.RenderToBitmap(width, height, preferedMultisampling, delegate (object sender, BackBufferReadyEventArgs e)
            {
                // delegate used by RenderToBitmap method - it is called when the scene is rendered to back buffer and it is available in main CPU memory
                writeableBitmap.Lock();
            
                var viewportRect = new Int32Rect(0, 0, e.Width, e.Height);
            
                // Copy bitmap from e.Data.DataPointer to writeableBitmap
                writeableBitmap.WritePixels(viewportRect, e.Data.DataPointer, e.Data.SlicePitch, e.Data.RowPitch);
            
                writeableBitmap.AddDirtyRect(viewportRect);
                writeableBitmap.Unlock();
            });
            </code>
            </example>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.CreateCustomRenderingContext(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32)">
            <summary>
            Creates a <see cref="T:Ab3d.DirectX.CustomRenderingContext" /> from the specified back buffer, its render target view and depthStencilView.
            The created CustomRenderingContext can be used in <see cref="M:Ab3d.DirectX.DXScene.RenderScene(Ab3d.DirectX.RenderingContext,System.Boolean)" /> or <see cref="M:Ab3d.DirectX.DXScene.RenderScene(Ab3d.DirectX.RenderingContext,System.Boolean,System.Boolean,Ab3d.DirectX.DXScene)" /> methods.
            </summary>
            <param name="backBuffer">backBuffer</param>
            <param name="backBufferDescription">backBufferDescription</param>
            <param name="backBufferRenderTargetView">backBufferRenderTargetView</param>
            <param name="depthStencilView">depthStencilView</param>
            <param name="supersamplingCount">super-sampling count of the specified back buffer</param>
            <returns>CustomRenderingContext with all needed DirectX buffers and views</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.CreateCustomRenderingContext(System.Int32,System.Int32,System.Int32,Ab3d.DirectX.BackBufferReadyEventHandler,Ab3d.DirectX.DisposeList@)">
            <summary>
             Creates a <see cref="T:Ab3d.DirectX.CustomRenderingContext" /> with all needed DirectX buffers and views that can be used to call RenderScene with custom RenderingContext.
             The created RenderingContext can be used in <see cref="M:Ab3d.DirectX.DXScene.RenderScene(Ab3d.DirectX.RenderingContext,System.Boolean)" /> or <see cref="M:Ab3d.DirectX.DXScene.RenderScene(Ab3d.DirectX.RenderingContext,System.Boolean,System.Boolean,Ab3d.DirectX.DXScene)" /> methods.
             </summary>
            <param name="width">width of the rendered bitmap</param>
            <param name="height">height of the rendered bitmap</param>
            <param name="preferedMultisampling">multisampling count that is used to render the image (used if possible)</param>
            <param name="renderedTextureReadyCallback">Delegate that is called when the scene is rendered. In this delegate it is possible to read the memory with the rendered buffer.</param>
            <param name="objectsToDispose">DisposeList with all the created objects that need to be disposed when they are no longer used</param>
            <example>
                <para>
             The following example shows how to use CreateCustomRenderingContext to render to WPF's WriteableBitmap:
             </para>
                <code>
             DisposeList objectsToDispose;
             
             int width = 512;
             int height = 512;
             int preferedMultisampling = 4;
             int frameNumber = 1; // increase that on each call
             
             var writeableBitmap = new WriteableBitmap(width, height, 96, 96, PixelFormats.Bgra32, null);
             
             // Create custom RenderingContext with the required buffers and other resources - stored in objectsToDispose
             // Also define the callback method that will be called when the rendered image is available in main CPU memory
             var renderingContext = CreateCustomRenderingContext(
                   width, 
                   height, 
                   preferedMultisampling, 
                   delegate (object sender, BackBufferReadyEventArgs e)
                   {
                       // delegate used by RenderToBitmap method - it is called when the scene is rendered to back buffer and it is available in main CPU memory
                       writeableBitmap.Lock();
            
                       var viewportRect = new Int32Rect(0, 0, e.Width, e.Height);
            
                       // Copy bitmap from e.Data.DataPointer to writeableBitmap
                       writeableBitmap.WritePixels(viewportRect, e.Data.DataPointer, e.Data.SlicePitch, e.Data.RowPitch);
            
                       writeableBitmap.AddDirtyRect(viewportRect);
                       writeableBitmap.Unlock();
                   },
                   out objectsToDispose);
            
             // Make sure that frameNumber is increased on each call to ensure that update is called
             renderingContext.SetPerFrameData(frameNumber, ChangeNotifications.All);
            
             // render the scene with custom RenderingContext
             RenderScene(renderingContext);
            
             objectsToDispose.Dispose();
             </code>
            </example>
            <returns>CustomRenderingContext with all needed DirectX buffers and views</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.CreateCustomRenderingContext(System.Int32,System.Int32,System.Int32,SharpDX.DXGI.Format,SharpDX.DXGI.Format,Ab3d.DirectX.BackBufferReadyEventHandler,Ab3d.DirectX.DisposeList@)">
            <summary>
            Creates a <see cref="T:Ab3d.DirectX.CustomRenderingContext" /> with all needed DirectX buffers and views that can be used to call RenderScene with custom RenderingContext.
            The created RenderingContext can be used in <see cref="M:Ab3d.DirectX.DXScene.RenderScene(Ab3d.DirectX.RenderingContext,System.Boolean)" /> or <see cref="M:Ab3d.DirectX.DXScene.RenderScene(Ab3d.DirectX.RenderingContext,System.Boolean,System.Boolean,Ab3d.DirectX.DXScene)" /> methods.
            </summary>
            <param name="width">width of the rendered bitmap</param>
            <param name="height">height of the rendered bitmap</param>
            <param name="preferedMultisampling">multisampling count that is used to render the image (used if possible)</param>
            <param name="backBufferFormat">format of back buffer (DXEngine by default usues Format.B8G8R8A8_UNorm that is required for the texture to be shader by by WPF)</param>
            <param name="depthStencilFormat">format of depth stencil buffer (DXEngine by default usues Format.D32_Float)</param>
            <param name="renderedTextureReadyCallback">Delegate that is called when the scene is rendered. In this delegate it is possible to read the memory with the rendered buffer.</param>
            <param name="objectsToDispose">DisposeList with all the created objects that need to be disposed when they are no longer used</param>
            <example>
                <para>
            The following example shows how to use CreateCustomRenderingContext to render to WPF's WriteableBitmap:
            </para>
                <code>
            DisposeList objectsToDispose;
            
            int width = 512;
            int height = 512;
            int preferedMultisampling = 4;
            int frameNumber = 1; // increase that on each call
            
            var writeableBitmap = new WriteableBitmap(width, height, 96, 96, PixelFormats.Bgra32, null);
            
            // Create custom RenderingContext with the required buffers and other resources - stored in objectsToDispose
            // Also define the callback method that will be called when the rendered image is available in main CPU memory
            var renderingContext = CreateCustomRenderingContext(
                  width, 
                  height, 
                  preferedMultisampling, 
                  Format.B8G8R8A8_UNorm,
                  Format.D32_Float,
                  delegate (object sender, BackBufferReadyEventArgs e)
                  {
                      // delegate used by RenderToBitmap method - it is called when the scene is rendered to back buffer and it is available in main CPU memory
                      writeableBitmap.Lock();
            
                      var viewportRect = new Int32Rect(0, 0, e.Width, e.Height);
            
                      // Copy bitmap from e.Data.DataPointer to writeableBitmap
                      writeableBitmap.WritePixels(viewportRect, e.Data.DataPointer, e.Data.SlicePitch, e.Data.RowPitch);
            
                      writeableBitmap.AddDirtyRect(viewportRect);
                      writeableBitmap.Unlock();
                  },
                  out objectsToDispose);
            
            // Make sure that frameNumber is increased on each call to ensure that update is called
            renderingContext.SetPerFrameData(frameNumber, ChangeNotifications.All);
            
            // render the scene with custom RenderingContext
            RenderScene(renderingContext);
            
            objectsToDispose.Dispose();
            </code>
            </example>
            <returns>CustomRenderingContext with all needed DirectX buffers and views</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.CreateCustomRenderingContext(System.Int32,System.Int32,System.Int32,SharpDX.DXGI.Format,SharpDX.DXGI.Format,Ab3d.DirectX.BackBufferReadyEventHandler,Ab3d.DirectX.VirtualRealityProviderBase,Ab3d.DirectX.DisposeList@)">
            <summary>
            Creates a <see cref="T:Ab3d.DirectX.CustomRenderingContext" /> with all needed DirectX buffers and views that can be used to call RenderScene with custom RenderingContext.
            The created RenderingContext can be used in <see cref="M:Ab3d.DirectX.DXScene.RenderScene(Ab3d.DirectX.RenderingContext,System.Boolean)" /> or <see cref="M:Ab3d.DirectX.DXScene.RenderScene(Ab3d.DirectX.RenderingContext,System.Boolean,System.Boolean,Ab3d.DirectX.DXScene)" /> methods.
            </summary>
            <param name="width">width of the rendered bitmap</param>
            <param name="height">height of the rendered bitmap</param>
            <param name="preferedMultisampling">multisampling count that is used to render the image (used if possible)</param>
            <param name="backBufferFormat">format of back buffer (DXEngine by default usues Format.B8G8R8A8_UNorm that is required for the texture to be shader by by WPF)</param>
            <param name="depthStencilFormat">format of depth stencil buffer (DXEngine by default usues Format.D32_Float)</param>
            <param name="renderedTextureReadyCallback">Delegate that is called when the scene is rendered. In this delegate it is possible to read the memory with the rendered buffer.</param>
            <param name="virtualRealityProvider">VirtualRealityProviderBase or null</param>
            <param name="objectsToDispose">DisposeList with all the created objects that need to be disposed when they are no longer used</param>
            <example>
                <para>
            The following example shows how to use CreateCustomRenderingContext to render to WPF's WriteableBitmap:
            </para>
                <code>
            DisposeList objectsToDispose;
            
            int width = 512;
            int height = 512;
            int preferedMultisampling = 4;
            int frameNumber = 1; // increase that on each call
            
            var writeableBitmap = new WriteableBitmap(width, height, 96, 96, PixelFormats.Bgra32, null);
            
            // Create custom RenderingContext with the required buffers and other resources - stored in objectsToDispose
            // Also define the callback method that will be called when the rendered image is available in main CPU memory
            var renderingContext = CreateCustomRenderingContext(
                  width, 
                  height, 
                  preferedMultisampling, 
                  Format.B8G8R8A8_UNorm,
                  Format.D32_Float,
                  delegate (object sender, BackBufferReadyEventArgs e)
                  {
                      // delegate used by RenderToBitmap method - it is called when the scene is rendered to back buffer and it is available in main CPU memory
                      writeableBitmap.Lock();
            
                      var viewportRect = new Int32Rect(0, 0, e.Width, e.Height);
            
                      // Copy bitmap from e.Data.DataPointer to writeableBitmap
                      writeableBitmap.WritePixels(viewportRect, e.Data.DataPointer, e.Data.SlicePitch, e.Data.RowPitch);
            
                      writeableBitmap.AddDirtyRect(viewportRect);
                      writeableBitmap.Unlock();
                  },
                  out objectsToDispose);
            
            // Make sure that frameNumber is increased on each call to ensure that update is called
            renderingContext.SetPerFrameData(frameNumber, ChangeNotifications.All);
            
            // render the scene with custom RenderingContext
            RenderScene(renderingContext);
            
            objectsToDispose.Dispose();
            </code>
            </example>
            <returns>CustomRenderingContext with all needed DirectX buffers and views</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.CreateCustomRenderingContext(System.Int32,System.Int32,System.Int32,System.Int32,SharpDX.DXGI.Format,SharpDX.DXGI.Format,Ab3d.DirectX.BackBufferReadyEventHandler,Ab3d.DirectX.VirtualRealityProviderBase,Ab3d.DirectX.DisposeList@)">
            <summary>
            Creates a <see cref="T:Ab3d.DirectX.CustomRenderingContext" /> with all needed DirectX buffers and views that can be used to call RenderScene with custom RenderingContext.
            The created RenderingContext can be used in <see cref="M:Ab3d.DirectX.DXScene.RenderScene(Ab3d.DirectX.RenderingContext,System.Boolean)" /> or <see cref="M:Ab3d.DirectX.DXScene.RenderScene(Ab3d.DirectX.RenderingContext,System.Boolean,System.Boolean,Ab3d.DirectX.DXScene)" /> methods.
            </summary>
            <param name="width">width of the rendered bitmap</param>
            <param name="height">height of the rendered bitmap</param>
            <param name="preferedMultisampling">multisampling count that is used to render the image (used if possible)</param>
            <param name="supersamplingCount">super-sampling count (possible values: 1 no super-sampling, 4, 16, 64)</param>
            <param name="backBufferFormat">format of back buffer (DXEngine by default usues Format.B8G8R8A8_UNorm that is required for the texture to be shader by by WPF)</param>
            <param name="depthStencilFormat">format of depth stencil buffer (DXEngine by default usues Format.D32_Float)</param>
            <param name="renderedTextureReadyCallback">Delegate that is called when the scene is rendered. In this delegate it is possible to read the memory with the rendered buffer.</param>
            <param name="virtualRealityProvider">VirtualRealityProviderBase or null</param>
            <param name="objectsToDispose">DisposeList with all the created objects that need to be disposed when they are no longer used</param>
            <example>
                <para>
            The following example shows how to use CreateCustomRenderingContext to render to WPF's WriteableBitmap:
            </para>
                <code>
            DisposeList objectsToDispose;
            
            int width = 512;
            int height = 512;
            int preferedMultisampling = 4;
            int frameNumber = 1; // increase that on each call
            
            var writeableBitmap = new WriteableBitmap(width, height, 96, 96, PixelFormats.Bgra32, null);
            
            // Create custom RenderingContext with the required buffers and other resources - stored in objectsToDispose
            // Also define the callback method that will be called when the rendered image is available in main CPU memory
            var renderingContext = CreateCustomRenderingContext(
                  width, 
                  height, 
                  preferedMultisampling,
                  supersamplingCount,
                  Format.B8G8R8A8_UNorm,
                  Format.D32_Float,
                  delegate (object sender, BackBufferReadyEventArgs e)
                  {
                      // delegate used by RenderToBitmap method - it is called when the scene is rendered to back buffer and it is available in main CPU memory
                      writeableBitmap.Lock();
            
                      var viewportRect = new Int32Rect(0, 0, e.Width, e.Height);
            
                      // Copy bitmap from e.Data.DataPointer to writeableBitmap
                      writeableBitmap.WritePixels(viewportRect, e.Data.DataPointer, e.Data.SlicePitch, e.Data.RowPitch);
            
                      writeableBitmap.AddDirtyRect(viewportRect);
                      writeableBitmap.Unlock();
                  },
                  out objectsToDispose);
            
            // Make sure that frameNumber is increased on each call to ensure that update is called
            renderingContext.SetPerFrameData(frameNumber, ChangeNotifications.All);
            
            // render the scene with custom RenderingContext
            RenderScene(renderingContext);
            
            objectsToDispose.Dispose();
            </code>
            </example>
            <returns>CustomRenderingContext with all needed DirectX buffers and views</returns>
        </member>
        <member name="T:Ab3d.DirectX.DXScene.ChangeNotifications">
            <summary>
            ChangeNotifications enum defines flags that describe what changes have occur in the DXScene from last time the scene was rendered.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.CameraChanged">
            <summary>
            CameraChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.LightPropertiesChanged">
            <summary>
            LightPropertiesChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.IsEnabledChanged">
            <summary>
            IsEnabledChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.LightsCountChanged">
            <summary>
            LightsCountChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.EffectsChanged">
            <summary>
            EffectsChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.MaterialPropertiesChanged">
            <summary>
            MaterialPropertiesChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.SceneBoundsChanged">
            <summary>
            SceneBoundsChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.SceneNodesCountChanged">
            <summary>
            SceneNodesCountChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.SceneNodesPositionChanged">
            <summary>
            SceneNodesPositionChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.SceneNodesPropertiesChanged">
            <summary>
            SceneNodesPropertiesChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.SceneNodesVisibilityChanged">
            <summary>
            SceneNodesVisibilityChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.RenderingPrimitivePropertiesChanged">
            <summary>
            Properties of RenderingPrimitive has changed. This does not require recollecting rendering primitives.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.RenderingPrimitiveDirty">
            <summary>
            RenderingPrimitive has changed so much that it requires recollecting rendering primitives.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.MeshChanged">
            <summary>
            MeshChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.MeshVertexBufferDataChanged">
            <summary>
            MeshVertexBufferDataChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.SceneNodesWorldMatrixChanged">
            <summary>
            SceneNodesWorldMatrixChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.SizeChanged">
            <summary>
            SizeChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.BackgroundColorChanged">
            <summary>
            BackgroundColorChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.ShaderSettingsChanged">
            <summary>
            ShaderSettingsChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.RenderingStepsChanged">
            <summary>
            RenderingStepsChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.PostProcessChanged">
            <summary>
            PostProcessChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.VirtualRealitySettingsChanged">
            <summary>
            VirtualRealitySettingsChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.ShadowRenderingSettingsChanged">
            <summary>
            ShadowRenderingSettingsChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.RenderToBitmap">
            <summary>
            RenderToBitmap - used in RenderingContext.RenderReason when RenderToBitmap method is used.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.ViewChanged">
            <summary>
            ViewChanged - used when the same scene is rendered to a different view.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.OtherChange">
            <summary>
            OtherChange
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.DXScene.ChangeNotifications.All">
            <summary>
            All
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.NotifyChange(Ab3d.DirectX.DXScene.ChangeNotifications)">
            <summary>
            NotifyChange method adds the specified ChangeNotifications to all the changes flags
            </summary>
            <param name="changeType">ChangeNotifications</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.NotifyChange(Ab3d.DirectX.DXScene.ChangeNotifications,System.Object)">
            <summary>
            NotifyChange method adds the specified ChangeNotifications to all the changes flags
            </summary>
            <param name="changeType">ChangeNotifications</param>
            <param name="changedObject">object that produced the change (optional)</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.HasDirtyFlag(Ab3d.DirectX.DXScene.ChangeNotifications)">
            <summary>
            Returns true if this DXScene has the flags from the method argument set.
            Note that if this value is checked before the Update phase is completed, then the value may not have the final value (but it has the camera and light changed flags already set).
            </summary>
            <param name="flags">ChangeNotifications</param>
            <returns>true if this DXScene has the flags from the method argument set</returns>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.ClearChangeFlag(Ab3d.DirectX.DXScene.ChangeNotifications)">
            <summary>
            Removes the specified ChangeNotifications from the current changes flags
            </summary>
            <param name="changeTypeToClear">ChangeNotifications</param>
        </member>
        <member name="M:Ab3d.DirectX.DXScene.Update">
            <summary>
            Update calls Update method on all child nodes.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.IRayHitTestedObject">
            <summary>
            IRayHitTestedObject interface can be implemented by a objects that supports hit testing.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.IRayHitTestedObject.GetClosestHitResult(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext)">
            <summary>
            GetClosestHitResult method returns a <see cref="T:Ab3d.DirectX.DXRayHitTestResult" /> with the closest triangle hit by the specified ray.
            When no triangle is hit, null is returned.
            </summary>
            <param name="localRay">SharpDX.Ray in local SceneNode coordinate system</param>
            <param name="hitTestContext">DXHitTestContext</param>
            <returns>DXRayHitTestResult with the closest triangle hit or null when no triangle is hit</returns>
        </member>
        <member name="M:Ab3d.DirectX.IRayHitTestedObject.GetNextHitResult(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext,Ab3d.DirectX.DXRayHitTestResult)">
            <summary>
            GetNextHitResult method continues hit testing from the previously returned hit test and returns a <see cref="T:Ab3d.DirectX.DXRayHitTestResult" />
            with the next hit triangle (not necessary the next closest triangle) or null if no other triangle is hit.
            This method can be used to get all hit results.
            </summary>
            <param name="localRay">SharpDX.Ray in local SceneNode coordinate system</param>
            <param name="hitTestContext">DXHitTestContext</param>
            <param name="previousHitResult">DXRayHitTestResult as result of the previous call to GetNextHitResult method or null if this is the first time this method is called</param>
            <returns>DXRayHitTestResult with the next triangle hit or null when no triangle is hit</returns>
        </member>
        <member name="T:Ab3d.DirectX.IShadowCastingNode">
            <summary>
            IShadowCastingNode interface is implemented by a <see cref="T:Ab3d.DirectX.SceneNode" /> that can cast shadow and implements the <see cref="P:Ab3d.DirectX.IShadowCastingNode.IsCastingShadow" /> property.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.IShadowCastingNode.IsCastingShadow">
            <summary>
            Gets or sets a Boolean that specifies if this SceneNode is casing shadow.
            This means that if IsCastingShadow is true, then 3D objects rendered with this SceneNode will create shadow; 
            if false shadow will not be created.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.IShadowReceivingNode">
            <summary>
            IShadowReceivingNode interface is implemented by a <see cref="T:Ab3d.DirectX.SceneNode" /> that can receive shadow and implements the <see cref="P:Ab3d.DirectX.IShadowReceivingNode.IsReceivingShadow" /> property.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.IShadowReceivingNode.IsReceivingShadow">
            <summary>
            Gets or sets a Boolean that specifies if this SceneNode can receive shadow - this means that the shadow is rendered on the object(s) rendered by this SceneNode.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.MeshObjectNode">
            <summary>
            MeshObjectNode is an <see cref="T:Ab3d.DirectX.ObjectNode" /> that can render an object that is defined by object derived from <see cref="T:Ab3d.DirectX.MeshBase" /> class.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshObjectNode.Mesh">
            <summary>
            Gets a Mesh that defines the 3D object geometry.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshObjectNode.Materials">
            <summary>
            Gets or sets an array of Material that can be set to override the materials defined in the Mesh.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshObjectNode.IsCastingShadow">
            <summary>
            Gets or sets a Boolean that specifies if this SceneNode is casing shadow.
            This means that if IsCastingShadow is true, then 3D objects rendered with this SceneNode will create shadow; 
            if false shadow will not be created. True by default.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.MeshObjectNode.IsReceivingShadow">
            <summary>
            Gets or sets a Boolean that specifies if this SceneNode can receive shadow - this means that the shadow is rendered on the object(s) rendered by this SceneNode.
            NOTE: For the shadow to be visible, the effect that is used to render this mesh needs to support rendering shadows. True by default.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.MeshObjectNode.IsBackFaceMaterial">
            <summary>
            IsBackFaceMaterial specifies if the material is used to render front (IsBackFaceMaterial == false) or back (IsBackFaceMaterial == true) faces.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.#ctor(Ab3d.DirectX.MeshBase)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.MeshObjectNode" /> class.
            </summary>
            <param name="meshBase">MeshBase object that defines the 3D object geometry</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.#ctor(Ab3d.DirectX.MeshBase,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.MeshObjectNode" /> class.
            </summary>
            <param name="meshBase">MeshBase object that defines the 3D object geometry</param>
            <param name="name">optional name of the SceneNode</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.#ctor(Ab3d.DirectX.MeshBase,Ab3d.DirectX.Material,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.MeshObjectNode" /> class.
            </summary>
            <param name="meshBase">MeshBase object that defines the 3D object geometry</param>
            <param name="material">material used by this ObjectNode</param>
            <param name="name">optional name of the SceneNode</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.#ctor(Ab3d.DirectX.MeshBase,Ab3d.DirectX.Material[],System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.MeshObjectNode" /> class.
            </summary>
            <param name="mesh">MeshBase object that defines the 3D object geometry</param>
            <param name="materials">material used by this ObjectNode</param>
            <param name="name">optional name of the SceneNode</param>
            <exception cref="T:System.ArgumentNullException">mesh;mesh is null.</exception>
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.Update">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.UpdateBounds(System.Boolean)">
            <summary>
            Updates the bounds of this SceneNode if the dirty flags indicates that the bounds could be changed of if the forceUpdate parameter is set to true
            </summary>
            <param name="forceUpdate">if true than bounds are updated regardless of the SceneNode's dirty flags</param>
            <returns>true if bounds were changed</returns>
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.UpdateMaterial">
            <summary>
            UpdateMaterial method needs to be called after a material is changed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.UpdateMesh">
            <summary>
            UpdateMesh method needs to be called when the Mesh has been recreated or when SubMeshes data has changed (StartIndexLocation, IndexCount and MaterialIndex do not require regeneration of RenderingQueues).
            This method updates the RenderableMeshPrimitive that was added to the RenderingQueue.
            </summary>
            <remarks>
                <para>
            UpdateMesh method needs to be called when the Mesh has been recreated or when SubMeshes data has changed (StartIndexLocation, IndexCount and MaterialIndex do not require regeneration of RenderingQueues).
            </para>
                <para>
            This method updates the RenderableMeshPrimitive that was added to the RenderingQueue.
            </para>
                <para>
            This call can set the following DirtyFlags on this SceneNode:<br />
            - <see cref="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.MeshVertexBufferDataChanged" /> when this mesh was already shown and when only vertex buffer is changed - no need to regenerate the RenderingQueues<br />
            - <see cref="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.MeshIndexBufferDataChanged" /> when this mesh was already shown and when only SubMesh data are changed - no need to regenerate the RenderingQueues<br />
            - <see cref="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.MeshChanged" /> when RenderingQueues need to be regenerated
            </para>
            </remarks>
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.OnWorldMatrixChanged">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.OnInitializeResources(Ab3d.DirectX.DXScene)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.CollectRenderableObjects">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.OnIsVisibleChanged(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.GetClosestHitResult(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.GetNextHitResult(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext,Ab3d.DirectX.DXRayHitTestResult)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.GetDetailsText(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns a string with detailed description of this SceneNode.
            </summary>
            <param name="showBounds">true to show bounds information</param>
            <param name="showTransform">true to show transformation information</param>
            <param name="showDirtyFlags">true to show dirty flags value</param>
            <param name="showMaterialInfo">true to show material info</param>
            <param name="showMeshInfo">true to show mesh info</param>
            <returns>string with detailed description of this object node</returns>
        </member>
        <member name="M:Ab3d.DirectX.MeshObjectNode.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.ObjectNode">
            <summary>
            ObjectNode is a <see cref="T:Ab3d.DirectX.SceneNode" /> that is used by scene nodes that can produce renderable objects (objects derived from RenderablePrimitiveBase class).
            Renderable objects are defined in the overridden <see cref="M:Ab3d.DirectX.ObjectNode.CollectRenderableObjects" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ObjectNode.IsAutomaticallyCollectingRenderableObjectsForChildNodes">
            <summary>
            Gets or sets a Boolean that specifies if CollectRenderableObjects will be automatically called for all ChildNodes of this ObjectNode. Default value is true.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ObjectNode.CustomRenderingQueue">
            <summary>
            Gets or sets a custom RenderingQueue that will contain the RenderablePrimitiveBase objects created by this ObjectNode.
            If CustomRenderingQueue is null, then the ObjectNode will be put into <see cref="P:Ab3d.DirectX.DXScene.OtherGeometryRenderingQueue" /> or <see cref="P:Ab3d.DirectX.DXScene.TransparentRenderingQueue" /> based on the material.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ObjectNode.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.ObjectNode" /> class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ObjectNode.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.ObjectNode" /> class.
            </summary>
            <param name="name">name</param>
        </member>
        <member name="M:Ab3d.DirectX.ObjectNode.OnCustomRenderingQueueChanged(Ab3d.DirectX.RenderingQueue,Ab3d.DirectX.RenderingQueue)">
            <summary>
            OnCustomRenderingQueueChanged is a virtual protected method that is called when the value of the <see cref="P:Ab3d.DirectX.ObjectNode.CustomRenderingQueue" /> property is changed.
            </summary>
            <param name="oldRenderingQueue">old value of CustomRenderingQueue</param>
            <param name="newRenderingQueue">new value for CustomRenderingQueue</param>
        </member>
        <member name="M:Ab3d.DirectX.ObjectNode.CollectRenderableObjects">
            <summary>
            The task of the CollectRenderableObjects method is to create objects derived from <see href="RenderablePrimitiveBase" />
            and add them to the appropriate <see href="RenderingQueue" />.
            This method is called at the beginning of RenderScene method call
            but only when the scene was significantly changed (number of SceneNodes is changed, material is significantly changed, etc.)
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.RenderingEventHandler">
            <summary>
            RenderingEventHandler is an event handler with RenderingEventArgs as event arguments
            </summary>
            <param name="sender">sender</param>
            <param name="e">RenderingEventArgs</param>
        </member>
        <member name="T:Ab3d.DirectX.RenderingEventArgs">
            <summary>
            RenderingEventArgs contains the <see cref="F:Ab3d.DirectX.RenderingEventArgs.RenderingContext" /> and is used for AfterFrameInitialized and AfterObjectsRendered events on DXScene.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.RenderingEventArgs.RenderingContext">
            <summary>
            RenderingContext
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.RenderingEventArgs.#ctor(Ab3d.DirectX.RenderingContext)">
            <summary>
            Constructor
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="T:Ab3d.DirectX.SceneNode">
            <summary>
            SceneNode class represents a basic component of a 3D scene that is composed of various SceneNodes organized in a hierarchical structure.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.Logger">
            <summary>
            Logger is always null in release build
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags">
            <summary>
            SceneNodeDirtyFlags enum defines the flags that are used to mark which part of the SceneNode was changed (is dirty).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.Unchanged">
            <summary>
            Unchanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.ParentChanged">
            <summary>
            ParentChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.ChildAdded">
            <summary>
            ChildAdded
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.ChildRemoved">
            <summary>
            ChildRemoved
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.ChildMoved">
            <summary>
            ChildMoved
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.ChildChanged">
            <summary>
            ChildMoved
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.IsVisibleChanged">
            <summary>
            IsVisibleChanged
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.TransformChanged">
            <summary>
            Used when Transform on this SceneNode is changed.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.ParentTransformChanged">
            <summary>
            Used when Transformation on a parent SceneNode has changed.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.WorldMatrixChanged">
            <summary>
            Used when the <see cref="F:Ab3d.DirectX.SceneNode.WorldMatrix" /> has changed. Usually the TransformChanged or ParentTransformChanged is set and then this calls the <see cref="M:Ab3d.DirectX.SceneNode.OnWorldMatrixChanged" /> method that sets this flag.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.BoundsChanged">
            <summary>
            The Bounds property has changed (this means that the local bounds that defines the content transformed with local transformation has changed).
            WorldBounds has changed when BoundsChanged or WorldMatrixChanged have changed.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.ChildBoundsChanged">
            <summary>
            Bounds of a child node was changed - the Bounds of this SceneNode need to be updated accordingly.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.MaterialChanged">
            <summary>
            MaterialChanged - recollected rendering primitives. When only simple material property is changed, use the MaterialPropertiesChanged.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.MaterialPropertiesChanged">
            <summary>
            MaterialPropertiesChanged is used to notify that only simple material properties are changed and the there is not need to recollect rendering primitives. To recollect rendering primitives use the MaterialChanged value.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.MeshVertexBufferDataChanged">
            <summary>
            Used when data in VertexBuffer has changed. This change does not require to recollect rendering primitives in RenderingQueues and therefore requires that the VertexBuffer on the used RenderingPrimitive is updated.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.MeshIndexBufferDataChanged">
            <summary>
            Used when data in IndexBuffer has changed or when StartIndexLocation or IndexCount has changed. This change does not require to recollect rendering primitives in RenderingQueues and therefore requires that the VertexBuffer on the used RenderingPrimitive is updated.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.MeshChanged">
            <summary>
            Used when the whole mesh needs to be recreated. This flag recollects the rendering primitives in RenderingQueues.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.RenderingQueueChanged">
            <summary>
            Used when the rendering queue has been changed
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.RenderingPrimitiveDirty">
            <summary>
            RenderingPrimitive changed in such a way that rendering queues need to be recreated.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.OtherChange">
            <summary>
            OtherChange
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.SceneNodeCreated">
            <summary>
            SceneNodeCreated
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.All">
            <summary>
            Everything was changed
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.DirtyFlags">
            <summary>
            Gets the current dirty flags
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.ParentDXScene">
            <summary>
            Gets the parent DXScene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.Transform">
            <summary>
            Gets or sets the Transformation.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.IsWorldMatrixIdentity">
            <summary>
            True if final world matrix (<see cref="F:Ab3d.DirectX.SceneNode.WorldMatrix" />) is identity.
            This field can be checked to skip multipliyng with WorldMatrix.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.WorldMatrix">
            <summary>
            When <see cref="F:Ab3d.DirectX.SceneNode.IsWorldMatrixIdentity" /> is false this field defines the final world matrix that is calculated from the parent's world matrix and this node's transformation matrix.
            When <see cref="F:Ab3d.DirectX.SceneNode.IsWorldMatrixIdentity" /> is true this field has an invalid value (is not set to Identity matrix for performance reasons).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.WorldBounds">
            <summary>
            Bounds with BoundingBox in world coordinates (transformed by parents transformations and transformation on this SceneNode).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.Bounds">
            <summary>
            Bounds (bounding box) of this object in local coordinates (transformed by transformation on this SceneNode but not with parent's transformations).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.IsVisible">
            <summary>
            Gets or sets a Boolean that specified is this SceneNode and its child SceneNodes are visible.
            This property may be true, but if parent's SceneNode is not visible, then this SceneNode will not be actually visible (this can be get from <see cref="P:Ab3d.DirectX.SceneNode.IsActuallyVisible" />).
            When IsVisible is set to false, the DirectX resources created with this SceneNode are not disposed (are still available).
            But when rendering the RenderablePrimitive objects that are created from this SceneNode are skipped when the scene is rendered.
            This makes hiding and showing ob SceneNodes very fast because only the visibility of the RenderablePrimitive is changed.
            If you want to release DirectX resources when hiding the SceneNode, remove it from its parent SceneNode and call Dispose instead of setting IsVisible to false.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.IsActuallyVisible">
            <summary>
            Gets a Boolean that specifies if this SceneNode and its Children are actually visible taking parents visibility into account - this.IsVisible is true and also the parent is visible.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.IsHitTestVisible">
            <summary>
            Gets or sets a Boolean that specifies if this SceneNode and all its child SceneNodes are visible to hit testing (when false, then the object cannot be hit and the testing ray passes through this SceneNode and through its child SceneNodes).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.Tag">
            <summary>
            Tag can contain any arbitrary data.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.ParentNode">
            <summary>
            Gets or sets the parent SceneNode
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.IsLocked">
            <summary>
            Gets or sets a boolean that specified is this SceneNode can be changed or not. If true than this SceneNode cannot be changed any more. 
            This also prevents checking DirtyFlags and calling Update method (calling NotifySceneNodeChange has no effect).
            SceneNode can be made locked with calling Lock method. It can be un-locked with calling UnLock method.
            Note that we can also lock only child nodes with calling LockChildNodes method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.IsChildNodesListLocked">
            <summary>
            Gets a boolean that specifies if ChildNodes for this SceneNode can be changed.
            This property is set to true with calling LockChildNodes method. After locking the child nodes, they cannot be unlocked any more.
            Note that this property is different from IsLocked property - that one prevent any change to SceneNode and can be unlocked.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SceneNode.childNodes">
            <summary>
            Protected list of SceneNodes
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.ChildNodes">
            <summary>
            Gets a readonly collection of child SceneNodes
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SceneNode.ChildNodesCount">
            <summary>
            Gets a number of child SceneNodes count
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.SceneNode.ChildNodesChanged">
            <summary>
            Occurs when list of ChildNode is changed.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.SceneNode.ParentNodeChanged">
            <summary>
            Occurs when <see cref="P:Ab3d.DirectX.SceneNode.ParentNode" /> is changed. 
            Occurs also when this SceneNode is added to the SceneNodes tree for the first time or when it is removed from the SceneNodes tree (ParentNode is set to null).
            This event does not occur when this SceneNode is disposed.
            </summary>
        </member>
        <member name="E:Ab3d.DirectX.SceneNode.ResourcesInitialized">
            <summary>
            ResourcesInitialized event is fried after the OnInitializeResources was called and the DirectX resources were created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.SceneNode" /> class.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.SceneNode" /> class.
            </summary>
            <param name="name">name</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.NotifySceneNodeChange(Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags)">
            <summary>
            Add the SceneNodeDirtyFlags to this SceneNode's DirtyFlags flags.
            This methods also calls NotifyChange on parent DXScene.
            </summary>
            <param name="changeType">SceneNodeDirtyFlags</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.NotifyAllParentSceneNodesChange(Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags,System.Boolean)">
            <summary>
            Add the changeType to all parent SceneNodes.
            This does not change this SceneNode's dirty flags.
            </summary>
            <param name="changeType">SceneNodeDirtyFlags</param>
            <param name="updateOnlyUntilSetFlag">if true, than setting the flag is stopped when a parent with already set flag is found</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.NotifyAllChildSceneNodesChange(Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags,System.Boolean)">
            <summary>
            Add the changeType to all child SceneNodes.
            This does not change this SceneNode's dirty flags.
            </summary>
            <param name="changeType">SceneNodeDirtyFlags</param>
            <param name="updateOnlyUntilSetFlag">if true, than setting the flag is stopped when a child with already set flag is found</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.ClearDirtyFlag(Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags)">
            <summary>
            Removes the dirtyFlagToClear from the current DirtyFlags
            </summary>
            <param name="dirtyFlagToClear">SceneNodeDirtyFlags</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.CleanAllDirtyFlags(System.Boolean)">
            <summary>
            Clean dirty flags on this and child nodes.
            This is called after a frame was rendered.
            </summary>
            <param name="clearChildNodeFlags">true to clear dirty flags from all child nodes also (true by default)</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.Lock">
            <summary>
            Locks the SceneNode which make it unchangable.
            Note that Lock can be called only when the DirtyFlags are Unchanged - there are no changes made on this SceneNode.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.UnLock">
            <summary>
            Unlocks the SceneNode.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.LockChildNodes">
            <summary>
            LockChildNodes method locks ChildNodes and prevents changing them. After locking SceneNodes they cannot be unlocked again.
            This is used mostly by SceneNodes that does not contain any ChildNodes - for example for MeshObjectNode.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.CheckIsChangeAllowed">
            <summary>
            This method throws InvalidOperationException when IsLocked is true.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.CheckIsChildNodeChangeAllowed">
            <summary>
            This method throws InvalidOperationException when IsLocked or IsChildNodesListLocked is true.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.Update">
            <summary>
            Update method is called on each update phase (before render phase)
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.UpdateBounds(System.Boolean)">
            <summary>
            Updates the bounds of this SceneNode if the dirty flags indicates that the bounds could be changed of if the forceUpdate parameter is set to true
            </summary>
            <param name="forceUpdate">if true than bounds are updated regardless of the SceneNode's dirty flags</param>
            <returns>true if bounds were changed</returns>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.GetTotalTransformMatrix(System.Boolean)">
            <summary>
            Returns a SharpDX.Matrix that represents the transformation from the Root SceneNode to this SceneNode.
            The includeThisTransform parameter specifies if transformation from this SceneNode is also included in the returned matrix.
            </summary>
            <param name="includeThisTransform">when true transformation from this SceneNode is also included in the returned matrix; when false only parent transformations are included.</param>
            <returns>transformation matrix as SharpDX.Matrix</returns>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.AddChildren(System.Collections.Generic.IEnumerable{Ab3d.DirectX.SceneNode})">
            <summary>
            Adds child SceneNodes to the ChildNodes collection of this SceneNode
            </summary>
            <param name="childNodesToAdd">IEnumerable of SceneNodes</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.AddChild(Ab3d.DirectX.SceneNode)">
            <summary>
            Adds the specified SceneNode to the ChildNodes collection of this SceneNode
            </summary>
            <param name="childNode">SceneNode that is added to the ChildNodes collection</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.InsertChild(System.Int32,Ab3d.DirectX.SceneNode)">
            <summary>
            Inserts the specified SceneNode to the ChildNodes collection to the specified index
            </summary>
            <param name="index">index at which the child node is inserted; if -1 than the childNode is added to the end</param>
            <param name="childNode">SceneNode that is inserted to the ChildNodes collection</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.RemoveChild(Ab3d.DirectX.SceneNode)">
            <summary>
            Removes the specified SceneNode from the ChildNodes collection
            </summary>
            <param name="childNode">SceneNode that is removed to the ChildNodes collection</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.RemoveChildAt(System.Int32)">
            <summary>
            Removes the SceneNode at the specified index from the ChildNodes collection
            </summary>
            <param name="childIndex">index at which the child node is removed</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.ReplaceChild(Ab3d.DirectX.SceneNode,Ab3d.DirectX.SceneNode)">
            <summary>
            Replaces the currentChildNode with the newChildNode
            </summary>
            <param name="currentChildNode">SceneNode that will be replaced by newChildNode</param>
            <param name="newChildNode">SceneNode that replaces the currentChildNode</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.ReplaceChild(System.Int32,Ab3d.DirectX.SceneNode)">
            <summary>
            Replaces the SceneNode at the specified index with the newChildNode
            </summary>
            <param name="currentChildNodeIndex">index at which the SceneNode is replaced</param>
            <param name="newChildNode">SceneNode that replaces the SceneNode at the specified index</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.GetChildNode(System.Int32)">
            <summary>
            Returns a child SceneNode object with the specified index.
            </summary>
            <param name="index">index of the child SceneNode</param>
            <returns>child SceneNode object with the specified index</returns>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.ClearChildNodes">
            <summary>
            Removes all SceneNodes from the ChildNodes collection
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.FindNode(System.String)">
            <summary>
            Searches the ChildNodes recursively and returns the SceneNode with the specified name if found; else returns null.
            </summary>
            <param name="nodeName">name of the SceneNode</param>
            <returns>SceneNode with the specified name if found; else returns null</returns>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.UpdateWorldMatrix(System.Boolean)">
            <summary>
            UpdateWorldMatrix checks if dirty flags indicate that the final world matrix for this SceneNode needs to be recalculated.
            </summary>
            <param name="forceUpdate">if true than the final world matrix is always recalculated</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.OnWorldMatrixChanged">
            <summary>
            OnWorldMatrixChanged is called from the UpdateWorldMatrix after the WorldMatrix has been changed.
            This method sets the WorldMatrixChanged and RenderingPrimitiveDirty DirtyFlags (later forces regeneration of the RenderingQueues -
            to avoid this do not call the base class and just set the WorldMatrixChanged dirty flags in the derived class).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.UpdateWorldBoundingBox(System.Boolean)">
            <summary>
            Updates the worldBounds field based on the current worldMatrix and Bounds.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.OnDisconnectingFromDXScene">
            <summary>
            OnDisconnectingFromDXScene is called when the SceneNode is about to be disconnected from DXScene (parentDXScene is not yet null).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.OnInitializeResources(Ab3d.DirectX.DXScene)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxScene">Parent DXScene used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.OnResourcesInitialized">
            <summary>
            OnResourcesInitialized fires the ResourcesInitialized event.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.GetAllDescendantNodes">
            <summary>
            Returns an enumerable of this SceneNode and all SceneNode that are children of this SceneNode and its children - gets all SceneNode in the hierarchy tree below this SceneNode as flat IEnumerable.
            </summary>
            <returns>IEnumerable of SceneNodes</returns>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.GetSceneNodesBounds(Ab3d.DirectX.SceneNode,System.Func{Ab3d.DirectX.SceneNode,System.Boolean})">
            <summary>
            Returns the Bounds of the scene nodes that are children of the rootSceneNode. The sceneNodesFilter Func can be used to choose which scene nodes to use.
            </summary>
            <param name="rootSceneNode">root scene node</param>
            <param name="sceneNodesFilter">Func that should return true for all SceneNodes that should be used to calculate Bounds</param>
            <returns>Bounds of the rootSceneNode child nodes</returns>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.OnChildNodesChanged(System.Collections.Specialized.NotifyCollectionChangedAction,Ab3d.DirectX.SceneNode)">
            <summary>
            OnChildNodesChanged
            </summary>
            <param name="action">NotifyCollectionChangedAction</param>
            <param name="changeSceneNode">change SceneNode</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.OnChildNodesChanged(System.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.Generic.IList{Ab3d.DirectX.SceneNode})">
            <summary>
            OnChildNodesChanged
            </summary>
            <param name="action">NotifyCollectionChangedAction</param>
            <param name="changeSceneNodes">IList of changed SceneNode</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.OnParentNodeChanged">
            <summary>
            OnParentNodeChanged
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.OnIsVisibleChanged(System.Boolean)">
            <summary>
            OnIsVisibleChanged is called when IsActuallyVisible property is changed.
            Overridden implementations should update the IsVisible property of the <see cref="T:Ab3d.DirectX.RenderablePrimitiveBase" /> objects that were already added to RenderingQueues.
            </summary>
            <param name="newIsActuallyVisible">new value of IsActuallyVisible property</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.OnParentVisibilityChanged(System.Boolean)">
            <summary>
            OnParentVisibilityChanged is called when parent visibility is changed.
            </summary>
            <param name="newIsParentVisible">new value of parent's IsActuallyVisible property</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.ForEachChildNode``1(System.Action{``0},System.Boolean)">
            <summary>
            ForEachChildNode calls the childNodeFoundAction for each SceneNode of type T that is find in the hierarchy of the child SceneNodes starting at this SceneNode's ChildNodes.
            </summary>
            <typeparam name="T">Type for which the childNodeFoundAction is called (must be derived from SceneNode)</typeparam>
            <param name="childNodeFoundAction">Action that is called for each found SceneNode (the found SceneNode is passed as parameter)</param>
            <param name="enumerateOnlyOneChildrenLevel">when false (by default) then all children of children in all hierarhy levels are enumerated; when true, then only SceneNodes from this.ChildNodes collection will be enumerated</param>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.GetDetailsText(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns string that tells details about this SceneNode
            </summary>
            <param name="showBounds">if true than bounds of this SceneNode is shown</param>
            <param name="showTransform">if true than transformation matrix is shown when set</param>
            <param name="showDirtyFlags">if true than DirtyFlags are shown</param>
            <param name="showMaterialInfo">true to show material info</param>
            <param name="showMeshInfo">true to show mesh info</param>
            <returns>string that tells details about this SceneNode</returns>
        </member>
        <member name="M:Ab3d.DirectX.SceneNode.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.ScreenSpaceLineNode">
            <summary>
            ScreenSpaceLineNode class is an ObjectNode that represent a 3D line that whose thickness is defined in screen space units.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ScreenSpaceLineNode.IsLineStrip">
            <summary>
            Gets a Boolean that specified if positions define connected or disconnected lines:
            when true if lines are connected to each other (the last position of one line is the first position of the next line).
            when false if lines are disconnected (each line has two positions that are not shared with other lines).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ScreenSpaceLineNode.IsLineClosed">
            <summary>
            Gets a Boolean that specified if line positions are closed (the last position should be connected to the first position).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ScreenSpaceLineNode.LineMaterial">
            <summary>
            Gets or sets an array of Material that can be set to override the materials defined in the Mesh.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ScreenSpaceLineNode.Positions">
            <summary>
            Gets an array of Vector3 positions that were used to initialize this ScreenSpaceLineNode.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ScreenSpaceLineNode.IsCastingShadow">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.#ctor(Ab3d.DirectX.ScreenSpaceLineMesh,Ab3d.DirectX.Materials.ILineMaterial,System.String)">
            <summary>
            Constructor that takes already created ScreenSpaceLineMesh and ILineMaterial
            </summary>
            <param name="screenSpaceLineMesh">ScreenSpaceLineMesh</param>
            <param name="lineMaterial">lineMaterial</param>
            <param name="name">name (optional)</param>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.#ctor(SharpDX.Vector3[],System.Boolean,System.Boolean,Ab3d.DirectX.Materials.ILineMaterial,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="positions">positions</param>
            <param name="isLineStrip">true if lines are connected to each other (the last position of one line is the first position of the next line); false if lines are disconnected (each line has two positions that are not shared with other lines)</param>
            <param name="isLineClosed">true if the end of the last line is connected to the beginning of the first line</param>
            <param name="lineMaterial">lineMaterial</param>
            <param name="name">name (optional)</param>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.#ctor(SharpDX.Vector3[],System.Boolean,System.Boolean,SharpDX.Color4,System.Single,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="positions">positions</param>
            <param name="isLineStrip">if true then one line position is used as the end of one line segment and the start of the next line segment</param>
            <param name="isLineClosed">true if the end of the last line is connected to the beginning of the first line</param>
            <param name="lineColor">color of the line</param>
            <param name="lineThickness">thickness of the line</param>
            <param name="name">name (optional)</param>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.#ctor(SharpDX.Vector3[],System.Boolean,System.Boolean,System.Boolean,SharpDX.Color4,System.Single,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="positions">positions</param>
            <param name="isLineStrip">if true then one line position is used as the end of one line segment and the start of the next line segment</param>
            <param name="isPolyLine">if true then line segments are rendered as connected to each other creating a polyline</param>
            <param name="isLineClosed">true if the end of the last line is connected to the beginning of the first line</param>
            <param name="lineColor">color of the line</param>
            <param name="lineThickness">thickness of the line</param>
            <param name="name">name (optional)</param>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.#ctor(SharpDX.Vector3[],System.Boolean,System.Boolean,System.Boolean,SharpDX.Color4,System.Single,System.Single,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="positions">positions</param>
            <param name="isLineStrip">if true then one line position is used as the end of one line segment and the start of the next line segment</param>
            <param name="isPolyLine">if true then line segments are rendered as connected to each other creating a polyline</param>
            <param name="isLineClosed">true if the end of the last line is connected to the beginning of the first line</param>
            <param name="lineColor">color of the line</param>
            <param name="lineThickness">thickness of the line</param>
            <param name="miterLimit">a double value that defines at which line thickness the mitered (sharp) line joint is converted into beveled (square) line joint</param>
            <param name="name">name (optional)</param>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.UpdateBounds(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.OnWorldMatrixChanged">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.UpdatePositions">
            <summary>
            UpdatePositions method needs to be called after the Positions of ScreenSpaceLineMesh are changed.
            This method updates the RenderableMeshPrimitive that was added to the RenderingQueue.
            This call also sets <see cref="F:Ab3d.DirectX.SceneNode.SceneNodeDirtyFlags.MeshVertexBufferDataChanged" /> dirty flag on this SceneNode.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.CollectRenderableObjects">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.OnCustomRenderingQueueChanged(Ab3d.DirectX.RenderingQueue,Ab3d.DirectX.RenderingQueue)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.OnIsVisibleChanged(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.RemoveDuplicateFollowingPositions(SharpDX.Vector3[],System.Single)">
            <summary>
            RemoveDuplicateFollowingPositions checks an array of Vector3 and returns an array with removed duplicate positions that follow each other.
            In case there are no duplicates, the same positions instance is returned as it was passed to this method (no new array is created).
            </summary>
            <param name="positions">array of Vector3</param>
            <param name="epsilon">epsilon (default value is 1.0E-8f)</param>
            <returns>array of Vector3 without duplicate following positions</returns>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.GetDetailsText(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns a string with detailed description of this SceneNode.
            </summary>
            <param name="showBounds">true to show bounds information</param>
            <param name="showTransform">true to show transformation information</param>
            <param name="showDirtyFlags">true to show dirty flags value</param>
            <param name="showMaterialInfo">true to show material info</param>
            <param name="showMeshInfo">true to show mesh info</param>
            <returns>string with detailed description of this object node</returns>
        </member>
        <member name="M:Ab3d.DirectX.ScreenSpaceLineNode.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.UpdateStatusEventHandler">
            <summary>
            UpdateStatusEventHandler is an event handler with UpdateStatusEventArgs as event arguments
            </summary>
            <param name="sender">sender</param>
            <param name="e">RenderingReasonEventArgs</param>
        </member>
        <member name="T:Ab3d.DirectX.UpdateStatusEventArgs">
            <summary>
            UpdateStatusEventArgs is used in the <see cref="E:Ab3d.DirectX.DXScene.AfterUpdated" /> event and defines the DXScene's dirty flags and a Boolena that specifes if the new frame needs to be rendered (this value can be changed by the event subscriber).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.UpdateStatusEventArgs.DXSceneDirtyFlags">
            <summary>
            Gets the DXScene's dirty flags for this frame
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.UpdateStatusEventArgs.IsRenderNeeded">
            <summary>
            Gets or sets a Boolean that specifies if this a new frame needs to be rendered (true) or not (false).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.UpdateStatusEventArgs.#ctor(Ab3d.DirectX.DXScene.ChangeNotifications,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="dxSceneDirtyFlags">DXScene's dirty flags for this frame</param>
            <param name="isRenderNeeded">is rendering needed (based on the dirty flags)</param>
        </member>
        <member name="T:Ab3d.DirectX.Shaders.DirectionalLightShader">
            <summary>
            DirectionalLightShader class is used by the <see cref="T:Ab3d.DirectX.Effects.StandardEffect" /> and is optimized to render up to 3 directional lights.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.DirectionalLightShader.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.DirectionalLightShader.PreloadShaders">
            <summary>
            Loads all the shaders
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.DirectionalLightShader.ResetRenderableGeometryMaterialFlagsValue">
            <summary>
            When RenderableGeometry objects are rendered in the same order in each frame,
            the RenderableGeometry.MaterialFlags value specifies how similar the material is
            to the previous object (for example if diffuse part is the same, then many color checks can be skipped).
            But when the order of rendering is changed or if we start rendering from the middle
            of the RenderingQueue, then we need to reset the cached value for the
            first rendered RenderableGeometry so that all the checks are done agine.
            This method does that.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.DirectionalLightShader.SetCustomPerFrameConstantBuffers(SharpDX.Direct3D11.Buffer,SharpDX.Direct3D11.Buffer)">
            <summary>
            SetCustomPerFrameConstantBuffers sets custom perFrameCameraConstantsBuffer and perFrameLightsConstantBuffer.
            Note that the constant buffers need to be exactly the same as the DirectionalLightShader expects.
            </summary>
            <param name="perFrameCameraConstantsBuffer">perFrameCameraConstantsBuffer or null to use constant buffer from this shader</param>
            <param name="perFrameDirectionalLightsConstantsBuffer">perFrameDirectionalLightsConstantsBuffer or null to use constant buffer from this shader</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.DirectionalLightShader.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.DirectionalLightShader.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Sets the content of the constant buffers based on the specified Material and other properties.
            </summary>
            <param name="material">Material</param>
            <param name="renderableGeometry">object that the material is applied for (usually RenderablePrimitive)</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.DirectionalLightShader.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Shaders.IStandardShader">
            <summary>
            IStandardShader interface defines methods that need to be implemented by a Shader class that can be used as a material that can render standard materials.
            Standard materials support diffuse color with textures, specular color with specular power and emissive color.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.IStandardShader.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.IStandardShader.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Sets the content of the constant buffers based on the specified Material and other properties.
            </summary>
            <param name="material">Material</param>
            <param name="renderableGeometry">object that the material is applied for (usually RenderablePrimitive)</param>
        </member>
        <member name="T:Ab3d.DirectX.Shaders.SuperInstancedShader">
            <summary>
            SuperInstancedShader can render many instances of a mesh and support many different lights (Directional, Point, Spot and Ambient light).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperInstancedShader.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperInstancedShader.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperInstancedShader.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperInstancedShader.SetMaterialConstantBuffer(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase,System.Boolean,System.Boolean)">
            <summary>
            Sets constant buffers based on the specified Material and other properties.
            </summary>
            <param name="material">Material</param>
            <param name="renderablePrimitive">RenderablePrimitiveBase</param>
            <param name="useInstanceObjectColor">if true (by default) then color defined in instance buffer is used; if false color defined in IDiffuseMaterial is used</param>
            <param name="hasAlphaBlend">true if the material has transparency</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperInstancedShader.ApplyShaders(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            ApplyShaders binds the appropriate shaders and their constant buffers and sets the states.
            </summary>
            <param name="isPerPixelShader">true when per pixel shader is used, else per vertex shader is used</param>
            <param name="isSolidColorShader">when true, then objects are rendered with solid color without and lighting calculations (as emissive color)</param>
            <param name="isScreenSpaceScaling">when true, then objects are scaled so that their screen-space size is the same as size defined in the matrix M11 value (when the mesh's size is 1 and the mesh is centered at 0,0,0)</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperInstancedShader.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Shaders.SuperShader">
            <summary>
            SuperInstancedShader class is used by the <see cref="T:Ab3d.DirectX.Effects.StandardEffect" /> and support many different lights (Directional, Point, Spot and Ambient light).
            The number of lights that can be rendered in single pass is defined by the <see cref="F:Ab3d.DirectX.Shaders.SuperShader.MaxLights" /> constant.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Shaders.SuperShader.MaxLights">
            <summary>
            Maximum number of lights that can be rendered by this SuperShader (Ambient light is not counted).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Shaders.SuperShader.MaxShadowLights">
            <summary>
            Gets the maximum number of lights that can cast shadow.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Shaders.SuperShader.ShadowThreshold">
            <summary>
            Gets or sets a float value that helps prevent light bleeding (having areas that should be in shadow fully illuminated) for variance shadow mapping.
            </summary>
            <remarks>
                <para>
            Gets or sets a float value that helps prevent light bleeding (having areas that should be in shadow fully illuminated) for variance shadow mapping.
            </para>
                <para>
            The value is used to map all shadow values from 0 ... ShadowThreshold to 0 and then linearly rescale the values from ShadowThreshold to 1 into 0 to 1.
            </para>
                <para>
            For more info see "Shadow bleeding" in "Chapter 8. Summed-Area Variance Shadow Maps" (https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch08.html)
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.Shaders.SuperShader.ShadowTreshold">
            <summary>
            Gets or sets a float value that helps prevent light bleeding (having areas that should be in shadow fully illuminated) for variance shadow mapping.
            </summary>
            <remarks>
                <para>
            Gets or sets a float value that helps prevent light bleeding (having areas that should be in shadow fully illuminated) for variance shadow mapping.
            </para>
                <para>
            The value is used to map all shadow values from 0 ... ShadowThreshold to 0 and then linearly rescale the values from ShadowThreshold to 1 into 0 to 1.
            </para>
                <para>
            For more info see "Shadow bleeding" in "Chapter 8. Summed-Area Variance Shadow Maps" (https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch08.html)
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.Shaders.SuperShader.ShadowDepthBias">
            <summary>
            Gets or sets a float value that offsets the depth of the lights (distance from the lights to the object) and
            can help reduce the show artifacts in the corners. The value that works best need to be set based on the size of the scene. Default value is 0 that does not apply any bias.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperShader.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">Parent DXDevice used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperShader.PreloadShaders">
            <summary>
            Loads all the shaders
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperShader.ResetRenderableGeometryMaterialFlagsValue">
            <summary>
            When RenderableGeometry objects are rendered in the same order in each frame,
            the RenderableGeometry.MaterialFlags value specifies how similar the material is
            to the previous object (for example if diffuse part is the same, then many color checks can be skipped).
            But when the order of rendering is changed or if we start rendering from the middle
            of the RenderingQueue, then we need to reset the cached value for the
            first rendered RenderableGeometry so that all the checks are done agine.
            This method does that.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperShader.SetCustomPerFrameConstantBuffers(SharpDX.Direct3D11.Buffer,SharpDX.Direct3D11.Buffer)">
            <summary>
            SetCustomPerFrameConstantBuffers sets custom perFrameCameraConstantsBuffer and perFrameLightsConstantBuffer.
            Note that the constant buffers need to be exactly the same as the SuperShader expects.
            </summary>
            <param name="perFrameCameraConstantsBuffer">perFrameCameraConstantsBuffer or null to use constant buffer from this shader</param>
            <param name="perFrameLightsConstantBuffer">perFrameLightsConstantBuffer or null to use constant buffer from this shader</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperShader.GetRequiredRenderingPassesCount(System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Returns number of rendering passes that are required to render the specified lights.
            </summary>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
            <returns>number of rendering passes that are required to render the specified lights</returns>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperShader.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperShader.ApplyRenderingPass(System.Int32,Ab3d.DirectX.RenderingContext)">
            <summary>
            Prepares the lights constant buffer for the specified rendering pass.
            </summary>
            <param name="renderingPassIndex">rendering pass index</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperShader.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <summary>
            Sets the content of the constant buffers based on the specified Material and other properties.
            </summary>
            <param name="material">Material</param>
            <param name="renderableGeometry">object that the material is applied for (usually RenderablePrimitive)</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperShader.SetShadowMappingParameters(Ab3d.DirectX.ShadowLightData[],Ab3d.DirectX.RenderingContext)">
            <summary>
            SetShadowMappingParameters sets parameters needed for shadow mapping.
            This method must be called before the <see cref="M:Ab3d.DirectX.Shaders.SuperShader.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method.
            Shadow rendering is enabled only after the next call to ApplyPerFrameSettings and before another ApplyPerFrameSettings call.
            </summary>
            <param name="shadowLightsData">array of ShadowLightData - one element for each light</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.Shaders.SuperShader.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.PlanarShadowRenderingProvider">
            <summary>
            PlanarShadowRenderingProvider provides support for rendering shadows on a 3D plane surface.
            </summary>
            <remarks>
                <para>
                    <b>PlanarShadowRenderingProvider</b> provides support for rendering shadows on a 3D plane surface.
            </para>
                <para>
            Planar shadow rendering is the second shadow rendering technique in Ab3d.DXEngine.
            It is provided by PlanarShadowRenderingProvider and can render shadow to a 3D plane.
            </para>
                <para>
            Its <b>advantage</b> over <see cref="T:Ab3d.DirectX.VarianceShadowRenderingProvider" /> is that it can render sharp shadows that do not loose precision
            even when user zoom into the shadow. It is also much faster to render.
            The shadows are rendered with applying a shadow matrix to all objects.
            This matrix flatten all the objects so that they have no height and become only a 2D shape of the object's shadow.
            That shape is then rendered a 3D object on top of the plane.
            </para>
                <para>
            To support clipping to plane's bounds by the GPU (when using Ab3d.PowerToys this need to be done in software)
            and to prevent rendering some parts of the shadow multiple times, a DirectX stencil buffer is used.
            </para>
                <para>
                    <b>Disadvantages</b> of VarianceShadowRenderingProvider are:<br />
            - it can render shadows only to a 3D plane,<br />
            - it cannot render soft shadows,<br />
            - shadows are rendered for object behind the plane or point light,<br />
            - some objects that lie on the plane or are very close to the plane may get slightly invalid shadow.
            </para>
                <para>
            It is also possible to render planar shadows without PlanarShadowRenderingProvider and with using only
            PlanarShadowMeshCreator from Ab3d.PowerToys but this does not provide hardware accelerated shadows rendering
            (shadow object need to be created on the CPU) and cannot render transparent shadows correctly - see samples that come with Ab3d.PowerToys.
            </para>
                <para>
            PlanarShadowRenderingProvider support only directional or point light as source of the shadow.
            To use a custom light that does not illuminate the 3D scene set the <see cref="P:Ab3d.DirectX.PlanarShadowRenderingProvider.CustomShadowLight" /> property.
            Otherwise, the first light that has DXAttributeType.IsCastingShadow attribute set to true is used.
            If no light has IsCastingShadow attribute set, then the first directional or point light is used.
            </para>
                <para>
            PlanarShadowRenderingProvider also renders the 3D plane that receives the shadow.
            If you want to render your the plane by yourself, then set <see cref="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneMaterial" /> and <see cref="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneBackMaterial" />
            to null. But you must still provide <see cref="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneSize" /> (and <see cref="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneCenterPosition" />, <see cref="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneNormalVector" /> and <see cref="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneHeightDirection" /> when they differ from default values).
            This is needed to correctly set the stencil buffer to clip shadow to the plane's area.
            If <see cref="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneSize" /> is set to (0,0) them the shadow plane will not be rendered and the shadow will not be clipped by the PlanarShadowRenderingProvider.
            </para>
                <example>
                    <para>
            To enable planar shadow rendering the <see cref="M:Ab3d.DirectX.DXScene.InitializeShadowRendering(Ab3d.DirectX.ShadowRenderingProviderBase)" /> method must be called with an instance of PlanarShadowRenderingProvider.
            The following code shows that:
            </para>
                    <code>
            // Create new PlanarShadowRenderingProvider
            var planarShadowRenderingProvider = new PlanarShadowRenderingProvider()
            {
                ShadowPlaneCenterPosition = new Vector3(0, 0, 0),
                ShadowPlaneSize = new Vector2(400, 400),
                ShadowPlaneNormalVector = new Vector3(0, 1, 0),
                ShadowPlaneHeightDirection = new Vector3(0, 0, -1),
            
                ShadowPlaneMaterial = new StandardMaterial()
                {
                    DiffuseColor = Colors.Green.ToColor3()
                },
            
                ShadowPlaneBackMaterial = new StandardMaterial()
                {
                    DiffuseColor = Colors.DimGray.ToColor3()
                },
            
                ShadowColor = Color3.Black,
                ShadowTransparency = 0.65f,
            
                // Because shadow is rendered as standard 3D object, we need to offset it from the shadow plane
                // to prevent z-fighting problems that occur when two 3D objects are rendered to the same 3D position.
                // This value need to be very small so that it is not seen that the shadow is above the plane.
                // Default value is 0.01f.
                ShadowOffsetFromPlane = 0.01f,
            
                // When using PlanarShadowRenderingProvider we do not need PlanarShadowMeshCreator from Ab3d.PowerToys
                // to prepare a special MeshGeometry3D for us. Also PlanarShadowMeshCreator does not need to manually (on the CPU)
                // cut the shadow to the plane bounds but this can be done with using hardware accelerated algorithm (using stencil buffer).
                // But if we still want to use PlanarShadowMeshCreator we can set the following two properties to false 
                // (for example if we wanted to use PlanarShadowRenderingProvider just to provide proper transparent shadows).
                ApplyShadowMatrix = true,
                CutShadowToPlaneBounds = true,
            
                // To use a custom light that does not illuminate the 3D scene set the CustomShadowLight.
                // Otherwise the first light that has DXAttributeType.IsCastingShadow attribute set to true is used.
                // If no light has IsCastingShadow attribute set, then the first directional or point light is used.
                //CustomShadowLight = new Ab3d.DirectX.Lights.DirectionalLight(new Vector3(0, -1, 1))
                //CustomShadowLight = new Ab3d.DirectX.Lights.PointLight(new Vector3(0, 500, 0), 300)
            };
            
            // Initialize shadow rendering with DXEngine
            MainDXViewportView.DXScene.InitializeShadowRendering(planarShadowRenderingProvider);
            </code>
                </example>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneRenderingQueue">
            <summary>
            Gets a RenderingQueue that is used to render shadow plane.
            If you are rendering your own shadow plane, then use this RenderingQueue.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PlanarShadowRenderingProvider.PlanarShadowsRenderingStepsGroupName">
            <summary>
            Name of the RenderingStepsGroup that contains rendering steps that render planar shadow.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PlanarShadowRenderingProvider.RenderShadowPlaneRenderingStepsName">
            <summary>
            Name of the RenderShadowPlane RenderingStep - renders plane 3D object.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PlanarShadowRenderingProvider.RenderPlanarShadowsRenderingStepName">
            <summary>
            Name for RenderPlanarShadows RenderingStep - renders shadow.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneRenderingQueueName">
            <summary>
            Name for RenderingQueue that contains shadow plane renderable object.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowColor">
            <summary>
            Gets or sets a color that is used to render shadow. Default value is Black. See also <see cref="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowTransparency" /> that defines the transparency of the shadow.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowTransparency">
            <summary>
            Gets or sets a float value that defines the transparency of the shadow (1 means no transparency; 0 means full transparency; default value is 0.65f).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowOffsetFromPlane">
            <summary>
            Gets or sets a float number that specifies the distance of the shadow "objects" from the plane. This distance needs to be specified to prevent z-fighting artifacts that would occur is plane and shows objects are rendered to the same 3D positions.
            Default value is 0.01f.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneCenterPosition">
            <summary>
            Gets or sets a Vector3 that specifies the center position of the shadow plane. Default value is (0, 0, 0).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneSize">
            <summary>
            Gets or sets a Vector2 that specifies the size of the shadow plane.
            When size is set to (0, 0), then the shadow plane is not rendered and also the shadow is not cut to shadow plane.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneNormalVector">
            <summary>
            Gets or sets a Vector3 that specifies the normal vector of the shadow plane. Default value is (0, 1, 0).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneHeightDirection">
            <summary>
            Gets or sets a Vector3 that specifies the direction of the height (in the plane's size). Default value is (0, 0, -1).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneMaterial">
            <summary>
            Gets or sets a DirectX Material that is used to render the front (top) side of the shadow plane.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ShadowPlaneBackMaterial">
            <summary>
            Gets or sets a DirectX Material that is used to render the back (bottom) side of the shadow plane.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.FilterRenderingQueuesFunction">
            <summary>
            Gets or sets a filter function that can be used to filter RenderingQueue that will be rendered (returning false for RenderingQueue that are not rendered).
            This property can be set to render only shadow objects that are defined in a custom RenderingQueue or to prevent rendering transparent objects.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.ApplyShadowMatrix">
            <summary>
            Gets or sets a Boolean that specifies if a shadow matrix is applied to the rendered 3D objects.
            By default this property is set to true, but when rendering custom shadow objects (defined in a custom RenderingQueue)
            that already have shadow matrix applied, then this property should be set to false.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.CutShadowToPlaneBounds">
            <summary>
            Gets or sets a boolean that specifies if shadow is clipped to the shadow plane's bounds.
            When true then stencil buffer is used to render only the the part where the plane is rendered; when false the mesh need to be clipped on the CPU (for example with using PlanarShadowMeshCreator from Ab3d.PowerToys). 
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.CustomShadowLight">
            <summary>
            When CustomShadowLight is set, then it is used as a light that generates the shadow instead of a light from a 3D scene.
            This way it is possible to generate a shadow from a light that does not illuminate the scene.
            The only possible types of lights that can be assigned to this property are <see cref="T:Ab3d.DirectX.Lights.PointLight" /> and <see cref="T:Ab3d.DirectX.Lights.DirectionalLight" />.
            It is also possible to use a custom light with overriding the <see cref="M:Ab3d.DirectX.PlanarShadowRenderingProvider.CalculateShadowMatrix" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.DepthStencilFormat">
            <summary>
            Gets or sets format of depth stencil buffer that is set by this PlanarShadowRenderingProvider.
            Possible values are D32_Float_S8X24_UInt (default) and D24_UNorm_S8_UInt.
            When changed the change need to be done before initializing the PlanarShadowRenderingProvider.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PlanarShadowRenderingProvider.IsCheckingIsCastingShadow">
            <summary>
            Gets or sets a Boolean that specifies if PlanarShadowRenderingProvider is checking if object
            has IsCastingShadow property set. That check can slightly decrease performance therefore the default value is false.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PlanarShadowRenderingProvider.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PlanarShadowRenderingProvider.CalculateShadowMatrix">
            <summary>
            CalculateShadowMatrix is a virtual method that calculates the shadow matrix from the shadow light.
            This matrix is used to transform the 3D objects into flat shadow meshes.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PlanarShadowRenderingProvider.CreateResources(Ab3d.DirectX.DXScene)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.PlanarShadowRenderingProvider.InitializeRenderingSteps(Ab3d.DirectX.DXScene)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.PlanarShadowRenderingProvider.Update">
            <summary>
            Update method is called on each DXScene.Update call before rendering of the scene begins.
            If derived class need to create some SceneNodes then they should be created in the overridden methods.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PlanarShadowRenderingProvider.GetDirectionalLightShadowMatrix(SharpDX.Vector3,SharpDX.Plane@)">
            <summary>
            GetDirectionalLightShadowMatrix is a static method that calculates the shadow matrix for the specified light direction and shadow plane.
            </summary>
            <param name="lightDirection">light direction</param>
            <param name="shadowPlane">shadow plane</param>
        </member>
        <member name="M:Ab3d.DirectX.PlanarShadowRenderingProvider.GetPointLightShadowMatrix(SharpDX.Vector3,SharpDX.Plane@)">
            <summary>
            GetPointLightShadowMatrix is a static method that calculates the shadow matrix for the specified light position and shadow plane.
            </summary>
            <param name="lightPosition">light position</param>
            <param name="shadowPlane">shadow plane</param>
        </member>
        <member name="M:Ab3d.DirectX.PlanarShadowRenderingProvider.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.PrepareVarianceShadowMappingRenderingStep">
            <summary>
            PrepareVarianceShadowMappingRenderingStep rendering step prepares other rendering steps for variance shadow rendering.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PrepareVarianceShadowMappingRenderingStep.ShadowShaderResourceView">
            <summary>
            Gets ShaderResourceView for the shadow map buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PrepareVarianceShadowMappingRenderingStep.BluredShaderResourceView1">
            <summary>
            Gets ShaderResourceView for the first blured shadow map.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.PrepareVarianceShadowMappingRenderingStep.BluredShaderResourceView2">
            <summary>
            Gets ShaderResourceView for the second blured shadow map.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.PrepareVarianceShadowMappingRenderingStep.#ctor(System.String,Ab3d.DirectX.VarianceShadowRenderingProvider,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name of this rendering step</param>
            <param name="varianceShadowRenderingProvider">VarianceShadowRenderingProvider</param>
            <param name="description">description of this rendering step</param>
        </member>
        <member name="M:Ab3d.DirectX.PrepareVarianceShadowMappingRenderingStep.OnInitializeResources(Ab3d.DirectX.DXScene)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxScene">Parent DXScene used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.PrepareVarianceShadowMappingRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.PrepareVarianceShadowMappingRenderingStep.SaveExecutionTimeStatistics(System.Double,Ab3d.DirectX.RenderingStatistics)">
            <summary>
            SaveExecutionTimeStatistics is called when we are collecting statistics.
            The implementation of the method should save or add the elapsedMilliseconds to the corresponding property in the RenderingStatistics class.
            </summary>
            <param name="stepExecutionTimeInMilliseconds">time in milliseconds to execute this rendering step</param>
            <param name="renderingStatistics">RenderingStatistics</param>
        </member>
        <member name="M:Ab3d.DirectX.PrepareVarianceShadowMappingRenderingStep.Dispose(System.Boolean)">
            <summary>
            Dispose any resources that are created in RenderingStep.
            </summary>
            <param name="isDisposing">isDisposing</param>
        </member>
        <member name="T:Ab3d.DirectX.ShadowLightData">
            <summary>
            ShadowLightData class defines data that are required for shadow mapping and are generated from one shadow light.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ShadowLightData.ShadowLight">
            <summary>
            Light that the data was created from.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ShadowLightData.LightPosition">
            <summary>
            Position of the light.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ShadowLightData.LightViewProjection">
            <summary>
            Light ViewProjection matrix
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ShadowLightData.ShadowDepthView">
            <summary>
            ShaderResourceView of the shadow map buffer
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ShadowLightData.#ctor(Ab3d.DirectX.Lights.ILight,SharpDX.Vector3,SharpDX.Matrix@,SharpDX.Direct3D11.ShaderResourceView)">
            <summary>
            Constructor
            </summary>
            <param name="shadowLight">Light that the data was created from</param>
            <param name="lightPosition">Position of the light</param>
            <param name="lightViewProjection">Light ViewProjection matrix</param>
            <param name="shadowDepthView">ShaderResourceView of the shadow map buffer</param>
        </member>
        <member name="M:Ab3d.DirectX.ShadowLightData.Update(Ab3d.DirectX.Lights.ILight,SharpDX.Vector3,SharpDX.Matrix@,SharpDX.Direct3D11.ShaderResourceView)">
            <summary>
            Updates the data
            </summary>
            <param name="shadowLight">Light that the data was created from</param>
            <param name="lightPosition">Position of the light</param>
            <param name="lightViewProjection">Light ViewProjection matrix</param>
            <param name="shadowDepthView">ShaderResourceView of the shadow map buffer</param>
        </member>
        <member name="T:Ab3d.DirectX.ShadowRenderingProviderBase">
            <summary>
            ShadowRenderingProviderBase is an abstract class that is a base class for all shadow rendering providers that change DXEngine rendering steps with adding shadow rendering.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ShadowRenderingProviderBase.IsEnabled">
            <summary>
            Gets or sets a Boolean that specifies if this shadow rendering provider is enabled or not.
            Default value is true.
            </summary>
            <remarks>
                <para>
                    <b>IsEnabled</b> gets or sets a Boolean that specifies if this shadow rendering provider is enabled or not.
            </para>
                <para>
            IsEnabled property can be used to quickly enable of disable shadow rendering. 
            </para>
                <para>
            When the ShadowRenderingProviderBase is disabled, the created DirectX resources are usually disposed, but the created rendering steps are still part of the DXScene.RenderingSteps.
            </para>
                <para>
            To remove all the created DirectX resources and also remove the rendering steps, call the Dispose method.
            </para>
            </remarks>
        </member>
        <member name="M:Ab3d.DirectX.ShadowRenderingProviderBase.OnInitializeResources(Ab3d.DirectX.DXScene)">
            <summary>
            OnInitializeResources is called from the DXScene.<see cref="M:Ab3d.DirectX.DXScene.InitializeShadowRendering(Ab3d.DirectX.ShadowRenderingProviderBase)" />.
            The method calls <see cref="M:Ab3d.DirectX.ShadowRenderingProviderBase.CreateResources(Ab3d.DirectX.DXScene)" /> and <see cref="M:Ab3d.DirectX.ShadowRenderingProviderBase.InitializeRenderingSteps(Ab3d.DirectX.DXScene)" /> methods.
            </summary>
            <param name="dxScene">Parent DXScene used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.ShadowRenderingProviderBase.CreateResources(Ab3d.DirectX.DXScene)">
            <summary>
            CreateResources is called when the ShadowRenderingProviderBase is initialized and should create the DirectX resources.
            </summary>
            <remarks>
                <para>
                    <b>CreateResources</b> is called when the ShadowRenderingProviderBase is initialized and should create the DirectX resources.
            </para>
                <para>
            This method is called after this shadow rendering provider is registered with calling the <see cref="M:Ab3d.DirectX.DXScene.InitializeShadowRendering(Ab3d.DirectX.ShadowRenderingProviderBase)" /> method. 
            This method then calls the <see cref="M:Ab3d.DirectX.DXSceneResource.InitializeResources(Ab3d.DirectX.DXScene)" /> and the <see cref="M:Ab3d.DirectX.ShadowRenderingProviderBase.OnInitializeResources(Ab3d.DirectX.DXScene)" />.
            OnInitializeResources calls the this CreateResources method and then <see cref="M:Ab3d.DirectX.ShadowRenderingProviderBase.InitializeRenderingSteps(Ab3d.DirectX.DXScene)" /> method.
            </para>
                <para>
            This method usually creates required shaders, constant buffers and additional texture buffers.
            </para>
            </remarks>
            <param name="dxScene">parent DXScene</param>
        </member>
        <member name="M:Ab3d.DirectX.ShadowRenderingProviderBase.InitializeRenderingSteps(Ab3d.DirectX.DXScene)">
            <summary>
            InitializeRenderingSteps is called when the ShadowRenderingProviderBase is initialized and should add customer rendering steps to the DXScene.RenderingSteps list.
            See remarks for more into.
            </summary>
            <remarks>
                <para>
                    <b>InitializeRenderingSteps</b> is called when the ShadowRenderingProviderBase is initialized and should add customer rendering steps to the DXScene.RenderingSteps list.
            </para>
                <para>
            It is recommended that the created rendering steps are protected or public with private setter.
            This way a derived class can override the InitializeRenderingSteps method and add the created rendering steps in some other was to the DXScene.RenderingSteps.
            </para>
            </remarks>
            <param name="dxScene">parent DXScene</param>
        </member>
        <member name="M:Ab3d.DirectX.ShadowRenderingProviderBase.OnIsEnabledChanged(System.Boolean)">
            <summary>
            OnIsEnabledChanged is called when the IsEnabled property is changed.
            </summary>
            <param name="newIsEnabledValue"></param>
        </member>
        <member name="M:Ab3d.DirectX.ShadowRenderingProviderBase.Update">
            <summary>
            Update method is called on each DXScene.Update call before rendering of the scene begins.
            If derived class need to create some SceneNodes then they should be created in the overridden methods.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ShadowRenderingProviderBase.NotifyDXSceneChange">
            <summary>
            NotifyDXSceneChange calls NotifyChange on dxScene and sets the ShadowRenderingSettingsChanged flag.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ShadowRenderingProviderBase.IsLightCastingShadow(Ab3d.DirectX.Lights.ILight)">
            <summary>
            Returns true if the light is casting shadow (implements IShadowCastingLight as has IsCastingShadow property set to true).
            </summary>
            <param name="light">ILight</param>
            <returns>true if the light is casting shadow, otherwise false</returns>
        </member>
        <member name="M:Ab3d.DirectX.ShadowRenderingProviderBase.CollectShadowLights(System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},System.Collections.Generic.List{Ab3d.DirectX.Lights.ILight})">
            <summary>
            Clears the filteredLights list and fills it with all lights that have IsCastingShadow set to true and implement ISpotLight interface.
            </summary>
            <param name="allSceneLights">allSceneLights</param>
            <param name="filteredLights">changed lights list</param>
        </member>
        <member name="M:Ab3d.DirectX.ShadowRenderingProviderBase.CollectNonShadowLights(System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},System.Collections.Generic.List{Ab3d.DirectX.Lights.ILight})">
            <summary>
            Clears the filteredLights list and fills it with all lights that have IsCastingShadow set to false (or do not define IsCastingShadow or ISpotLight interface).
            </summary>
            <param name="allSceneLights">allSceneLights</param>
            <param name="filteredLights">changed lights list</param>
        </member>
        <member name="M:Ab3d.DirectX.ShadowRenderingProviderBase.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.SuperShadowShaderEffect">
            <summary>
            SuperShadowShaderEffect is an effect that can use <see cref="T:Ab3d.DirectX.Shaders.SuperShader" /> and configure it to render the scene with using the shadow mapping buffer that was rendered before.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SuperShadowShaderEffect.EffectName">
            <summary>
            Name of this effect
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SuperShadowShaderEffect.RequiredInputLayoutType">
            <summary>
            Gets the input layout that is required to render this effect.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SuperShadowShaderEffect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SuperShadowShaderEffect.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.SuperShadowShaderEffect.PreloadShaders">
            <summary>
            PreloadShaders can be called to load the shaders in advance before they are used.
            Calling this method increases the startup time, but when the 3D object needs to be shown, it is shown faster because all the shaders have already been created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SuperShadowShaderEffect.SetShadowMappingParameters(Ab3d.DirectX.ShadowLightData[],System.Single,Ab3d.DirectX.RenderingContext)">
            <summary>
            SetShadowMappingParameters sets parameters needed for shadow mapping.
            This method must be called after the <see cref="M:Ab3d.DirectX.Effect.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method and enabled shadow rendering until the next call to <see cref="M:Ab3d.DirectX.Effect.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method.
            </summary>
            <param name="shadowLightsData">array of ShadowLightData - one element for each light</param>
            <param name="shadowThreshold">float value that helps prevent light bleeding</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.SuperShadowShaderEffect.SetShadowMappingParameters(Ab3d.DirectX.ShadowLightData[],System.Single,System.Single,Ab3d.DirectX.RenderingContext)">
            <summary>
            SetShadowMappingParameters sets parameters needed for shadow mapping.
            This method must be called after the <see cref="M:Ab3d.DirectX.Effect.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method and enabled shadow rendering until the next call to <see cref="M:Ab3d.DirectX.Effect.ApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)" /> method.
            </summary>
            <param name="shadowLightsData">array of ShadowLightData - one element for each light</param>
            <param name="shadowThreshold">float value that helps prevent light bleeding</param>
            <param name="shadowDepthBias">float value that offsets the light distance and can prevent shadow artifacts in the corners</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.SuperShadowShaderEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.SuperShadowShaderEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.SuperShadowShaderEffect.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.VarianceDepthBlurPostProcess">
            <summary>
            VarianceDepthBlurPostProcess is a post process that applies blur to depth data created with variance depth mapping.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.VarianceDepthBlurPostProcess.#ctor(System.Boolean,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Ab3d.DirectX.VarianceDepthBlurPostProcess" /> class.
            </summary>
            <param name="isVerticalBlur">if set to <c>true</c> the VarianceDepthBlurPostProcess will render the vertical pass; otherwise a horizontal pass is rendered.</param>
            <param name="filterWidth">width of the filter (default value is 5)</param>
        </member>
        <member name="M:Ab3d.DirectX.VarianceDepthBlurPostProcess.GetSamplerState(Ab3d.DirectX.RenderingContext)">
            <summary>
            Gets a sampler state that will be used to sample the input texture (CommonStates.LinearClamp by default)
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <returns>sampler state that will be used to sample the input texture</returns>
        </member>
        <member name="M:Ab3d.DirectX.VarianceDepthBlurPostProcess.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.VarianceShadowDepthEffect">
            <summary>
            VarianceShadowDepthEffect renders the objects with writing the object's depth and depth squared into the render target.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.VarianceShadowDepthEffect.EffectName">
            <summary>
            Name of this effect
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.VarianceShadowDepthEffect.RequiredInputLayoutType">
            <summary>
            Gets the input layout that is required to render this effect.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.VarianceShadowDepthEffect.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.VarianceShadowDepthEffect.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.VarianceShadowDepthEffect.PreloadShaders">
            <summary>
            PreloadShaders can be called to load the shaders in advance before they are used.
            Calling this method increases the startup time, but when the 3D object needs to be shown, it is shown faster because all the shaders have already been created.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.VarianceShadowDepthEffect.SetShadowDepthParameters(Ab3d.DirectX.ShadowLightData)">
            <summary>
            Sets shadow light data to this effect
            </summary>
            <param name="shadowLightData">ShadowLightData</param>
        </member>
        <member name="M:Ab3d.DirectX.VarianceShadowDepthEffect.OnApplyPerFrameSettings(Ab3d.DirectX.ICamera,System.Collections.Generic.IList{Ab3d.DirectX.Lights.ILight},Ab3d.DirectX.RenderingContext)">
            <summary>
            Sets per frame settings for this effect (this sets camera, lights and other per frame settings).
            This method also sets PassesCount.
            </summary>
            <param name="camera">camera</param>
            <param name="lights">list of lights</param>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.VarianceShadowDepthEffect.ApplyMaterial(Ab3d.DirectX.Material,Ab3d.DirectX.RenderablePrimitiveBase)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.VarianceShadowDepthEffect.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.VarianceShadowRenderingProvider">
            <summary>
            VarianceShadowRenderingProvider provides support for rendering shadows with using Variance shadow rendering technique.
            Currently only one SpotLight or one DirectionalLight shadow casting light are supported.
            </summary>
            <remarks>
                <para>
            VarianceShadowRenderingProvider provides support for rendering shadows with using Variance shadow rendering technique.
            </para>
                <para>
            The used algorithm is based on the GPU Gems3 "Chapter 8. Summed-Area Variance Shadow Maps" (https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch08.html)
            </para>
                <para>
            Currently only one SpotLight or one DirectionalLight shadow casting light are supported.
            </para>
                <example>
                    <para>
            To enable shadow rendering the <see cref="M:Ab3d.DirectX.DXScene.InitializeShadowRendering(Ab3d.DirectX.ShadowRenderingProviderBase)" /> method must be called with an instance of VarianceShadowRenderingProvider.
            Then the light that casts the shadow needs to be specified with setting the DXAttributeType.IsCastingShadow attribute on the light.
            The following code shows that:
            </para>
                    <code>
            // Create new VarianceShadowRenderingProvider
            var varianceShadowRenderingProvider = new VarianceShadowRenderingProvider()
            {
                ShadowMapSize = 512,
                ShadowDepthBluringSize = 4,
                ShadowThreshold = 0.2f
            };
            
            // Initialize shadow rendering with DXEngine
            MainDXViewportView.DXScene.InitializeShadowRendering(varianceShadowRenderingProvider);
            
            
            // Create a SpotLight
            var shadowSpotLight = new SpotLight()
            {
                Position = new Point3D(0, 100, -500),
                Direction = new Vector3D(0, -1, 5)
            };
            
            // Mark it for casting shadow (set IsCastingShadow DXEngine attribute to true)
            shadowSpotLight.SetDXAttribute(DXAttributeType.IsCastingShadow, true);
            </code>
                </example>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.VarianceShadowRenderingProvider.ShadowMapSize">
            <summary>
            Gets or sets and integer value that represents the size of a shadow depth map texture. Default value is 512 and means that by default a 512 x 512 texture will be used.
            </summary>
            <remarks>
                <para>
                    <b>ShadowMapSize</b> gets or sets and integer value that represents the size of a shadow depth map texture.
            </para>
                <para>
            The value defines the width and height of the texture. For example value 512 means that a 512 x 512 texture will be used.
            </para>
                <para>
            The shadow depth map texture is used to store depth information - distance of a pixel from the light.
            </para>
                <para>
            Bigger texture will produce more detailed shadows but will be slower to render.
            Also, to bigger texture will require bigger blur amount to achieve nice shoft edges.
            </para>
                <note type="note">
            The ShadowMapSize and <see cref="P:Ab3d.DirectX.VarianceShadowRenderingProvider.ShadowDepthBluringSize" /> values must be changed before the VarianceShadowRenderingProvider is initialized.
            To change the value of those two properties do the following:<br />
            1) disable the existing VarianceShadowRenderingProvider with calling <see cref="M:Ab3d.DirectX.DXScene.InitializeShadowRendering(Ab3d.DirectX.ShadowRenderingProviderBase)" /> method with null parameter;<br />
            2) create a new instance of VarianceShadowRenderingProvider with new values for ShadowMapSize and ShadowDepthBluringSize;<br />
            3) Call the <see cref="M:Ab3d.DirectX.DXScene.InitializeShadowRendering(Ab3d.DirectX.ShadowRenderingProviderBase)" /> method again an pass the new instance of VarianceShadowRenderingProvider as parameter.
            </note>
                <para>
            Default value is 512.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.VarianceShadowRenderingProvider.ShadowDepthBluringSize">
            <summary>
            Gets or sets an integer that specifies the blur amount that is applied on the shadow depth map and can produce shadows with nice soft edges. Default value is 4.
            </summary>
            <remarks>
                <para>
                    <b>ShadowDepthBluringSize</b> gets or sets an integer that specifies the blur amount that is applied on the shadow depth map and can produce shadows with nice soft edges.
            </para>
                <para>
            Default value is 4.
            </para>
                <note type="note">
            The <see cref="P:Ab3d.DirectX.VarianceShadowRenderingProvider.ShadowMapSize" /> and values must be changed before the VarianceShadowRenderingProvider is initialized.
            To change the value of those two properties do the following:<br />
            1) disable the existing VarianceShadowRenderingProvider with calling <see cref="M:Ab3d.DirectX.DXScene.InitializeShadowRendering(Ab3d.DirectX.ShadowRenderingProviderBase)" /> method with null parameter;<br />
            2) create a new instance of VarianceShadowRenderingProvider with new values for ShadowMapSize and ShadowDepthBluringSize;<br />
            3) Call the <see cref="M:Ab3d.DirectX.DXScene.InitializeShadowRendering(Ab3d.DirectX.ShadowRenderingProviderBase)" /> method again an pass the new instance of VarianceShadowRenderingProvider as parameter.
            </note>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.VarianceShadowRenderingProvider.ShadowThreshold">
            <summary>
            Gets or sets a float value that helps prevent light bleeding (having areas that should be in shadow fully illuminated) for variance shadow mapping. Default value is 0.2f.
            </summary>
            <remarks>
                <para>
            Gets or sets a float value that helps prevent light bleeding (having areas that should be in shadow fully illuminated) for variance shadow mapping.
            </para>
                <para>
            The value is used to map all shadow values from 0 ... ShadowThreshold to 0 and then linearly rescale the values from ShadowThreshold to 1 into 0 to 1.
            </para>
                <para>
            For more info see "Shadow bleeding" in "Chapter 8. Summed-Area Variance Shadow Maps" (https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch08.html)
            </para>
                <para>
            Default value is 0.2f.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.VarianceShadowRenderingProvider.ShadowTreshold">
            <summary>
            Gets or sets a float value that helps prevent light bleeding (having areas that should be in shadow fully illuminated) for variance shadow mapping. Default value is 0.2f.
            </summary>
            <remarks>
                <para>
            Gets or sets a float value that helps prevent light bleeding (having areas that should be in shadow fully illuminated) for variance shadow mapping.
            </para>
                <para>
            The value is used to map all shadow values from 0 ... ShadowThreshold to 0 and then linearly rescale the values from ShadowThreshold to 1 into 0 to 1.
            </para>
                <para>
            For more info see "Shadow bleeding" in "Chapter 8. Summed-Area Variance Shadow Maps" (https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch08.html)
            </para>
                <para>
            Default value is 0.2f.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.VarianceShadowRenderingProvider.ShadowDepthBias">
            <summary>
            Gets or sets a float value that offsets the depth of the lights (distance from the lights to the object) and
            can help reduce the show artifacts in the corners.  The value does not work for all 3D scenes because it depends on the size of the scene. Default value is 0 that does not apply any bias.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.VarianceShadowRenderingProvider.ShadowDepthMapRenderingStepsGroupName">
            <summary>
            Name of the RenderingStepsGroup that contains rendering steps that render shadow depth map.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.VarianceShadowRenderingProvider.PrepareVarianceShadowMappingRenderingStepsName">
            <summary>
            Name of the PrepareVarianceShadowMappingRenderingStep that prepares parameters for other rendering steps in shadow depth rendering.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.VarianceShadowRenderingProvider.RenderShadowDepthRenderingStepName">
            <summary>
            Name for RenderShadowDepthRenderingStep 
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.VarianceShadowRenderingProvider.DepthBlurPostProcessingRenderingStepName">
            <summary>
            Name for DepthBlurPostProcessingRenderingStep
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.VarianceShadowRenderingProvider.ChangeRenderTargetRenderingStepName">
            <summary>
            Name for ChangeRenderTargetRenderingStep
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.VarianceShadowRenderingProvider.RenderNonShadowObjectsRenderingStepName">
            <summary>
            Name for RenderNonShadowObjectsRenderingStep
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.VarianceShadowRenderingProvider.ShadowRenderingStepsGroup">
            <summary>
            Gets a <see cref="T:Ab3d.DirectX.RenderingStepsGroup" /> that groups rendering step that render shadow map.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.VarianceShadowRenderingProvider.PrepareShadowDepthRenderingStep">
            <summary>
            Gets a <see cref="T:Ab3d.DirectX.PrepareVarianceShadowMappingRenderingStep" /> that prepares render targets for variance shadow depth rendering.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.VarianceShadowRenderingProvider.RenderShadowDepthRenderingStep">
            <summary>
            Gets a <see cref="T:Ab3d.DirectX.RenderObjectsRenderingStep" /> that renders shadow depth map - render objects from the light perspective and writes a distance from the light to a shadow depth map.
            This rendering step uses <see cref="T:Ab3d.DirectX.VarianceShadowDepthEffect" /> to render objects (it is set to OverrideEffect property), filters object setting FilterObjectsFunction to <see cref="M:Ab3d.DirectX.VarianceShadowRenderingProvider.FilterShadowCastingObjectsFunction(Ab3d.DirectX.RenderablePrimitiveBase)" /> and filters lights to use only the first shadow light (using FilterLightsFunction property).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.VarianceShadowRenderingProvider.DepthBlurPostProcessingRenderingStep">
            <summary>
            Gets a <see cref="T:Ab3d.DirectX.RenderPostProcessingRenderingStep" /> that runs a post process that blurs the shadow depth map.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.VarianceShadowRenderingProvider.ChangeBackBufferRenderingStep">
            <summary>
            Gets a <see cref="P:Ab3d.DirectX.VarianceShadowRenderingProvider.ChangeBackBufferRenderingStep" /> that changes render targets from shadow depth rendering to rendering 3D scene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.VarianceShadowRenderingProvider.RenderNonShadowObjectsRenderingStep">
            <summary>
            Gets a <see cref="T:Ab3d.DirectX.RenderObjectsRenderingStep" /> that renders all objects that do not cast shadow.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.VarianceShadowRenderingProvider.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.VarianceShadowRenderingProvider.CreateResources(Ab3d.DirectX.DXScene)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.VarianceShadowRenderingProvider.InitializeRenderingSteps(Ab3d.DirectX.DXScene)">
            <inheritdoc />
        </member>
        <member name="M:Ab3d.DirectX.VarianceShadowRenderingProvider.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.CommonStates">
            <summary>
            CommonStates class defines that standard BlendStates, DepthStencilStates, RasterizerState and SamplerStates.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.CommonStates.OnInitializeResources(Ab3d.DirectX.DXDevice)">
            <summary>
            Initializes resources.
            </summary>
            <param name="dxDevice">DXDevice used to initialize resources</param>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.DefaultBlendState">
            <summary>
            Gets or sets the default BlendState - initially set to <see cref="P:Ab3d.DirectX.CommonStates.Opaque" /> BlendState.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.DefaultDepthStencilState">
            <summary>
            Gets or sets the default DepthStencilState - initially set to <see cref="P:Ab3d.DirectX.CommonStates.DepthReadWrite" /> DepthStencilState.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.DefaultRasterizerState">
            <summary>
            Gets or sets the default RasterizerState - initially set to <see cref="P:Ab3d.DirectX.CommonStates.CullClockwise" /> RasterizerState.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.TextureFiltering">
            <summary>
            Gets or sets an TextureFilteringTypes enum that specifies what sampler filter will be used to sample textures.
            Note that the TextureFiltering property cannot be changed after some sampler states have already been used.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.Opaque">
            <summary>
            Opaque blend state - blending is disabled.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.AlphaToCoverage">
            <summary>
            Alpha-to-coverage blend state. See remarks for more information.
            </summary>
            <remarks>
                <para>
            When using alpha-to-coverage then the graphics card determines if the pixel is transparent or opaque based on the color's alpha value
            (when alpha is less the 0.5 then pixel is fully transparent; otherwise the pixel is fully opaque).
            </para>
                <para>
            What is more, when using MSAA (multi-sample anti-aliasing) then the level of transparency can be defined more accurately with making some sub-pixel samples transparent and some opaque
            (for example when using 8 x MSAA then each pixel's color is calculated with combining 8 sub-pixel samples; when alpha-to-coverage is enabled and alpha value is 0.25 (=2/8) then 2 of the samples will be transparent and 6 will be opaque).
            This way it is possible to create smoother transitions from fully transparent to fully opaque regions.
            This technique does not produce as accurate results as standard alpha blending, but a big advantage is that it does not require objects to be sorted (and rendered) from those that are farthest away to those that are closest to the camera (and the results are still very good for some use cases - especially when the textures has small transitions from transparent to opaque).
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.PremultipliedAlphaBlend">
            <summary>
            Alpha blend used for pre-multiplied alpha (used for normal translucent objects, opaque sprites w/ alpha mask, etc.)
            D.rgb := aS.rgb * 1 + D.rgb * ( 1 - S.a )
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.PremultipliedAdditiveBlend">
            <summary>
            Additive blend for pre-multiplied alpha (used for light, fire, laser beam, lightning bolt, etc.)
            D.rgb := aS.rgb * 1 + D.rgb * 1
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.PremultipliedSubstractiveBlend">
            <summary>
            Substractive blend for pre-multiplied alpha (used for shadows, "negative lights", etc.)
            D.rgb := D.rgb * 1 - aS.rgb * 1
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.NonPremultipliedAlphaBlend">
            <summary>
            Alpha blend for non-pre-multiplied alpha (used for light, fire, laser beam, lightning bolt, etc.)
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.DepthReadWrite">
            <summary>
            Gets a DepthStencilState with reading and writing to depth buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.DepthNone">
            <summary>
            Gets a DepthStencilState without reading and writing to depth buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.DepthRead">
            <summary>
            Gets a DepthStencilState with only reading and no writing to depth buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.DepthWrite">
            <summary>
            Gets a DepthStencilState with only writing and no reading to depth buffer
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.RenderOnlyHiddenObjects">
            <summary>
            Gets a DepthStencilState that will render only objects that are behind other objects (renders only "hidden" objects).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.CullNone">
            <summary>
            Gets a RasterizerState that does not cull any triangles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.CullClockwise">
            <summary>
            Gets a RasterizerState that culls clockwise oriented triangles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.CullCounterClockwise">
            <summary>
            Gets a RasterizerState that culls counter-clockwise oriented triangles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.WireframeCullClockwise">
            <summary>
            Gets a RasterizerState that renders the objects with wireframe and culls clockwise oriented triangles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.WireframeCullCounterClockwise">
            <summary>
            Gets a RasterizerState that renders the objects with wireframe and culls counter-clockwise oriented triangles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.WireframeCullNone">
            <summary>
            Gets a RasterizerState that renders the objects with wireframe and does not cull any triangles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.WireframeMultisampleCullNone">
            <summary>
            Gets a RasterizerState that renders the objects with wireframe with multisampling and does not cull any triangles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.WireframeMultisampleCullClockwise">
            <summary>
            Gets a RasterizerState that renders the objects with wireframe with multisampling and culls clockwise oriented triangles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.WireframeMultisampleCullCounterClockwise">
            <summary>
            Gets a RasterizerState that renders the objects with wireframe with multisampling and culls counter-clockwise oriented triangles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.CullNoneMultisample">
            <summary>
            Gets a RasterizerState that support multisampling and does not cull any triangles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.CullClockwiseMultisample">
            <summary>
            Gets a RasterizerState that support multisampling and culls clockwise oriented triangles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.CullCounterClockwiseMultisample">
            <summary>
            Gets a RasterizerState that support multisampling and culls counter-clockwise oriented triangles
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.WrapSampler">
            <summary>
            Gets a SamplerState that uses <see cref="F:SharpDX.Direct3D11.TextureAddressMode.Wrap" />.
            Sampler filter and anisotropy count are set based on the <see cref="P:Ab3d.DirectX.CommonStates.TextureFiltering" /> value.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.ClampSampler">
            <summary>
            Gets a SamplerState that uses <see cref="F:SharpDX.Direct3D11.TextureAddressMode.Clamp" />.
            Sampler filter and anisotropy count are set based on the <see cref="P:Ab3d.DirectX.CommonStates.TextureFiltering" /> value.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.LinearClampSampler">
            <summary>
            Gets a SamplerState that uses linear (instead of anisotropic) filtering and Clamp address mode.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.TransparentBorderColorSampler">
            <summary>
            Gets a SamplerState that uses <see cref="F:SharpDX.Direct3D11.TextureAddressMode.Border" /> and sets the border color to transparent color (0, 0, 0, 0).
            Sampler filter and anisotropy count are set based on the <see cref="P:Ab3d.DirectX.CommonStates.TextureFiltering" /> value.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.MirrorSampler">
            <summary>
            Gets a SamplerState that uses <see cref="F:SharpDX.Direct3D11.TextureAddressMode.Mirror" />.
            Sampler filter and anisotropy count are set based on the <see cref="P:Ab3d.DirectX.CommonStates.TextureFiltering" /> value.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.MirrorXSampler">
            <summary>
            Gets a SamplerState that uses <see cref="F:SharpDX.Direct3D11.TextureAddressMode.Mirror" /> for AddressU and <see cref="F:SharpDX.Direct3D11.TextureAddressMode.Wrap" /> for AddressV and AddressW.
            Sampler filter and anisotropy count are set based on the <see cref="P:Ab3d.DirectX.CommonStates.TextureFiltering" /> value.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.CommonStates.MirrorYSampler">
            <summary>
            Gets a SamplerState that uses <see cref="F:SharpDX.Direct3D11.TextureAddressMode.Mirror" /> for AddressV and <see cref="F:SharpDX.Direct3D11.TextureAddressMode.Wrap" /> for AddressU and AddressW.
            Sampler filter and anisotropy count are set based on the <see cref="P:Ab3d.DirectX.CommonStates.TextureFiltering" /> value.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.CommonStates.GetRecommendedBlendState(System.Boolean,System.Boolean)">
            <summary>
            Returns a recommended BlendState based on the hasTransparency and hasPreMultipliedAlpha parameters.
            </summary>
            <param name="hasTransparency">true when the texture has transparent or semi-transparent pixels (alpha color is less then 1)</param>
            <param name="hasPreMultipliedAlpha">true (by default) when the texture is using a pre-multiplied alpha colors (rgb colors are multiplied by the alpha - for example a 50% transparent red color is: r=0.5, b=0, g=0, a=0.5)</param>
            <returns>recommended BlendState based on the hasTransparency and hasPreMultipliedAlpha parameters</returns>
        </member>
        <member name="M:Ab3d.DirectX.CommonStates.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Ab3d.DirectX.ContextStatesManager">
            <summary>
            ContextStatesManager is a helper class that is used to set the current BlendStates, DepthStencilStates, RasterizerState and SamplerStates.
            Before each state change it checks if the state already has the new state value and in this case prevents the actual DirectX state change call to improve performance.
            ContextStatesManager also collect state changes statistics.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.StateChangesCount">
            <summary>
            Gets number of state changes after last call to ResetChangesCount.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.ShaderChangesCount">
            <summary>
            Gets number of times shader is changes after last call to ResetChangesCount.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.VertexBuffersChangesCount">
            <summary>
            Gets number of times vertex buffer is changed after last call to ResetChangesCount.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.IndexBuffersChangesCount">
            <summary>
            Gets number of times index buffer is changed after last call to ResetChangesCount.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.ConstantBufferChangesCount">
            <summary>
            Gets number of times constant buffer is changed after last call to ResetChangesCount.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.IsBlendStateLocked">
            <summary>
            If set to true than the current BlendState cannot be changed until IsBlendStateLocked is set to false.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.IsDepthStencilStateLocked">
            <summary>
            If set to true than the current DepthStencilState cannot be changed until IsDepthStencilStateLocked is set to false.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.IsRasterizerStateLocked">
            <summary>
            If set to true than the current RasterizerState cannot be changed until IsRasterizerStateLocked is set to false.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.IsSamplerStateLocked">
            <summary>
            If set to true than the current SamplerState cannot be changed until IsSamplerStateLocked is set to false.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.ContextStatesManager.ResetType">
            <summary>
            ResetType enum contain values that can be used to reset only some of the current values in ContextStatesManager.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.VertexShader">
            <summary>
            VertexShader
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.PixelShader">
            <summary>
            PixelShader
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.GeometryShader">
            <summary>
            GeometryShader
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.PrimitiveTopology">
            <summary>
            PrimitiveTopology
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.InputLayout">
            <summary>
            InputLayout
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.VertexBuffer">
            <summary>
            VertexBuffer
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.IndexBuffer">
            <summary>
            IndexBuffer
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.BlendState">
            <summary>
            BlendState
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.DepthStencilState">
            <summary>
            DepthStencilState
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.RasterizerState">
            <summary>
            RasterizerState
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.SamplerState">
            <summary>
            SamplerState
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.VertexShaderConstantBuffers">
            <summary>
            VertexShaderConstantBuffers
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.PixelShaderConstantBuffers">
            <summary>
            PixelShaderConstantBuffers
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.GeometryShaderConstantBuffers">
            <summary>
            GeometryShaderConstantBuffers
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.PixelShaderResources">
            <summary>
            PixelShaderResource
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.ContextStatesManager.ResetType.All">
            <summary>
            Reset all states
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.#ctor(Ab3d.DirectX.DXDevice,SharpDX.Direct3D11.DeviceContext,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="parentDXDevice">parent DXDevice</param>
            <param name="deviceContext">DeviceContext</param>
            <param name="name">name of this ContextStatesManager (usually indicates ContextStatesManager for background threads)</param>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.Reset(System.Boolean)">
            <summary>
            Resets all the cached resource states.
            This is usually called at the beginning of rendering a frame because we do not know if any state changes were set after the last frame was rendered.
            </summary>
            <param name="resetBoundGpuResources">when true (by default), the GPU resources that were bound through this ContextStatesManager will be reset to null</param>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.Reset(Ab3d.DirectX.ContextStatesManager.ResetType,System.Boolean,System.Boolean)">
            <summary>
            Resets the specified cached resource states. 
            This can be called if some state were not set by ContextStatesManager but were directly set by the application so the current values stored in ContextStatesManager are not valid any more.
            </summary>
            <param name="resetType">ResetType defines what resources are reset</param>
            <param name="resetBoundGpuResources">when true (by default), the GPU resources that were bound through this ContextStatesManager will be reset to null</param>
            <param name="resetLockedStates">when true (by default) the IsBlendStateLocked, IsDepthStencilStateLocked, IsRasterizerStateLocked and IsSamplerStateLocked are reset to false. When false, the locked state is not reset by this method.</param>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.ResetChangesCount">
            <summary>
            Resets the counter that counts how many state changes appeared in this ContextStatesManager
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.BlendState">
            <summary>
            Gets or sets the current BlendState
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.DepthStencilState">
            <summary>
            Gets or sets the current DepthStencilState
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.RasterizerState">
            <summary>
            Gets or sets the current RasterizerState
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.IsFrontCounterClockwise">
            <summary>
            Gets a boolean that is the same as the IsFrontCounterClockwise value in RasterizerState (this is an cached value and do not require a native GetDescription call on each getter call)
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.SetRasterizerState(SharpDX.Direct3D11.RasterizerState,System.Nullable{System.Boolean})">
            <summary>
            It is possible to call this method to set rasterizer stat and also set the cached value of IsFrontCounterClockwise.
            This eliminates the need to call the native GetDescription call when IsFrontCounterClockwise check is needed.
            </summary>
            <param name="rasterizerState"></param>
            <param name="isFrontCounterClockwise">can be null</param>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.GetSamplerState(System.Int32)">
            <summary>
            Gets the SamplerState for the specified slot
            </summary>
            <param name="slot">slot number</param>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.SetSamplerState(SharpDX.Direct3D11.SamplerState,System.Int32)">
            <summary>
            Sets the SamplerState for the specified slot
            </summary>
            <param name="state">SamplerState</param>
            <param name="slot">slot number</param>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.GetPixelShaderResource(System.Int32)">
            <summary>
            Gets the ShaderResourceView for the specified slot in the pixel shader
            </summary>
            <param name="slot">slot number</param>
            <returns>ShaderResourceView</returns>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.SetPixelShaderResource(SharpDX.Direct3D11.ShaderResourceView,System.Int32)">
            <summary>
            Sets the ShaderResourceView for the specified slot in the pixel shader
            </summary>
            <param name="resourceView">ShaderResourceView</param>
            <param name="slot">slot number</param>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.GetVertexShaderConstantBuffer(System.Int32)">
            <summary>
            Gets the constant buffer as Buffer for the specified slot in the vertex shader
            </summary>
            <param name="slot">slot number</param>
            <returns>constant buffer as Buffer</returns>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.SetVertexShaderConstantBuffer(SharpDX.Direct3D11.Buffer,System.Int32,System.Boolean)">
            <summary>
            Sets the constant buffer for the specified slot in the vertex shader
            </summary>
            <param name="constantBuffer">constant buffer</param>
            <param name="slot">slot number</param>
            <param name="forceOverrideExistingBuffer">if true (by default) the constant buffer is set even if the reference for the existing constant buffer is the same - the values inside constant buffer are not checked for equality</param>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.GetPixelShaderConstantBuffer(System.Int32)">
            <summary>
            Gets the constant buffer as Buffer for the specified slot in the pixel shader
            </summary>
            <param name="slot">slot number</param>
            <returns>constant buffer as Buffer</returns>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.SetPixelShaderConstantBuffer(SharpDX.Direct3D11.Buffer,System.Int32,System.Boolean)">
            <summary>
            Sets the constant buffer for the specified slot in the pixel shader
            </summary>
            <param name="constantBuffer">constant buffer</param>
            <param name="slot">slot number</param>
            <param name="forceOverrideExistingBuffer">if true (by default) the constant buffer is set even if the reference for the existing constant buffer is the same - the values inside constant buffer are not checked for equality</param>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.GetGeometryShaderConstantBuffer(System.Int32)">
            <summary>
            Gets the constant buffer as Buffer for the specified slot in the geometry shader
            </summary>
            <param name="slot">slot number</param>
            <returns>constant buffer as Buffer</returns>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.SetGeometryShaderConstantBuffer(SharpDX.Direct3D11.Buffer,System.Int32,System.Boolean)">
            <summary>
            Sets the constant buffer for the specified slot in the geometry shader
            </summary>
            <param name="constantBuffer">constant buffer</param>
            <param name="slot">slot number</param>
            <param name="forceOverrideExistingBuffer">if true (by default) the constant buffer is set even if the reference for the existing constant buffer is the same - the values inside constant buffer are not checked for equality</param>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.SetVertexBuffer(System.Int32,SharpDX.Direct3D11.Buffer,System.Int32,System.Int32)">
            <summary>
            Sets vertex buffer.
            </summary>
            <param name="slot">vertex buffer slot</param>
            <param name="vertexBuffer">vertexBuffer</param>
            <param name="vertexStride">vertexStride</param>
            <param name="vertexOffset">vertexOffset in bytes</param>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.SetIndexBuffer(SharpDX.Direct3D11.Buffer,SharpDX.DXGI.Format,System.Int32)">
            <summary>
            SetIndexBuffer sets the index buffer to the new index buffer if it is changed.
            </summary>
            <param name="indexBuffer">indexBuffer</param>
            <param name="format">index buffer format</param>
            <param name="indexOffset">index buffer offset</param>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.VertexShader">
            <summary>
            Gets or sets the current VertexShader
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.SetVertexShader(SharpDX.Direct3D11.VertexShader)">
            <summary>
            Sets the vertex shader if it is different as previously set vertex shader.
            The same as setter for VertexShader property but this method returns true if vertex shader was changed.
            </summary>
            <param name="newVertexShader">new VertexShader</param>
            <returns>true if vertex shader was changed</returns>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.PixelShader">
            <summary>
            Gets or sets the current PixelShader
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.SetPixelShader(SharpDX.Direct3D11.PixelShader)">
            <summary>
            Sets the pixel shader if it is different as previously set pixel shader.
            The same as setter for PixelShader property but this method returns true if pixel shader was changed.
            </summary>
            <param name="newPixelShader">new PixelShader</param>
            <returns>true if PixelShader was changed</returns>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.GeometryShader">
            <summary>
            Gets or sets the current GeometryShader
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.SetGeometryShader(SharpDX.Direct3D11.GeometryShader)">
            <summary>
            Sets the geometry shader if it is different as previously set geometry shader.
            The same as setter for GeometryShader property but this method returns true if geometry shader was changed.
            </summary>
            <param name="newGeometryShader">new GeometryShader</param>
            <returns>true if GeometryShader was changed</returns>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.PrimitiveTopology">
            <summary>
            Gets or sets the current PrimitiveTopology
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ContextStatesManager.InputLayout">
            <summary>
            Gets or sets the current InputLayout
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ContextStatesManager.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.Threading.BackgroundTaskStartDelegate">
            <summary>
            BackgroundTaskStartDelegate is a delegate that takes a thread index as an integer parameter and is passed to the <see cref="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.Execute(Ab3d.DirectX.Threading.BackgroundTaskStartDelegate)" /> method.
            </summary>
            <param name="threadIndex"></param>
        </member>
        <member name="T:Ab3d.DirectX.Threading.BackgroundThreadsManager">
            <summary>
            BackgroundThreadsManager can be used to create multiple threads and execute custom actions on them.
            </summary>
            <remarks>
                <para>
            BackgroundThreadsManager can be used to create multiple threads and execute custom actions on them.
            </para>
                <para>
            To set up the number of required threads call the <see cref="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.SetupThreads(System.Int32)" /> method.
            Then you can call the <see cref="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.Execute(Ab3d.DirectX.Threading.BackgroundTaskStartDelegate)" /> method to executed the specified action on all set up threads.
            When number of threads in the call to the <see cref="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.SetupThreads(System.Int32)" /> method is lower then the number specified in the previous call,
            the unused threads are not immediately aborted but instead they are scheduled to be aborted after the <see cref="P:Ab3d.DirectX.Threading.BackgroundThreadsManager.ThreadAbortDelayMs" /> time.
            </para>
                <para>
            You can derive your own class from BackgroundThreadsManager and override the SetupThreads, Execute, WaitAll and Dispose methods to provide you own threading mechanism.
            </para>
                <para>
            IMPORTANT: The methods in this class are not thread safe and must be called only from one thread.
            </para>
            </remarks>
        </member>
        <member name="P:Ab3d.DirectX.Threading.BackgroundThreadsManager.ThreadAbortDelayMs">
            <summary>
            Gets or sets a integer value that specifies the number of milliseconds that are used to delay the call to Thread.Abort method after the thread is not used any more.
            This is used to prevent creation and abortion of threads when the number of used threads is changing rapidly because the number of rendered objects is also changing.
            Default value is 1000 and delays the thread abortion for 1 second. Zero value means that the unused threads are immediately aborted.
            To immediately abort unused threads, set ThreadAbortDelayMs to 0 and then call <see cref="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.SetupThreads(System.Int32)" /> method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Threading.BackgroundThreadsManager.ThreadsCount">
            <summary>
            Gets the number of currently active background threads (including the threads that are schedules to be aborted).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.SetupThreads(System.Int32)">
            <summary>
            SetupThreads sets up the background threads based on the specified threadsCount.
            When the number of currently created background threads is bigger then the specified threadsCount, the unused threads are scheduled to be aborted (see <see cref="P:Ab3d.DirectX.Threading.BackgroundThreadsManager.ThreadAbortDelayMs" />).
            To immediately abort unused threads set ThreadAbortDelayMs to 0 before calling this method.
            </summary>
            <param name="threadsCount">number of required background threads</param>
        </member>
        <member name="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.Execute(Ab3d.DirectX.Threading.BackgroundTaskStartDelegate)">
            <summary>
            Execute method executes the specified taskAction on all threads that were before set up with calling the <see cref="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.SetupThreads(System.Int32)" /> method.
            The taskAction gets a thread index as parameter.
            </summary>
            <param name="taskAction">Action that will be executed on each thread (gets thread index as parameter)</param>
        </member>
        <member name="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.WaitAll">
            <summary>
            Waits indefinitely until all taskActions that were passed to the <see cref="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.Execute(Ab3d.DirectX.Threading.BackgroundTaskStartDelegate)" /> method are completed.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.WaitAll(System.Int32)">
            <summary>
            Waits until all taskActions that were passed to the <see cref="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.Execute(Ab3d.DirectX.Threading.BackgroundTaskStartDelegate)" /> method are completed.
            If the this takes longer than the millisecondsTimeout, the methods returns with false value.
            </summary>
            <returns>
            True when the tasks were completed before the timeout; false otherwise.
            </returns>
        </member>
        <member name="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.HasExceptions">
            <summary>
            HasExceptions returns true if any executed action has thrown an exception.
            </summary>
            <returns>true if any executed action has thrown an exception</returns>
        </member>
        <member name="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.GetException(System.Int32)">
            <summary>
            GetException returns an Exception object for the thread with the specified index.
            If no exception was thrown by this thread, then null is returned.
            </summary>
            <param name="threadIndex">thread index</param>
            <returns>Exception object for the thread with the specified index or null if no exception was thrown.</returns>
        </member>
        <member name="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Threading.BackgroundThreadsManager.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">true when disposing managed objects</param>
        </member>
        <member name="T:Ab3d.DirectX.Transformation">
            <summary>
            Transformation defines the Matrix that is used to transform the SceneNode.
            Transformation is optimized for cases where the Matrix is identity (no transformation).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Transformation.IsIdentity">
            <summary>
            Gets a Boolean that specifies if the Matrix is identity (there is no transformation).
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.Transformation.Value">
            <summary>
            Gets or sets a Matrix of this transformation
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.#ctor">
            <summary>
            Constructor that sets the Matrix to identity and IsIdentity to true.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.#ctor(SharpDX.Matrix)">
            <summary>
            Constructor
            </summary>
            <param name="matrix">matrix</param>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.#ctor(SharpDX.Matrix@)">
            <summary>
            Constructor
            </summary>
            <param name="matrix">matrix</param>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.Transform(SharpDX.Vector3@,SharpDX.Vector4@)">
            <summary>
            Transforms the source Vector3 with the current matrix and creates the destination as Vector4
            </summary>
            <param name="source">source as Vector3</param>
            <param name="destination">out destination as Vector4</param>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.Transform(SharpDX.Vector3@,SharpDX.Vector3@)">
            <summary>
            Transforms the source Vector3 with the current matrix and creates the destination as Vector3
            </summary>
            <param name="source">source as Vector3</param>
            <param name="destination">out destination as Vector3</param>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.TransformWithoutTranslation(SharpDX.Vector3@,SharpDX.Vector3@)">
            <summary>
            Transforms the source Vector3 with the current matrix but without using the 4th row of the matrix and creates the destination as Vector3 that is only rotated and scaled but not translated.
            </summary>
            <param name="source">source as Vector3</param>
            <param name="destination">out destination as Vector3</param>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.SetIdentity">
            <summary>
            Sets this transformation as identity (no transformation).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.SetMatrix(SharpDX.Matrix)">
            <summary>
            Sets the matrix and sets IsIdentity to false (matrix is not checked for identity)
            </summary>
            <param name="matrix">Matrix</param>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.SetMatrix(SharpDX.Matrix@)">
            <summary>
            Sets the matrix and sets IsIdentity to false (matrix is not checked for identity)
            </summary>
            <param name="matrix">Matrix</param>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.SetMatrixAndCheckForIdentity(SharpDX.Matrix)">
            <summary>
            Checks the matrix if it is identity and sets the matrix
            </summary>
            <param name="matrix">Matrix</param>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.SetMatrixAndCheckForIdentity(SharpDX.Matrix@)">
            <summary>
            Checks the matrix if it is identity and sets the matrix
            </summary>
            <param name="matrix">Matrix</param>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.SetMatrix(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the matrix and sets IsIdentity to false (matrix is not checked for identity)
            </summary>
            <param name="M11">M11</param>
            <param name="M12">M12</param>
            <param name="M13">M12</param>
            <param name="M14">M14</param>
            <param name="M21">M21</param>
            <param name="M22">M22</param>
            <param name="M23">M23</param>
            <param name="M24">M24</param>
            <param name="M31">M31</param>
            <param name="M32">M32</param>
            <param name="M33">M33</param>
            <param name="M34">M34</param>
            <param name="M41">M41</param>
            <param name="M42">M42</param>
            <param name="M43">M43</param>
            <param name="M44">M44</param>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.LeftMultiply(Ab3d.DirectX.Transformation)">
            <summary>
            Returns a Matrix that is created by multiplying this matrix with rightTransform: result = this.Matrix * rightTransform
            </summary>
            <param name="rightTransform">Transformation</param>
            <returns>Matrix</returns>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.RightMultiply(Ab3d.DirectX.Transformation)">
            <summary>
            Returns a Matrix that is created by multiplying leftTransform with this matrix: result = leftTransform * this.Matrix
            </summary>
            <param name="leftTransform">Transformation</param>
            <returns>Matrix</returns>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.LeftMultiply(SharpDX.Matrix@)">
            <summary>
            Returns a Matrix that is created by multiplying this matrix with rightMatrix: result = this.Matrix * rightMatrix
            </summary>
            <param name="rightMatrix">Matrix</param>
            <returns>Matrix</returns>
        </member>
        <member name="M:Ab3d.DirectX.Transformation.RightMultiply(SharpDX.Matrix@)">
            <summary>
            Returns a Matrix that is created by multiplying leftMatrix with this matrix: result = leftMatrix * this.Matrix
            </summary>
            <param name="leftMatrix">Matrix</param>
            <returns>Matrix</returns>
        </member>
        <member name="T:Ab3d.DirectX.HitTester">
            <summary>
            HitTester is a class that can be used do a hit testing on a mesh data with vertex and index buffer.
            The static methods in this class take a Ray, various types of vertex buffers, index buffer and a few flags and returns a hit test result.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.HitTester.HitTest(SharpDX.Ray,Ab3d.DirectX.PositionNormalTexture[],System.Int32[],System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Hit test a ray against the mesh with specified vertex and index buffer.
            </summary>
            <param name="localRay">ray transformed to local coordinate system</param>
            <param name="vertexBufferArray">vertex buffer as array of PositionNormalTexture</param>
            <param name="indexBufferArray">index buffer</param>
            <param name="hitOnlyFrontFacingTriangles">When true then only triangles that have normals (calculated from triangle positions) oriented in the opposite direction as the ray are returned (because ray is usually created from the camera's position this returns only triangles that are facing the camera).</param>
            <param name="startTriangleIndex">index of the triangle where the hit testing will begin - triangle indice index is get by multiplying this number by 3</param>
            <param name="getOnlyNextHitTest">when true, then the next hit result is returned; when false all hit results are get and only the closest to the ray origin is returned.</param>
            <returns>DXRayHitTestResult when ray hits the mesh otherwise null is returned</returns>
        </member>
        <member name="M:Ab3d.DirectX.HitTester.HasTriangleSameOrientation(SharpDX.Vector3,SharpDX.Vector3,SharpDX.Vector3,SharpDX.Vector3)">
            <summary>
            Returns true when the triangle specified with 3 positions (its normal) and a ray with specified rayDirection are facing in the same direction.
            </summary>
            <param name="p1">first triangle position</param>
            <param name="p2">second triangle position</param>
            <param name="p3">third triangle position</param>
            <param name="rayDirection">ray's direction</param>
            <returns>true when the triangle specified with 3 positions (its normal) and a ray with specified rayDirection are facing in the same direction</returns>
        </member>
        <member name="M:Ab3d.DirectX.HitTester.HitTest(SharpDX.Ray,Ab3d.DirectX.PositionNormal[],System.Int32[],System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Hit test a ray against the mesh with specified vertex and index buffer.
            </summary>
            <param name="localRay">ray transformed to local coordinate system</param>
            <param name="vertexBufferArray">vertex buffer as array of PositionNormal</param>
            <param name="indexBufferArray">index buffer</param>
            <param name="hitOnlyFrontFacingTriangles">When true then only triangles that have normals (calculated from triangle positions) oriented in the opposite direction as the ray are returned (because ray is usually created from the camera's position this returns only triangles that are facing the camera).</param>
            <param name="startTriangleIndex">index of the triangle where the hit testing will begin - triangle indice index is get by multiplying this number by 3</param>
            <param name="getOnlyNextHitTest">when true, then the next hit result is returned; when false all hit results are get and only the closest to the ray origin is returned.</param>
            <returns>DXRayHitTestResult when ray hits the mesh otherwise null is returned</returns>
        </member>
        <member name="M:Ab3d.DirectX.HitTester.HitTest(SharpDX.Ray,Ab3d.DirectX.PositionTexture[],System.Int32[],System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Hit test a ray against the mesh with specified vertex and index buffer.
            </summary>
            <param name="localRay">ray transformed to local coordinate system</param>
            <param name="vertexBufferArray">vertex buffer as array of PositionTexture</param>
            <param name="indexBufferArray">index buffer</param>
            <param name="hitOnlyFrontFacingTriangles">When true then only triangles that have normals (calculated from triangle positions) oriented in the opposite direction as the ray are returned (because ray is usually created from the camera's position this returns only triangles that are facing the camera).</param>
            <param name="startTriangleIndex">index of the triangle where the hit testing will begin - triangle indice index is get by multiplying this number by 3</param>
            <param name="getOnlyNextHitTest">when true, then the next hit result is returned; when false all hit results are get and only the closest to the ray origin is returned.</param>
            <returns>DXRayHitTestResult when ray hits the mesh otherwise null is returned</returns>
        </member>
        <member name="M:Ab3d.DirectX.HitTester.HitTest(SharpDX.Ray,SharpDX.Vector3[],System.Int32[],System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Hit test a ray against the mesh with specified vertex and index buffer.
            </summary>
            <param name="localRay">ray transformed to local coordinate system</param>
            <param name="positionsArray">vertex buffer as array of Vector3</param>
            <param name="indexBufferArray">index buffer</param>
            <param name="hitOnlyFrontFacingTriangles">When true then only triangles that have normals (calculated from triangle positions) oriented in the opposite direction as the ray are returned (because ray is usually created from the camera's position this returns only triangles that are facing the camera).</param>
            <param name="startTriangleIndex">index of the triangle where the hit testing will begin - triangle indice index is get by multiplying this number by 3</param>
            <param name="getOnlyNextHitTest">when true, then the next hit result is returned; when false all hit results are get and only the closest to the ray origin is returned.</param>
            <returns>DXRayHitTestResult when ray hits the mesh otherwise null is returned</returns>
        </member>
        <member name="T:Ab3d.DirectX.OctTree">
            <summary>
            OctTree class is obsolete and can be removed in a future version. Please use MeshOctTree instead.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.OctTree.#ctor(Ab3d.DirectX.PositionNormalTexture[],System.Int32[],System.Int32,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="vertexBufferArray">vertexBufferArray</param>
            <param name="indicesArray">indicesArray</param>
            <param name="maxNodeLevel">maxNodeLevel</param>
            <param name="expandChildBoundingBoxes">expandChildBoundingBoxes</param>
        </member>
        <member name="M:Ab3d.DirectX.OctTree.#ctor(Ab3d.DirectX.PositionNormalTexture[],System.Int32[],SharpDX.BoundingBox,System.Int32,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="vertexBufferArray">vertexBufferArray</param>
            <param name="indicesArray">indicesArray</param>
            <param name="boundingBox">boundingBox</param>
            <param name="maxNodeLevel">maxNodeLevel</param>
            <param name="expandChildBoundingBoxes">expandChildBoundingBoxes</param>
        </member>
        <member name="M:Ab3d.DirectX.OctTree.#ctor(SharpDX.Vector3[],System.Int32[],System.Int32,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="positionsArray">positionsArray</param>
            <param name="indicesArray">indicesArray</param>
            <param name="maxNodeLevel">maxNodeLevel</param>
            <param name="expandChildBoundingBoxes">expandChildBoundingBoxes</param>
        </member>
        <member name="M:Ab3d.DirectX.OctTree.#ctor(SharpDX.Vector3[],System.Int32[],SharpDX.BoundingBox,System.Int32,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="positionsArray">positionsArray</param>
            <param name="indicesArray">indicesArray</param>
            <param name="boundingBox">boundingBox</param>
            <param name="maxNodeLevel">maxNodeLevel</param>
            <param name="expandChildBoundingBoxes">expandChildBoundingBoxes</param>
        </member>
        <member name="T:Ab3d.DirectX.MeshOctTree">
            <summary>
            MeshOctTree class organizes the triangles in 3D space into multiple levels of <see cref="T:Ab3d.DirectX.MeshOctTreeNode" /> objects so that the search of a triangle or
            check for triangle ray intersection is very efficient. Each MeshOctTreeNode divide its space into 8 child MeshOctTreeNode.
            </summary>
            <remarks>
                <para>
            MeshOctTree class organizes the triangles in 3D space into multiple levels of <see cref="T:Ab3d.DirectX.MeshOctTreeNode" /> objects so that the search of a triangle or
            check for triangle ray intersection is very efficient. Each MeshOctTreeNode divide its space into 8 child MeshOctTreeNode.
            </para>
                <para>
            The number of levels (depth) is defined by the <see cref="F:Ab3d.DirectX.MeshOctTree.MaxNodeLevel" /> that can be specified with the constructor.
            Bigger number reduces the number of triangles in each node but increased the MeshOctTree initialization time and used memory.
            </para>
            </remarks>
        </member>
        <member name="F:Ab3d.DirectX.MeshOctTree.RootNode">
            <summary>
            Root MeshOctTreeNode
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.MeshOctTree.ExpandChildBoundingBoxes">
            <summary>
            ExpandChildBoundingBoxes is a float that defined how much the bounding boxes of node overlap.
            By default the value is set to 0.2 - so each bounding box is extended for 20% (but it does not go out of the parent's bounding box).
            This way the triangles that lay on node borders will be put into the child nodes instead of having them in the parent node (there we need to do a hit test every time).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.MeshOctTree.MaxNodeLevel">
            <summary>
            Number of levels used for MeshOctTree - bigger number reduces the number of triangles in each node but increased the MeshOctTree initialization time and used memory. Default value is 4.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTree.#ctor(Ab3d.DirectX.PositionNormalTexture[],System.Int32[],System.Int32,System.Single)">
            <summary>
            Creates a new instance of <see cref="T:Ab3d.DirectX.MeshOctTree" />.
            The instance is created with a standard vertex buffer format (an array of PositionNormalTexture).
            If you need to create an MeshOctTree with an array of positions instead, then use the other constructor.
            </summary>
            <param name="vertexBufferArray">standard vertex buffer (an array of PositionNormalTexture)</param>
            <param name="indicesArray">indices array as array of int values</param>
            <param name="maxNodeLevel">Number of levels used for MeshOctTree - bigger number reduces the number of triangles in each node but increased the MeshOctTree initialization time and used memory. Default value is 4.</param>
            <param name="expandChildBoundingBoxes">a float that defined how much the bounding boxes of node overlap. By default the value is set to 0.2 - so each bounding box is extended for 20% (but it does not go out of the parent's bounding box). This way the triangles that lay on node borders will be put into the child nodes instead of having them in the parent node (there we need to do a hit test every time).</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTree.#ctor(Ab3d.DirectX.PositionNormalTexture[],System.Int32[],SharpDX.BoundingBox,System.Int32,System.Single)">
            <summary>
            Creates a new instance of <see cref="T:Ab3d.DirectX.MeshOctTree" />.
            The instance is created with a standard vertex buffer format (an array of PositionNormalTexture).
            If you need to create an MeshOctTree with an array of positions instead, then use the other constructor.
            </summary>
            <param name="vertexBufferArray">standard vertex buffer (an array of PositionNormalTexture)</param>
            <param name="indicesArray">indices array as array of int values</param>
            <param name="boundingBox">BoundingBox</param>
            <param name="maxNodeLevel">Number of levels used for MeshOctTree - bigger number reduces the number of triangles in each node but increased the MeshOctTree initialization time and used memory. Default value is 4.</param>
            <param name="expandChildBoundingBoxes">a float that defined how much the bounding boxes of node overlap. By default the value is set to 0.2 - so each bounding box is extended for 20% (but it does not go out of the parent's bounding box). This way the triangles that lay on node borders will be put into the child nodes instead of having them in the parent node (there we need to do a hit test every time).</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTree.#ctor(SharpDX.Vector3[],System.Int32[],System.Int32,System.Single)">
            <summary>
            Creates a new instance of <see cref="T:Ab3d.DirectX.MeshOctTree" />.
            The instance is created with an array of positions (array of Vector3 values).
            If you need to create an MeshOctTree with a standard vertex buffer format (an array of PositionNormalTexture) instead, then use the other constructor.
            </summary>
            <param name="positionsArray">array of positions (array of Vector3 values)</param>
            <param name="indicesArray">indices array as array of int values</param>
            <param name="maxNodeLevel">Number of levels used for MeshOctTree - bigger number reduces the number of triangles in each node but increased the MeshOctTree initialization time and used memory. Default value is 4.</param>
            <param name="expandChildBoundingBoxes">a float that defined how much the bounding boxes of node overlap. By default the value is set to 0.2 - so each bounding box is extended for 20% (but it does not go out of the parent's bounding box). This way the triangles that lay on node borders will be put into the child nodes instead of having them in the parent node (there we need to do a hit test every time).</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTree.#ctor(SharpDX.Vector3[],System.Int32[],SharpDX.BoundingBox,System.Int32,System.Single)">
            <summary>
            Creates a new instance of <see cref="T:Ab3d.DirectX.MeshOctTree" />.
            The instance is created with an array of positions (array of Vector3 values).
            If you need to create an MeshOctTree with a standard vertex buffer format (an array of PositionNormalTexture) instead, then use the other constructor.
            </summary>
            <param name="positionsArray">array of positions (array of Vector3 values)</param>
            <param name="indicesArray">indices array as array of int values</param>
            <param name="boundingBox">BoundingBox</param>
            <param name="maxNodeLevel">Number of levels used for MeshOctTree - bigger number reduces the number of triangles in each node but increased the MeshOctTree initialization time and used memory. Default value is 4.</param>
            <param name="expandChildBoundingBoxes">a float that defined how much the bounding boxes of node overlap. By default the value is set to 0.2 - so each bounding box is extended for 20% (but it does not go out of the parent's bounding box). This way the triangles that lay on node borders will be put into the child nodes instead of having them in the parent node (there we need to do a hit test every time).</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTree.HitTest(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext)">
            <summary>
            HitTest method executes a ray hit test on this oct tree and returns a <see cref="T:Ab3d.DirectX.DXRayHitTestResult" /> with the closest triangle in this oct tree that is hit by the specified ray.
            If not triangle is hit, null is returned.
            To get all hit results call <seealso cref="M:Ab3d.DirectX.MeshOctTree.GetAllHitResults(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext)" /> method.
            </summary>
            <param name="ray">ray</param>
            <param name="hitTestContext">DXHitTestContext</param>
            <returns>DXRayHitTestResult in case of a hit or null of no triangle is hit</returns>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTree.GetAllHitResults(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext)">
            <summary>
            HitTest method executes a ray hit test on this oct tree and returns a list of <see cref="T:Ab3d.DirectX.DXRayHitTestResult" /> with all the hit results sorted from the closest to the farthest.
            If no triangle is hit, an empty list is returned.
            To get only the closest hit results call <seealso cref="M:Ab3d.DirectX.MeshOctTree.HitTest(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext)" /> method.
            </summary>
            <param name="ray">ray</param>
            <param name="hitTestContext">DXHitTestContext</param>
            <returns>a list of hit DXRayHitTestResult with all the hit results sorted from the closest to the farthest. Empty list is returned in case no triangle is hit.</returns>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTree.GetNodesCountInLevel(System.Int32)">
            <summary>
            GetNodesCountInLevel is a diagnostics method and returns the number of nodes (<see cref="T:Ab3d.DirectX.MeshOctTreeNode" /> objects) in the specified node level.
            </summary>
            <param name="nodeLevel">node level</param>
            <returns>number of nodes in the specified node level</returns>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTree.GetNodesCountInAllLevels">
            <summary>
            GetNodesCountInAllLevels is a diagnostics method and returns the number of child nodes (<see cref="T:Ab3d.DirectX.MeshOctTreeNode" /> objects) in this MeshOctTree.
            </summary>
            <returns>number of child nodes (<see cref="T:Ab3d.DirectX.MeshOctTreeNode" /> objects) in this MeshOctTree</returns>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTree.CollectBoundingBoxesInLevel(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            CollectBoundingBoxesInLevel is a diagnostics method and returns a list of bounding boxes from child nodes.
            </summary>
            <param name="nodeLevel">node level</param>
            <param name="getActualBoundingBox">true to get <see cref="F:Ab3d.DirectX.MeshOctTreeNode.ActualBoundingBox" />, false to get <see cref="F:Ab3d.DirectX.MeshOctTreeNode.NodeBoundingBox" /></param>
            <param name="collectOnlyNodesWithTriangles">when true then only bounding boxes from nodes that have any triangle is collected</param>
            <returns> list of bounding boxes from child nodes</returns>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTree.GetTrianglesCountInLevel(Ab3d.DirectX.MeshOctTreeNode)">
            <summary>
            GetTrianglesCountInLevel is a diagnostics method and returns the number of triangles in the specified node and its child nodes.
            </summary>
            <param name="node">node</param>
            <returns>number of triangles in the specified node and its child nodes</returns>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTree.GetNodeStatistics">
            <summary>
            GetNodeStatistics is a diagnostics method and returns a string that describes the details about this MeshOctTree.
            </summary>
            <returns>string that describes the details about this MeshOctTree</returns>
        </member>
        <member name="T:Ab3d.DirectX.OctTreeNode">
            <summary>
            OctTreeNode class is obsolete and can be removed in a future version. Please use MeshOctTreeNode instead.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.OctTreeNode.#ctor(Ab3d.DirectX.OctTree,System.Int32,SharpDX.BoundingBox)">
            <summary>
            Constructor
            </summary>
            <param name="parentOctTree">parentOctTree</param>
            <param name="nodeLevel">nodeLevel</param>
            <param name="boundingBox">boundingBox</param>
        </member>
        <member name="T:Ab3d.DirectX.MeshOctTreeNode">
            <summary>
            MeshOctTreeNode class represents one node in a <see cref="T:Ab3d.DirectX.MeshOctTree" /> data structure.
            Each node represents its part of the 3D space that is defined by the BoundingBox.
            The node contains triangles that can be fully fitted into node's BoundingBox (and do not find in any of the child nodes).
            Each node (except the nodes on the <see cref="F:Ab3d.DirectX.MeshOctTree.MaxNodeLevel" />) can have up to 8 child MeshOctTreeNodes (number can be lower in case some nodes does not contain any triangles).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.MeshOctTreeNode.ParentMashOctTree">
            <summary>
            Parent MeshOctTree
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.MeshOctTreeNode.NodeLevel">
            <summary>
            level of this node (level 1 is the first level)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.MeshOctTreeNode.NodeBoundingBox">
            <summary>
            BoundingBox of this node (calculated as 1/8 part of its parent)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.MeshOctTreeNode.ActualBoundingBox">
            <summary>
            Bounding box created from actually containing positions
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.MeshOctTreeNode.HasChildTriangles">
            <summary>
            Boolean value that specifies if this MeshOctTree has any child triangles (set to true the first time the <see cref="M:Ab3d.DirectX.MeshOctTreeNode.AddTriangle(System.Int32,SharpDX.BoundingBox@)" /> method is called).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.MeshOctTreeNode.ChildNodes">
            <summary>
            List of child MeshOctTreeNode objects. The number of child MeshOctTreeNode objects can be lower then 8 when <see cref="M:Ab3d.DirectX.MeshOctTreeNode.Optimize(System.Boolean,System.Boolean)" /> method is called to remove empty MeshOctTreeNode objects.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.MeshOctTreeNode.TriangleIndexes">
            <summary>
            List of triangle indexes that are contained in this MeshOctTreeNode. To get the index of triangle indice in the TriangleIndicesArray, multiplying the values from this list with 3.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTreeNode.#ctor(Ab3d.DirectX.MeshOctTree,System.Int32,SharpDX.BoundingBox)">
            <summary>
            Creates an instance of MeshOctTreeNode
            </summary>
            <param name="parentMeshOctTree">parent MeshOctTree</param>
            <param name="nodeLevel">level of this node (level 1 is the first level)</param>
            <param name="boundingBox">BoundingBox of this node</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTreeNode.HitTest(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext)">
            <summary>
            Hit test a ray against the triangles in this and child MeshOctTreeNodes and returns the closest hit result.
            </summary>
            <param name="ray">Ray</param>
            <param name="hitTestContext">DXHitTestContext</param>
            <returns>DXRayHitTestResult when ray hits a triangle otherwise null is returned</returns>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTreeNode.GetAllHitResults(SharpDX.Ray@,Ab3d.DirectX.DXHitTestContext,System.Collections.Generic.List{Ab3d.DirectX.DXRayHitTestResult})">
            <summary>
            Hit test a ray against the triangles in this and child MeshOctTreeNodes and adds all hit result int the specified hitResults list.
            </summary>
            <param name="ray">Ray</param>
            <param name="hitTestContext">DXHitTestContext</param>
            <param name="hitResults">list of DXRayHitTestResult where the hit results are added</param>
            <returns>DXRayHitTestResult when ray hits a triangle otherwise null is returned</returns>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTreeNode.AddTriangle(System.Int32,SharpDX.BoundingBox@)">
            <summary>
            Adds a triangle with the specified triangleBoundingBox and index to this or any child node.
            </summary>
            <param name="triangleIndex">index of the triangle</param>
            <param name="triangleBoundingBox">reference to triangle's BoundingBox</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTreeNode.Optimize(System.Boolean,System.Boolean)">
            <summary>
            Optimize method optimizes this oct tree node and its child nodes.
            It is possible to remove empty child nodes and in case of a single child node move its triangles to this node.
            This method is automatically called from the MeshOctTree constructor.
            </summary>
            <param name="removeEmptyChildNodes">when true empty nodes (nodes without any triangles) are removed from children</param>
            <param name="moveSingleChildToParent">when true and there is only one child, it is removed and its triangles are moved to parent node</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTreeNode.CollectNodesCountInLevel(Ab3d.DirectX.MeshOctTreeNode,System.Int32,System.Boolean,System.Int32@)">
            <summary>
            CollectNodesCountInLevel is a diagnostics method and returns the number of nodes (<see cref="T:Ab3d.DirectX.MeshOctTreeNode" /> objects) in the specified targetNodeLevel level.
            </summary>
            <param name="node">start node</param>
            <param name="targetNodeLevel">target node level</param>
            <param name="countChildNodes">true to count child nodes</param>
            <param name="nodesCount">number of nodes (by ref)</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTreeNode.CollectBoundingBoxesInLevel(Ab3d.DirectX.MeshOctTreeNode,System.Int32,System.Boolean,System.Boolean,System.Collections.Generic.List{SharpDX.BoundingBox})">
            <summary>
            CollectBoundingBoxesInLevel is a diagnostics method and fills the boundingBoxes list with bounding boxes from child nodes.
            </summary>
            <param name="node">start node</param>
            <param name="targetNodeLevel">target node level</param>
            <param name="getActualBoundingBox">true to get <see cref="F:Ab3d.DirectX.MeshOctTreeNode.ActualBoundingBox" />, false to get <see cref="F:Ab3d.DirectX.MeshOctTreeNode.NodeBoundingBox" /></param>
            <param name="collectOnlyNodesWithTriangles">when true then only bounding boxes from nodes that have any triangle is collected</param>
            <param name="boundingBoxes">list of BoundingBox structs</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTreeNode.CollectNodesTrianglesCountInLevel(Ab3d.DirectX.MeshOctTreeNode,System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            CollectNodesTrianglesCountInLevel is a diagnostics method and fills a list of triangles count as int values with number of triangles in each node
            </summary>
            <param name="node">start node</param>
            <param name="targetNodeLevel">target node level</param>
            <param name="trianglesCount">list of triangles count as int values</param>
        </member>
        <member name="M:Ab3d.DirectX.MeshOctTreeNode.GetTrianglesCountInLevel(Ab3d.DirectX.MeshOctTreeNode,System.Boolean,System.Int32@)">
            <summary>
            Gets number of triangles in the specified node and its child nodes.
            </summary>
            <param name="node">start node</param>
            <param name="countChildNodes">true to count triangles in child nodes also</param>
            <param name="trianglesCount">number of triangles (by ref)</param>
        </member>
        <member name="T:Ab3d.DirectX.TextureLoader">
            <summary>
            TextureLoader static class contains a method that can load image file into ShaderResourceView.
            In case the image file is png, jpg, tiff, gif, bmp or ico then WIC image decoder is used.
            In case the image file is dds (DirectDraw Surface file format that is optimized for DirectX graphics), the internal DDS file loader is used.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.TextureLoader.SupportedWicFileFormatExtensions">
            <summary>
            String array that defined supported file format that can be read with WIC (Windows Imaging Component)
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.TextureLoader.IsSupportedFile(System.String,System.Boolean)">
            <summary>
            Returns true if the specified file name has a file extension that is supported with this TextureLoader.
            </summary>
            <param name="fileName">file name</param>
            <param name="supportDDSTextures">true (by default) when dds file extensions are also supported</param>
            <returns>true if the specified file name has a file extension that is supported with this TextureLoader</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureLoader.IsSupportedFileExtension(System.String,System.Boolean)">
            <summary>
            Returns true if the specified file extension has a file extension that is supported with this TextureLoader.
            File extension must start with leading period (for example ".png").
            </summary>
            <param name="fileExtension">file extension -  must start with leading period (for example ".png")</param>
            <param name="supportDDSTextures">true (by default) when dds file extensions are also supported</param>
            <returns>true if the specified file name has a file extension that is supported with this TextureLoader</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureLoader.CreateStandardTextureMaterial(Ab3d.DirectX.DXDevice,System.String)">
            <summary>
            CreateStandardTextureMaterial method can load image png, jpg, tiff, gif, bmp, ico or dds file and create a <see cref="T:Ab3d.DirectX.Materials.StandardMaterial" />.
            The loaded texture is set to the DiffuseTextures property. The method also sets the TextureBlendState and HasTransparency properties.
            The returned StandardMaterial and the ShaderResourceView that is set to the DiffuseTextures must be manually disposed by the user.
            </summary>
            <remarks>
                <para>
            CreateStandardTextureMaterial method can load image png, jpg, tiff, gif, bmp, ico or dds file and create a <see cref="T:Ab3d.DirectX.Materials.StandardMaterial" />.
            The loaded texture is set to the DiffuseTextures property. The method also sets the TextureBlendState and HasTransparency properties.
            </para>
                <para>
            The returned StandardMaterial and the ShaderResourceView that is set to the DiffuseTextures must be manually disposed by the user.
            </para>
                <para>
            This method is first calling the <see cref="M:Ab3d.DirectX.TextureLoader.LoadShaderResourceView(SharpDX.Direct3D11.Device,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Ab3d.DirectX.TextureInfo@)" /> method
            and then <see cref="M:Ab3d.DirectX.CommonStates.GetRecommendedBlendState(System.Boolean,System.Boolean)" /> method to get the recommended BlendState.
            </para>
            </remarks>
            <param name="dxDevice">DXEngine DXDevice</param>
            <param name="fileName">file name with full path to the file</param>
            <returns>StandardMaterial with loaded texture set to DiffuseTextures</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureLoader.CreateStandardTextureMaterial(Ab3d.DirectX.DXDevice,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            CreateStandardTextureMaterial method can load image png, jpg, tiff, gif, bmp, ico or dds file and create a <see cref="T:Ab3d.DirectX.Materials.StandardMaterial" />.
            The loaded texture is set to the DiffuseTextures property. The method also sets the TextureBlendState and HasTransparency properties.
            The returned StandardMaterial and the ShaderResourceView that is set to the DiffuseTextures must be manually disposed by the user.
            </summary>
            <remarks>
                <para>
            CreateStandardTextureMaterial method can load image png, jpg, tiff, gif, bmp, ico or dds file and create a <see cref="T:Ab3d.DirectX.Materials.StandardMaterial" />.
            The loaded texture is set to the DiffuseTextures property. The method also sets the TextureBlendState and HasTransparency properties.
            </para>
                <para>
            The returned StandardMaterial and the ShaderResourceView that is set to the DiffuseTextures must be manually disposed by the user.
            </para>
                <para>
            This method is first calling the <see cref="M:Ab3d.DirectX.TextureLoader.LoadShaderResourceView(SharpDX.Direct3D11.Device,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Ab3d.DirectX.TextureInfo@)" /> method
            and then <see cref="M:Ab3d.DirectX.CommonStates.GetRecommendedBlendState(System.Boolean,System.Boolean)" /> method to get the recommended BlendState.
            </para>
            </remarks>
            <param name="dxDevice">DXEngine DXDevice</param>
            <param name="fileName">file name with full path to the file</param>
            <param name="loadDdsIfPresent">When loadDdsIfPresent is set to true and file extension is not dds, then loader checks if there is a dds file with the same name but dds file extension present in the same folder as the specified fileName. If dds file exist, it is loaded instead of the file specified with fileName. This can greatly improve load performance and memory usage. Default value is false.</param>
            <param name="convertTo32bppPRGBA">When true (by default) the image is converted into 32 bit pre-multiplied RGBA format (Format.R8G8B8A8_UNorm). Note that when file name is saved into a format that is not supported by DirectX, it will be always converted into R8G8B8A8_UNorm.</param>
            <param name="generateMipMaps">When true (by default) the mipmaps are generated before a ShaderResourceView is created. Mipmaps are recommended because they can greatly improve texture quality.</param>
            <returns>StandardMaterial with loaded texture set to DiffuseTextures</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureLoader.LoadShaderResourceView(SharpDX.Direct3D11.Device,System.String,Ab3d.DirectX.TextureInfo@)">
            <summary>
            LoadShaderResourceViewFrom can load image png, jpg, tiff, gif, bmp, ico or dds file into ShaderResourceView.
            When loadDdsIfPresent is set to true and file extension is not dds, then loader checks if there is a dds file with the same name but dds file extension present in the same folder as the specified fileName.
            If dds file exist, it is loaded instead of the file specified with fileName. This can greatly improve load performance and memory usage.
            </summary>
            <remarks>
                <para>
                    <b>LoadShaderResourceViewFrom</b> can load image png, jpg, tiff, gif, bmp, ico or dds file into ShaderResourceView.
            When loadDdsIfPresent is set to true and file extension is not dds, then loader checks if there is a dds file with the same name but dds file extension present in the same folder as the specified fileName.
            If dds file exist, it is loaded instead of the file specified with fileName. This can greatly improve load performance and memory usage.
            </para>
                <para>
            When loading dds textures for diffuse texture, it is recommended to use the BC7_UNORM format with pre-multiplied alpha (it is also possible to use BC3 or when no alpha channel is used BC1).
            </para>
            </remarks>
            <param name="device">Direct11 Device</param>
            <param name="fileName">file name with full path to the file</param>
            <param name="textureInfo">TextureInfo class that provides information about the loaded bitmap</param>
            <returns>ShaderResourceView that can be used as DirectX shader resource.</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureLoader.LoadShaderResourceView(SharpDX.Direct3D11.Device,System.String,System.Boolean,System.Boolean,System.Boolean,Ab3d.DirectX.TextureInfo@)">
            <summary>
            LoadShaderResourceViewFrom can load image png, jpg, tiff, gif, bmp, ico or dds file into ShaderResourceView.
            When loadDdsIfPresent is set to true and file extension is not dds, then loader checks if there is a dds file with the same name but dds file extension present in the same folder as the specified fileName.
            If dds file exist, it is loaded instead of the file specified with fileName. This can greatly improve load performance and memory usage.
            </summary>
            <remarks>
                <para>
                    <b>LoadShaderResourceViewFrom</b> can load image png, jpg, tiff, gif, bmp, ico or dds file into ShaderResourceView.
            When loadDdsIfPresent is set to true and file extension is not dds, then loader checks if there is a dds file with the same name but dds file extension present in the same folder as the specified fileName.
            If dds file exist, it is loaded instead of the file specified with fileName. This can greatly improve load performance and memory usage.
            </para>
                <para>
            When loading dds textures for diffuse texture, it is recommended to use the BC7_UNORM format with pre-multiplied alpha (it is also possible to use BC3 or when no alpha channel is used BC1).
            </para>
            </remarks>
            <param name="device">Direct11 Device</param>
            <param name="fileName">file name with full path to the file</param>
            <param name="loadDdsIfPresent">When loadDdsIfPresent is set to true and file extension is not dds, then loader checks if there is a dds file with the same name but dds file extension present in the same folder as the specified fileName. If dds file exist, it is loaded instead of the file specified with fileName. This can greatly improve load performance and memory usage. Default value is false.</param>
            <param name="convertTo32bppPRGBA">When true (by default) the image is converted into 32 bit pre-multiplied RGBA format (Format.R8G8B8A8_UNorm). Note that when file name is saved into a format that is not supported by DirectX, it will be always converted into R8G8B8A8_UNorm.</param>
            <param name="generateMipMaps">When true (by default) the mipmaps are generated before a ShaderResourceView is created. Mipmaps are recommended because they can greatly improve texture quality.</param>
            <param name="textureInfo">TextureInfo class that provides information about the loaded bitmap</param>
            <returns>ShaderResourceView that can be used as DirectX shader resource.</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureLoader.LoadShaderResourceView(SharpDX.Direct3D11.Device,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            LoadShaderResourceViewFrom can load image png, jpg, tiff, gif, bmp, ico or dds file into ShaderResourceView.
            When loadDdsIfPresent is set to true and file extension is not dds, the loader checked if there is a dds file with the same name but dds file extension.
            If dds file exist, it is loaded instead of the file specified with fileName. This can greatly improve load performance and memory usage.
            </summary>
            <remarks>
                <para>
                    <b>LoadShaderResourceViewFrom</b> can load image png, jpg, tiff, gif, bmp, ico or dds file into ShaderResourceView.
            When loadDdsIfPresent is set to true and file extension is not dds, the loader check if there is a dds file with the same name but dds file extension.
            If dds file exist, it is loaded instead of the file specified with fileName. This can greatly improve load performance and memory usage.
            </para>
                <para>
            When loading dds textures for diffuse texture, it is recommended to use the BC7_UNORM format with pre-multiplied alpha (it is also possible to use BC3 or when no alpha channel is used BC1).
            </para>
            </remarks>
            <param name="device">Direct11 Device</param>
            <param name="fileName">file name with full path to the file</param>
            <param name="loadDdsIfPresent">When loadDdsIfPresent is set to true and file extension is not dds, the loader checked if there is a dds file with the same name but dds file extension. If dds file exist, it is loaded instead of the file specified with fileName. This can greatly improve load performance and memory usage. Default value is false.</param>
            <param name="convertTo32bppPRGBA">When true (by default) the image is converted into 32 bit pre-multiplied RGBA format (Format.R8G8B8A8_UNorm). Note that when file name is saved into a format that is not supported by DirectX, it will be always converted into R8G8B8A8_UNorm.</param>
            <param name="generateMipMaps">When true (by default) the mipmaps are generated before a ShaderResourceView is created. Mipmaps are recommended because they can greatly improve texture quality.</param>
            <returns>ShaderResourceView that can be used as DirectX shader resource.</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureLoader.CreateShaderResourceView(Ab3d.DirectX.DXDevice,System.Byte[],System.Int32,System.Int32,System.Int32,SharpDX.DXGI.Format,System.Boolean)">
            <summary>
            CreateShaderResourceView returns a ShaderResourceView from the specified byte array. The method can also generate mipmaps when generateMipMaps is set to true (by default).
            </summary>
            <param name="dxDevice">DXEngine's DXDevice</param>
            <param name="textureBytes">array of bytes with texture data</param>
            <param name="textureWidth">texture width</param>
            <param name="textureHeight">texture height</param>
            <param name="sourceStride">length of one data row in bytes</param>
            <param name="dxgiFormat">texture format</param>
            <param name="generateMipMaps">when true (by default) mipmaps will be generated</param>
            <returns>ShaderResourceView that can be used as DirectX shader resource.</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureLoader.CreateShaderResourceView(SharpDX.Direct3D11.Device,System.Byte[],System.Int32,System.Int32,System.Int32,SharpDX.DXGI.Format,System.Boolean)">
            <summary>
            CreateShaderResourceView returns a ShaderResourceView from the specified byte array. The method can also generate mipmaps when generateMipMaps is set to true (by default).
            </summary>
            <param name="device">DirectX 11 device</param>
            <param name="textureBytes">array of bytes with texture data</param>
            <param name="textureWidth">texture width</param>
            <param name="textureHeight">texture height</param>
            <param name="sourceStride">length of one data row in bytes</param>
            <param name="dxgiFormat">texture format</param>
            <param name="generateMipMaps">when true (by default) mipmaps will be generated</param>
            <returns>ShaderResourceView that can be used as DirectX shader resource.</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureLoader.CreateShaderResourceView(SharpDX.Direct3D11.Device,System.Byte[],System.Int32,System.Int32,System.Int32,SharpDX.DXGI.Format,System.Boolean,System.Boolean@)">
            <summary>
            CreateShaderResourceView returns a ShaderResourceView from the specified byte array. The method can also generate mipmaps when generateMipMaps is set to true (by default).
            </summary>
            <param name="device">DirectX 11 device</param>
            <param name="textureBytes">array of bytes with texture data</param>
            <param name="textureWidth">texture width</param>
            <param name="textureHeight">texture height</param>
            <param name="sourceStride">length of one data row in bytes</param>
            <param name="dxgiFormat">texture format</param>
            <param name="generateMipMaps">when true (by default) mipmaps will be generated</param>
            <param name="hasTransparency">out boolean parameters that is set to true when the loaded image contains transparent pixels (where alpha is less the 1); for fully opaque image false is returned</param>
            <returns>ShaderResourceView that can be used as DirectX shader resource.</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureLoader.CreateOnePixelTexture(SharpDX.Direct3D11.Device,SharpDX.Color4,SharpDX.DXGI.Format)">
            <summary>
            CreateOnePixelTexture creates a 1 x 1 texture with the specified color (color is converted into BGRA byte values) and returns the texture as ShaderResourceView.
            </summary>
            <param name="device">DirectX 11 device</param>
            <param name="color">color as Color4</param>
            <param name="dxgiFormat">optional texture format (B8G8R8A8_UNorm by default)</param>
            <returns>ShaderResourceView for a 1x1 texture with specified color</returns>
        </member>
        <member name="M:Ab3d.DirectX.TextureLoader.HasTransparentPixels(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            HasTransparentPixels returns true when the loaded image contains transparent pixels (where alpha is less the 1); for fully opaque image false is returned.
            </summary>
            <param name="textureBytes">byte array with texture data</param>
            <param name="width">texture width in pixels</param>
            <param name="height">texture height in pixels</param>
            <param name="stride">one row size in bytes</param>
            <param name="alphaOffset">specifies the offset of the alpha byte in the pixel bytes (for BGRA the correct value is 3)</param>
            <param name="pixelSize">size of one pixel in bytes (4 by default for BGRA)</param>
            <returns>true when the loaded image contains transparent pixels (where alpha is less the 1); for fully opaque image false is returned</returns>
        </member>
        <member name="T:Ab3d.DirectX.AnaglyphVirtualRealityProvider">
            <summary>
            AnaglyphVirtualRealityProvider is a VirtualRealityProvider that can render stereoscopic anaglyph images that can be viewed with colored glasses - for example red / cyan glasses.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.AnaglyphVirtualRealityProvider.resolveAnaglyphImagesRenderingStep">
            <summary>
            SimpleResolveStereoscopicImagesRenderingStep that is created in the InitializeRenderingSteps method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.AnaglyphVirtualRealityProvider.ColorTransformation">
            <summary>
            Gets or sets a AnaglyphColorTransformation that defines how the anaglyph rendering combines colors from left and right eye.
            This is done by specifying the matrices that are used to multiply colors for left and right eye and with a gamma correction value.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.AnaglyphVirtualRealityProvider.AnaglyphColorTransformation">
            <summary>
            AnaglyphColorTransformation class defines the matrices that are used to multiply colors for left and right eye.
            It also defines the gamma value that is used to apply gamma correction before the matrix multiplication.
            </summary>
            <remarks>
                <para>
            AnaglyphColorTransformation class defines the matrices that are used to multiply colors for left and right eye.
            It also defines the gamma value that is used to apply gamma correction before the matrix multiplication.
            </para>
                <para>
            The meaning behind the number in the matrices is the following:
            </para>
                <para>
            The rows in the matrix represent the destination color. For example the left eye matrix defined above will output only red color because values are defined
            only in the first row (RGB means - 1st row = red, 2nd row = green, 3rd row = blue). The second and third row there are 0, 0, 0 - so left eye will not have any green or blue color.
            The right eye matrix defines values for green and blue colors (green + blue = cyan). So the right eye is best seen with cyan glasses.
            </para>
                <para>
            The columns in the matrix represent how the source color is used.
            For example the "0.299f, 0.587f, 0.114f" means that the output color will be get with using 29.9% red, 58.7% green and 11.4% blue
            </para>
                <para>
            The gamma values can be used to apply a gamma correction before the matrix calculations are applied.
            This "boost" specific colors.
            When value 1.0f is used for gamma, then this color will have any gamma correction.
            When gamma vector is 1, 1, 1 then a simplified and faster pixel shader without gamma correction is used.        
            </para>
            </remarks>
        </member>
        <member name="F:Ab3d.DirectX.AnaglyphVirtualRealityProvider.AnaglyphColorTransformation.LeftEyeMatrix">
            <summary>
            Matrix3x3 for colors rendered for left eye
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.AnaglyphVirtualRealityProvider.AnaglyphColorTransformation.RightEyeMatrix">
            <summary>
            Matrix3x3 for colors rendered for right eye
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.AnaglyphVirtualRealityProvider.AnaglyphColorTransformation.Gamma">
            <summary>
            Color3 that specifies gamma correction values for red, green and blue colors.
            1.0f means no gamma correction.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.AnaglyphVirtualRealityProvider.AnaglyphColorTransformation.#ctor(SharpDX.Matrix3x3,SharpDX.Matrix3x3,SharpDX.Color3)">
            <summary>
            Constructor with specified gamma values
            </summary>
            <param name="leftEyeMatrix">Matrix3x3 for colors rendered for left eye</param>
            <param name="rightEyeMatrix">Matrix3x3 for colors rendered for right eye</param>
            <param name="gamma">Color3 that specifies gamma correction values for red, green and blue colors (1.0f means no gamma correction)</param>
        </member>
        <member name="M:Ab3d.DirectX.AnaglyphVirtualRealityProvider.AnaglyphColorTransformation.#ctor(SharpDX.Matrix3x3,SharpDX.Matrix3x3)">
            <summary>
            Constructor without specified gamma values
            </summary>
            <param name="leftEyeMatrix">Matrix3x3 for colors rendered for left eye</param>
            <param name="rightEyeMatrix">Matrix3x3 for colors rendered for right eye</param>
        </member>
        <member name="F:Ab3d.DirectX.AnaglyphVirtualRealityProvider.TrueAnaglyph">
            <summary>
            TrueAnaglyph
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.AnaglyphVirtualRealityProvider.GrayAnaglyph">
            <summary>
            GrayAnaglyph 
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.AnaglyphVirtualRealityProvider.ColorAnaglyph">
            <summary>
            ColorAnaglyph
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.AnaglyphVirtualRealityProvider.HalfColorAnaglyph">
            <summary>
            HalfColorAnaglyph
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.AnaglyphVirtualRealityProvider.LeftEye">
            <summary>
            LeftEye
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.AnaglyphVirtualRealityProvider.RightEye">
            <summary>
            RightEye
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.AnaglyphVirtualRealityProvider.OptimizedAnaglyph">
            <summary>
            OptimizedAnaglyph
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.AnaglyphVirtualRealityProvider.DuboisAnaglyph">
            <summary>
            DuboisAnaglyph
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.AnaglyphVirtualRealityProvider.#ctor(System.Single,System.Single,Ab3d.DirectX.AnaglyphVirtualRealityProvider.AnaglyphColorTransformation)">
            <summary>
            Constructor
            </summary>
            <param name="eyeSeparation">distance between left and right eye</param>
            <param name="parallax">value in degrees that specifies an angle of the left and right eye look direction</param>
            <param name="anaglyphColorTransformation">AnaglyphColorTransformation that specifies how the left and right images are combined</param>
        </member>
        <member name="M:Ab3d.DirectX.AnaglyphVirtualRealityProvider.CreateResources(Ab3d.DirectX.DXScene)">
            <summary>
            CreateResources is called when the VirtualRealityProvider is initialized and should create the DirectX resources.
            </summary>
            <remarks>
                <para>
                    <b>CreateResources</b> is called when the VirtualRealityProvider is initialized and should create the DirectX resources.
            </para>
                <para>
            This method is called after this virtual reality provider is registered with calling the <see cref="M:Ab3d.DirectX.DXScene.InitializeVirtualRealityRendering(Ab3d.DirectX.VirtualRealityProviderBase)" /> method. 
            This method then calls the <see cref="M:Ab3d.DirectX.DXSceneResource.InitializeResources(Ab3d.DirectX.DXScene)" /> and the <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.OnInitializeResources(Ab3d.DirectX.DXScene)" />.
            OnInitializeResources calls the this CreateResources method and then <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.InitializeRenderingSteps(Ab3d.DirectX.DXScene)" /> method.
            </para>
                <para>
            This method usually creates pixel shaders and constant buffers.
            Other resources (back buffers and views) are usually created in <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.UpdateRenderingContext(Ab3d.DirectX.RenderingContext,System.Boolean)" /> where the size of the current back buffer is compared with the size of back buffers for virtual reality.
            </para>
            </remarks>
            <param name="dxScene">parent DXScene</param>
        </member>
        <member name="M:Ab3d.DirectX.AnaglyphVirtualRealityProvider.InitializeRenderingSteps(Ab3d.DirectX.DXScene)">
            <summary>
            InitializeRenderingSteps is called when the VirtualRealityProvider is initialized and should add customer rendering steps to the DXScene.RenderingSteps list.
            See remarks for more into.
            </summary>
            <remarks>
                <para>
                    <b>InitializeRenderingSteps</b> is called when the VirtualRealityProvider is initialized and should add customer rendering steps to the DXScene.RenderingSteps list.
            </para>
                <para>
            Usually the virtual reality rendering provider adds 3 rendering steps to existing rendering step:<br />
            1) <see cref="T:Ab3d.DirectX.BeginVirtualRealityRenderingStep" /> is added before DXScene.DefaultPrepareRenderTargetsRenderingStep (prepares the rendering context for the currently rendered eys)<br />
            2) <see cref="T:Ab3d.DirectX.RenderingStepsLoop" /> is added after DXScene.DefaultResolveBackBufferRenderingStep (this renders the scene again for the other eye - jumps to BeginVirtualRealityRenderingStep)<br />
            3) <see cref="T:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep" /> or similar step is added after RenderingStepsLoop (to render post-process effects after the VR resolve) or before DXScene.DefaultCompleteRenderingStep (to render post-process effects before the VS resolve).
            </para>
                <para>
            It is recommended that the created rendering steps are protected or public with private setter.
            This way a derived class can override the InitializeRenderingSteps method and add the created rendering steps in some other was to the DXScene.RenderingSteps.
            </para>
            </remarks>
            <param name="dxScene">parent DXScene</param>
        </member>
        <member name="M:Ab3d.DirectX.AnaglyphVirtualRealityProvider.OnIsEnabledChanged(System.Boolean)">
            <summary>
            OnIsEnabledChanged is called when the IsEnabled property is changed.
            </summary>
            <param name="newIsEnabledValue"></param>
        </member>
        <member name="M:Ab3d.DirectX.AnaglyphVirtualRealityProvider.UpdateRenderingContext(Ab3d.DirectX.RenderingContext,System.Boolean)">
            <summary>
            UpdateRenderingContext is called from the BeginVirtualRealityRenderingStep and should update the properties in the RenderingContext according to the current eye.
            See remarks for more info about the usual tasks that are preformed in this method.
            </summary>
            <remarks>
                <para>
                    <b>UpdateRenderingContext</b> is called from the BeginVirtualRealityRenderingStep and should update the properties in the RenderingContext according to the current eye.
            </para>
                <para>
            This method is usually called from the <see cref="T:Ab3d.DirectX.BeginVirtualRealityRenderingStep" /> (when the virtual reality provider is enabled).
            </para>
                <para>
            Usually this method does the following:<br />
            - Creates the back buffers and views that are needed for rendering 
            (the back buffers are also recreated if the size of <see cref="P:Ab3d.DirectX.RenderingContext.CurrentBackBufferDescription" /> is different from the size of previously created back buffers).<br />
            - Updates the <see cref="P:Ab3d.DirectX.VirtualRealityContext.CurrentEye" /> property.<br />
            - Sets the <see cref="P:Ab3d.DirectX.RenderingContext.UsedCamera" /> property to a <see cref="T:Ab3d.DirectX.Cameras.StereoscopicCamera" /><br />
            - Calls <see cref="M:Ab3d.DirectX.RenderingContext.SetBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32,System.Boolean)" /> method and sets the new back buffers.<br />
            - Calls <see cref="P:Ab3d.DirectX.ResolveBackBufferRenderingStep.DestinationBuffer" /> on the <see cref="P:Ab3d.DirectX.DXScene.DefaultResolveBackBufferRenderingStep" />.
            </para>
            </remarks>
            <param name="renderingContext">RenderingContext</param>
            <param name="isNewFrame">true if no eye was yet rendered for the current frame; false if the first eye was already rendered for the current frame and we need to render the second eye</param>
        </member>
        <member name="M:Ab3d.DirectX.AnaglyphVirtualRealityProvider.Dispose(System.Boolean)">
            <summary>
            Dispose the created resource and removes the added rendering steps.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.BeginVirtualRealityRenderingStep">
            <summary>
            BeginVirtualRealityRenderingStep is a rendering step that prepares the rendering context for rendering the current eye.
            It is usually added before DXScene.DefaultPrepareRenderTargetsRenderingStep.
            When the virtual reality provider defined in current VirtualRealityContext is enabled, this step calls the <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.UpdateRenderingContext(Ab3d.DirectX.RenderingContext,System.Boolean)" /> method.
            If virtual reality provider is not enabled this step does nothing.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.BeginVirtualRealityRenderingStep.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.BeginVirtualRealityRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="T:Ab3d.DirectX.Eye">
            <summary>
            Represents left or right eye.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Eye.Left">
            <summary>
            Left eye
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.Eye.Right">
            <summary>
            Right eye
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.ResolveStereoscopicImagesRenderingStep">
            <summary>
            ResolveStereoscopicImagesRenderingStep is a base class for presenting stereoscopic images for left and right eye to the final RenderTarget.
            The actual implementation of how the two images are presented must be defined in the derived class.
            This class provides properties that define ShaderResourceView for left and right eye.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ResolveStereoscopicImagesRenderingStep.LeftEyeShaderResourceView">
            <summary>
            Gets or sets a ShaderResourceView that represents the scene rendered through left eye.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.ResolveStereoscopicImagesRenderingStep.RightEyeShaderResourceView">
            <summary>
            Gets or sets a ShaderResourceView that represents the scene rendered through right eye.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.ResolveStereoscopicImagesRenderingStep.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.ResolveStereoscopicImagesRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="T:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep">
            <summary>
            SimpleResolveStereoscopicImagesRenderingStep is a RenderingStep that is using a pixel shader for presenting stereoscopic images for left and right eye to the final RenderTarget.
            This class provide basic logic with preparing the quad mesh and vertex shader.
            The user of the class must provide an Action that takes RenderingContext as parameter and binds a pixel shader and sets its constant buffers 
            (LeftEyeShaderResourceView and RightEyeShaderResourceView are already bind to slots 0 and 1 by this SimpleResolveStereoscopicImagesRenderingStep).
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep.vertexShaderSharedResource">
            <summary>
            VertexShader shared resource
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep.inputLayoutSharedResource">
            <summary>
            InputLayout shared resource
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep.fullScreenQuadRenderableMeshPrimitive">
            <summary>
            RenderableMeshPrimitive that represents the full screen quad (rectangle with two triangles)
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep.ApplyPixelShaderAction">
            <summary>
            Action that takes RenderingContext as parameter and binds the pixel shader and sets its constant buffers (LeftEyeShaderResourceView and RightEyeShaderResourceView are already bind to slots 0 and 1).
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep.#ctor(System.String,System.Action{Ab3d.DirectX.RenderingContext},System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name</param>
            <param name="applyPixelShaderAction">Action that takes RenderingContext as parameter and binds the pixel shader and sets its constant buffers (LeftEyeShaderResourceView and RightEyeShaderResourceView are already bind to slots 0 and 1). This parameter must not be null.</param>
            <param name="description">description</param>
        </member>
        <member name="M:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep.OnRun(Ab3d.DirectX.RenderingContext)">
            <summary>
            Runs the rendering step.
            </summary>
            <param name="renderingContext">RenderingContext</param>
        </member>
        <member name="M:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep.SaveExecutionTimeStatistics(System.Double,Ab3d.DirectX.RenderingStatistics)">
            <summary>
            SaveExecutionTimeStatistics is called when we are collecting statistics.
            The implementation of the method should save or add the elapsedMilliseconds to the corresponding property in the RenderingStatistics class.
            </summary>
            <param name="stepExecutionTimeInMilliseconds">time in milliseconds to execute this rendering step</param>
            <param name="renderingStatistics">RenderingStatistics</param>
        </member>
        <member name="M:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.SplitScreenVirtualRealityProvider">
            <summary>
            SplitScreenVirtualRealityProvider is a VirtualRealityProvider that can render stereoscopic images where image for the left eye is rendered in one half of the screen and image for the right is rendered in the other half of the screen.
            This type of 3D rendering can be seen by the 3D TV displays.
            The SplitScreenVirtualRealityProvider supports SideBySide (vertical) and TopAndBottom (horizontal) split screen.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.SplitScreenVirtualRealityProvider.SplitScreenType">
            <summary>
            SplitScreenType defines the possible types of split screen.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SplitScreenVirtualRealityProvider.SplitScreenType.SideBySide">
            <summary>
            Splits the screen vertically
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.SplitScreenVirtualRealityProvider.SplitScreenType.TopAndBottom">
            <summary>
            Splits the screen horizontally
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SplitScreenVirtualRealityProvider.SplitScreen">
            <summary>
            Gets or sets the type of split screen.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.SplitScreenVirtualRealityProvider.ImagesSeparationDistance">
            <summary>
            Gets or sets a float value that specifies the distance between stereoscopic images. 
            The value is specified in pixels. This property can be used to calibrate the images for 3D TV displays.
            For example when ImagesSeparationDistance is set to 4 and we have SideBySide type, the left image goes for two pixels to the left and right image goes for two pixels to the right - creating 4 pixels separation.
            </summary>
            <remarks>
                <para>
                    <b>ImagesSeparationDistance</b> gets or sets a float value that specifies the distance between stereoscopic images.
            </para>
                <para>
            The value is specified in pixels. For example when ImagesSeparationDistance is set to 4 and we have SideBySide type, the left image goes for two pixels to the left and right image goes for two pixels to the right - creating 4 pixels separation.
            </para>
                <para>
            When Split-screen stereoscopic rendering is used to render the 3D scene on a 3D TV, it may be necessary to
            adjust the image separation distance before a good 3D effect can be achieved.
            </para>
                <para>
            Please use the following steps to calibrate the settings for 3D TV:<br />
            - When using HDMI cable to connect computer and TV, make sure that the computer screeen is not cropped or too small(with black border on TV). You might need to adjust graphics card settings to achive the full computer screen is visible from one edge of the TV to the other.<br />
            - Set EyeSeparation, Parallax angle and Separation distance to 0. This removes the 3D effect and produces the same images for left and right eye.<br />
            - On the TV, turn the 3D mode on (use Side-by-side or Top-and-bottom mode).<br />
            - Without wearing the 3D glasses the TV should be showing one clear image(because images for left and right eye are the same). If you see blurry left and right images that are shown one near another, then you need to adjust the image separation distance by clicking on '+' and '-' buttons.With clicking on the buttons, you need to bring the separate left and right images closer together and finnally the two images should combine into one clear image.For example some Samsung TVs work best with separation distance set to 42 for side-by-side and 22 for top-and-bottom.<br />
            - When you see one clear image, then you can put the 3D glasses on(turn them on if you have active glasses; this is not needed for passive glasses).<br />
            - Now you can increase the EyeSeparation and Parallax angle. Note that for stronger 3D effect you can increase parallax angle - this also requires increased eye separation.
            </para>
            </remarks>
        </member>
        <member name="M:Ab3d.DirectX.SplitScreenVirtualRealityProvider.#ctor(System.Single,System.Single,Ab3d.DirectX.SplitScreenVirtualRealityProvider.SplitScreenType)">
            <summary>
            Constructor
            </summary>
            <param name="eyeSeparation">distance between left and right eye</param>
            <param name="parallax">value in degrees that specifies an angle of the left and right eye</param>
            <param name="splitScreen">type of split screen</param>
        </member>
        <member name="M:Ab3d.DirectX.SplitScreenVirtualRealityProvider.CreateResources(Ab3d.DirectX.DXScene)">
            <summary>
            CreateResources is called when the VirtualRealityProvider is initialized and should create the DirectX resources.
            </summary>
            <remarks>
                <para>
                    <b>CreateResources</b> is called when the VirtualRealityProvider is initialized and should create the DirectX resources.
            </para>
                <para>
            This method is called after this virtual reality provider is registered with calling the <see cref="M:Ab3d.DirectX.DXScene.InitializeVirtualRealityRendering(Ab3d.DirectX.VirtualRealityProviderBase)" /> method. 
            This method then calls the <see cref="M:Ab3d.DirectX.DXSceneResource.InitializeResources(Ab3d.DirectX.DXScene)" /> and the <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.OnInitializeResources(Ab3d.DirectX.DXScene)" />.
            OnInitializeResources calls the this CreateResources method and then <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.InitializeRenderingSteps(Ab3d.DirectX.DXScene)" /> method.
            </para>
                <para>
            This method usually creates pixel shaders and constant buffers.
            Other resources (back buffers and views) are usually created in <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.UpdateRenderingContext(Ab3d.DirectX.RenderingContext,System.Boolean)" /> where the size of the current back buffer is compared with the size of back buffers for virtual reality.
            </para>
            </remarks>
            <param name="dxScene">parent DXScene</param>
        </member>
        <member name="M:Ab3d.DirectX.SplitScreenVirtualRealityProvider.InitializeRenderingSteps(Ab3d.DirectX.DXScene)">
            <summary>
            InitializeRenderingSteps is called when the VirtualRealityProvider is initialized and should add customer rendering steps to the DXScene.RenderingSteps list.
            See remarks for more into.
            </summary>
            <remarks>
                <para>
                    <b>InitializeRenderingSteps</b> is called when the VirtualRealityProvider is initialized and should add customer rendering steps to the DXScene.RenderingSteps list.
            </para>
                <para>
            Usually the virtual reality rendering provider adds 3 rendering steps to existing rendering step:<br />
            1) <see cref="T:Ab3d.DirectX.BeginVirtualRealityRenderingStep" /> is added before DXScene.DefaultPrepareRenderTargetsRenderingStep (prepares the rendering context for the currently rendered eys)<br />
            2) <see cref="T:Ab3d.DirectX.RenderingStepsLoop" /> is added after DXScene.DefaultResolveBackBufferRenderingStep (this renders the scene again for the other eye - jumps to BeginVirtualRealityRenderingStep)<br />
            3) <see cref="T:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep" /> or similar step is added after RenderingStepsLoop (to render post-process effects after the VR resolve) or before DXScene.DefaultCompleteRenderingStep (to render post-process effects before the VS resolve).
            </para>
                <para>
            This method usually also created the pixel shaders and constant buffers.
            Other resources (back buffers and views) are usually created in <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.UpdateRenderingContext(Ab3d.DirectX.RenderingContext,System.Boolean)" /> where the size of the current back buffer is compared with the size of back buffers for virtual reality.
            </para>
                <para>
            It is recommended that the created rendering steps are protected or public with private setter.
            This way a derived class can override the InitializeRenderingSteps method and add the created rendering steps in some other was to the DXScene.RenderingSteps.
            </para>
            </remarks>
            <param name="dxScene">parent DXScene</param>
        </member>
        <member name="M:Ab3d.DirectX.SplitScreenVirtualRealityProvider.UpdateRenderingContext(Ab3d.DirectX.RenderingContext,System.Boolean)">
            <summary>
            UpdateRenderingContext is called from the BeginVirtualRealityRenderingStep and should update the properties in the RenderingContext according to the current eye.
            See remarks for more info about the usual tasks that are preformed in this method.
            </summary>
            <remarks>
                <para>
                    <b>UpdateRenderingContext</b> is called from the BeginVirtualRealityRenderingStep and should update the properties in the RenderingContext according to the current eye.
            </para>
                <para>
            This method is usually called from the <see cref="T:Ab3d.DirectX.BeginVirtualRealityRenderingStep" /> (when the virtual reality provider is enabled).
            </para>
                <para>
            Usually this method does the following:<br />
            - Creates the back buffers and views that are needed for rendering 
            (the back buffers are also recreated if the size of <see cref="P:Ab3d.DirectX.RenderingContext.CurrentBackBufferDescription" /> is different from the size of previously created back buffers).<br />
            - Updates the <see cref="P:Ab3d.DirectX.VirtualRealityContext.CurrentEye" /> property.<br />
            - Sets the <see cref="P:Ab3d.DirectX.RenderingContext.UsedCamera" /> property to a <see cref="T:Ab3d.DirectX.Cameras.StereoscopicCamera" /><br />
            - Calls <see cref="M:Ab3d.DirectX.RenderingContext.SetBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32,System.Boolean)" /> method and sets the new back buffers.<br />
            - Calls <see cref="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.SetCustomDestinationBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)" /> on the <see cref="P:Ab3d.DirectX.DXScene.DefaultResolveBackBufferRenderingStep" />.
            </para>
            </remarks>
            <param name="renderingContext">RenderingContext</param>
            <param name="isNewFrame">true if no eye was yet rendered for the current frame; false if the first eye was already rendered for the current frame and we need to render the second eye</param>
        </member>
        <member name="M:Ab3d.DirectX.SplitScreenVirtualRealityProvider.Dispose(System.Boolean)">
            <summary>
            Dispose the created resource and removes the added rendering steps.
            </summary>
        </member>
        <member name="T:Ab3d.DirectX.StereoscopicVirtualRealityProvider">
            <summary>
            StereoscopicVirtualRealityProvider is an abstract class and provides common logic to render stereoscopic images.
            </summary>
            <remarks>
                <para>
                    <b>StereoscopicVirtualRealityProvider</b> is an abstract class and provides common logic to render stereoscopic images.
            </para>
                <para>
            The class provides basic properties to define the stereoscopic camera: <see cref="P:Ab3d.DirectX.StereoscopicVirtualRealityProvider.EyeSeparation" />, <see cref="P:Ab3d.DirectX.StereoscopicVirtualRealityProvider.Parallax" /> and <see cref="P:Ab3d.DirectX.StereoscopicVirtualRealityProvider.InvertLeftRightView" />.
            </para>
                <para>
            The class also provides basic implementation of <see cref="M:Ab3d.DirectX.StereoscopicVirtualRealityProvider.InitializeRenderingSteps(Ab3d.DirectX.DXScene)" /> method.
            The method creates the protected <see cref="F:Ab3d.DirectX.StereoscopicVirtualRealityProvider.beginVirtualRealityRenderingStep" /> (of type <see cref="T:Ab3d.DirectX.BeginVirtualRealityRenderingStep" />) and 
            protected <see cref="F:Ab3d.DirectX.StereoscopicVirtualRealityProvider.renderingStepsLoop" /> (of type <see cref="T:Ab3d.DirectX.RenderingStepsLoop" />) and also adds them to the RenderingSteps in the DXScene.
            </para>
                <para>    
            The position of the beginVirtualRealityRenderingStep is defined with the prepareRenderTargetsForEachEye parameter that is specified in the <see cref="M:Ab3d.DirectX.StereoscopicVirtualRealityProvider.#ctor(System.Single,System.Single,System.Boolean)">constructor</see>.
            If prepareRenderTargetsForEachEye is true, then the RenderTarget is cleared before each eye is rendered. 
            This is achieved with inserting the BeginVirtualRealityRenderingStep before the DefaultPrepareRenderTargetsRenderingStep (used for Anaglyph rendering).
            If prepareRenderTargetsForEachEye is false, then the RenderTarget is cleared only once per frame. 
            In this case the BeginVirtualRealityRenderingStep is added after the DefaultPrepareRenderTargetsRenderingStep (used for Split screen stereoscopic rendering) .
            </para>
                <para>
            The <see cref="M:Ab3d.DirectX.StereoscopicVirtualRealityProvider.CreateVirtualRealityContext(Ab3d.DirectX.RenderingContext)" /> method creates a default <see cref="T:Ab3d.DirectX.VirtualRealityContext" /> - calls its  constructor with current RenderingContext.
            It is possible to override this method to create an instance of your own class derived from VirtualRealityContext.
            </para>
                <para>
            The <see cref="M:Ab3d.DirectX.StereoscopicVirtualRealityProvider.UpdateRenderingContext(Ab3d.DirectX.RenderingContext,System.Boolean)" /> method does:<br />
            - sets the virtualRealityContext.CurrentEye based on the isNewFrame parameter: isNewFrame == true =&gt; LeftEye else RightEye<br />
            - ensures that stereoscopicCamera is created and sets its properties for the current eye and based on the current EyeSeparation, Parallax and InvertLeftRightView<br />
            - sets renderingContext.UsedCamera = stereoscopicCamera
            </para>
            </remarks>
        </member>
        <member name="F:Ab3d.DirectX.StereoscopicVirtualRealityProvider.beginVirtualRealityRenderingStep">
            <summary>
            BeginVirtualRealityRenderingStep that was created in the <see cref="M:Ab3d.DirectX.StereoscopicVirtualRealityProvider.InitializeRenderingSteps(Ab3d.DirectX.DXScene)" /> method.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.StereoscopicVirtualRealityProvider.renderingStepsLoop">
            <summary>
            RenderingStepsLoop that was created in the <see cref="M:Ab3d.DirectX.StereoscopicVirtualRealityProvider.InitializeRenderingSteps(Ab3d.DirectX.DXScene)" /> method.
            </summary>
        </member>
        <member name="F:Ab3d.DirectX.StereoscopicVirtualRealityProvider.stereoscopicCamera">
            <summary>
            StereoscopicCamera used to render stereoscopic scene.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.StereoscopicVirtualRealityProvider.EyeSeparation">
            <summary>
            Gets or sets a distance between left and right eye. The distance is specified in the same coordinate system as the camera.
            When rendering, the camera is first shifter to the left for the half of the EyeSeparation distance. Then the whole scene is rendered.
            The the camera is shifter to the right for half of the EyeSeparation distance.
            The best value for EyeSeparation is based on the size of objects in the scene, the size of the Viewport3D, monitor DPI settings and the actual distance between eyes of the user.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.StereoscopicVirtualRealityProvider.Parallax">
            <summary>
            Parallax defines a value in degrees that specifies an angle of the left and right eye look direction.
            If the parallax is zero, then the look directions of left and right cameras are parallel.
            If parallax is bigger then zero, then the left and right look directions are pointed to each other and they cross at some position in front of the camera (the bigger the angle the closer the crossing point).
            Usually the best 3D effect is producted when the parallax is set so that the look directions cross at the center of the scene - look directions of human eyes cross at the point of focus.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.StereoscopicVirtualRealityProvider.InvertLeftRightView">
            <summary>
            Gets or sets a Boolean that specifies if positions of the eyes are inverted.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.StereoscopicVirtualRealityProvider.#ctor(System.Single,System.Single,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="eyeSeparation">distance between left and right eye</param>
            <param name="parallax">value in degrees that specifies an angle of the left and right eye</param>
            <param name="prepareRenderTargetsForEachEye">specifies where the BeginVirtualRealityRenderingStep is inserted: true if current RenderTarget is cleared before each eye is rendered - two times per frame (BeginVirtualRealityRenderingStep is added before the DefaultPrepareRenderTargetsRenderingStep - used to Anaglyph rendering); false when the RenderTarget is cleared only once per frame - (BeginVirtualRealityRenderingStep is added after the DefaultPrepareRenderTargetsRenderingStep - used to Split screen stereoscopic rendering)</param>
        </member>
        <member name="M:Ab3d.DirectX.StereoscopicVirtualRealityProvider.InitializeRenderingSteps(Ab3d.DirectX.DXScene)">
            <summary>
            InitializeRenderingSteps is called when the VirtualRealityProvider is initialized and should add customer rendering steps to the DXScene.RenderingSteps list.
            See remarks for more into.
            </summary>
            <remarks>
                <para>
                    <b>InitializeRenderingSteps</b> is called when the VirtualRealityProvider is initialized and should add customer rendering steps to the DXScene.RenderingSteps list.
            </para>
                <para>
            Usually the virtual reality rendering provider adds 3 rendering steps to existing rendering step:<br />
            1) <see cref="T:Ab3d.DirectX.BeginVirtualRealityRenderingStep" /> is added before or after the DXScene.DefaultPrepareRenderTargetsRenderingStep (prepares the rendering context for the currently rendered eye). The position of the BeginVirtualRealityRenderingStep is defined by the prepareRenderTargetsForEachEye parameter specified in the constructor (see remarks of this class for more info).<br />
            2) <see cref="T:Ab3d.DirectX.RenderingStepsLoop" /> is added after DXScene.DefaultResolveBackBufferRenderingStep (this renders the scene again for the other eye - jumps to BeginVirtualRealityRenderingStep)<br />
            3) <see cref="T:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep" /> or similar step is added after RenderingStepsLoop (to render post-process effects after the VR resolve) or before DXScene.DefaultCompleteRenderingStep (to render post-process effects before the VS resolve).
            </para>
                <para>
            It is recommended that the created rendering steps are protected or public with private setter.
            This way a derived class can override the InitializeRenderingSteps method and add the created rendering steps in some other was to the DXScene.RenderingSteps.
            </para>
            </remarks>
            <param name="dxScene">parent DXScene</param>
        </member>
        <member name="M:Ab3d.DirectX.StereoscopicVirtualRealityProvider.CreateVirtualRealityContext(Ab3d.DirectX.RenderingContext)">
            <summary>
            CreateVirtualRealityContext method takes current RenderingContext as parameter and should create the VirtualRealityContext or a class derived from it.
            The returned VirtualRealityContext defines the context in which this virtual reality provider runs.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <returns>VirtualRealityContext</returns>
        </member>
        <member name="M:Ab3d.DirectX.StereoscopicVirtualRealityProvider.UpdateRenderingContext(Ab3d.DirectX.RenderingContext,System.Boolean)">
            <summary>
            UpdateRenderingContext is called from the BeginVirtualRealityRenderingStep and should update the properties in the RenderingContext according to the current eye.
            See remarks for more info about the usual tasks that are preformed in this method.
            </summary>
            <remarks>
                <para>
                    <b>UpdateRenderingContext</b> is called from the BeginVirtualRealityRenderingStep and should update the properties in the RenderingContext according to the current eye.
            </para>
                <para>
            This method is usually called from the <see cref="T:Ab3d.DirectX.BeginVirtualRealityRenderingStep" /> (when the virtual reality provider is enabled).
            </para>
                <para>
            Usually this method does the following:<br />
            - Creates the back buffers and views that are needed for rendering 
            (the back buffers are also recreated if the size of <see cref="P:Ab3d.DirectX.RenderingContext.CurrentBackBufferDescription" /> is different from the size of previously created back buffers).<br />
            - Updates the <see cref="P:Ab3d.DirectX.VirtualRealityContext.CurrentEye" /> property.<br />
            - Sets the <see cref="P:Ab3d.DirectX.RenderingContext.UsedCamera" /> property to a <see cref="T:Ab3d.DirectX.Cameras.StereoscopicCamera" /><br />
            - Calls <see cref="M:Ab3d.DirectX.RenderingContext.SetBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32,System.Boolean)" /> method and sets the new back buffers.<br />
            - Calls <see cref="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.SetCustomDestinationBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)" /> on the <see cref="P:Ab3d.DirectX.DXScene.DefaultResolveBackBufferRenderingStep" />.
            </para>
            </remarks>
            <param name="renderingContext">RenderingContext</param>
            <param name="isNewFrame">true if no eye was yet rendered for the current frame; false if the first eye was already rendered for the current frame and we need to render the second eye</param>
        </member>
        <member name="M:Ab3d.DirectX.StereoscopicVirtualRealityProvider.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
        <member name="T:Ab3d.DirectX.VirtualRealityContext">
            <summary>
            VirtualRealityContext provides base class for describing the context used for rendering a virtual reality scene.
            During rendering of the scene, the VirtualRealityContext can be read from the <see cref="P:Ab3d.DirectX.RenderingContext.VirtualRealityContext" /> property.
            The instace of VirtualRealityContext is created in the VirtualRealityProviderBase.CreateVirtualRealityContext method.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.VirtualRealityContext.CurrentEye">
            <summary>
            Gets or sets the currently rendered eye.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.VirtualRealityContext.VirtualRealityProvider">
            <summary>
            Gets a VirtualRealityProviderBase.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.VirtualRealityContext.#ctor(Ab3d.DirectX.VirtualRealityProviderBase)">
            <summary>
            Constructor
            </summary>
            <param name="virtualRealityProvider">VirtualRealityProviderBase</param>
        </member>
        <member name="T:Ab3d.DirectX.VirtualRealityProviderBase">
            <summary>
            VirtualRealityProviderBase is a base abstract class for all classes that provide virtual reality support to DXEngine.
            </summary>
        </member>
        <member name="P:Ab3d.DirectX.VirtualRealityProviderBase.IsEnabled">
            <summary>
            Gets or sets a Boolean that specifies if this Virtual reality provider is enabled or not.
            Default value is true.
            </summary>
            <remarks>
                <para>
                    <b>IsEnabled</b> gets or sets a Boolean that specifies if this Virtual reality provider is enabled or not.
            </para>
                <para>
            IsEnabled property can be used to quickly enable of disable Virtual reality rendering. 
            </para>
                <para>
            When the VirtualRealityProvider is disabled, the created DirectX resources are usually disposed, but the created rendering steps are still part of the DXScene.RenderingSteps.
            </para>
                <para>
            To remove all the created DirectX resources and also remove the rendering steps, call the Dispose method.
            </para>
            </remarks>
        </member>
        <member name="M:Ab3d.DirectX.VirtualRealityProviderBase.OnInitializeResources(Ab3d.DirectX.DXScene)">
            <summary>
            OnInitializeResources is called from  the DXScene.<see cref="M:Ab3d.DirectX.DXScene.InitializeVirtualRealityRendering(Ab3d.DirectX.VirtualRealityProviderBase)" />.
            The method calls <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.CreateResources(Ab3d.DirectX.DXScene)" /> and <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.InitializeRenderingSteps(Ab3d.DirectX.DXScene)" /> methods.
            </summary>
            <param name="dxScene">Parent DXScene used to initialize resources</param>
        </member>
        <member name="M:Ab3d.DirectX.VirtualRealityProviderBase.CreateResources(Ab3d.DirectX.DXScene)">
            <summary>
            CreateResources is called when the VirtualRealityProvider is initialized and should create the DirectX resources.
            </summary>
            <remarks>
                <para>
                    <b>CreateResources</b> is called when the VirtualRealityProvider is initialized and should create the DirectX resources.
            </para>
                <para>
            This method is called after this virtual reality provider is registered with calling the <see cref="M:Ab3d.DirectX.DXScene.InitializeVirtualRealityRendering(Ab3d.DirectX.VirtualRealityProviderBase)" /> method. 
            This method then calls the <see cref="M:Ab3d.DirectX.DXSceneResource.InitializeResources(Ab3d.DirectX.DXScene)" /> and the <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.OnInitializeResources(Ab3d.DirectX.DXScene)" />.
            OnInitializeResources calls the this CreateResources method and then <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.InitializeRenderingSteps(Ab3d.DirectX.DXScene)" /> method.
            </para>
                <para>
            This method usually creates pixel shaders and constant buffers.
            Other resources (back buffers and views) are usually created in <see cref="M:Ab3d.DirectX.VirtualRealityProviderBase.UpdateRenderingContext(Ab3d.DirectX.RenderingContext,System.Boolean)" /> where the size of the current back buffer is compared with the size of back buffers for virtual reality.
            </para>
            </remarks>
            <param name="dxScene">parent DXScene</param>
        </member>
        <member name="M:Ab3d.DirectX.VirtualRealityProviderBase.InitializeRenderingSteps(Ab3d.DirectX.DXScene)">
            <summary>
            InitializeRenderingSteps is called when the VirtualRealityProvider is initialized and should add customer rendering steps to the DXScene.RenderingSteps list.
            See remarks for more into.
            </summary>
            <remarks>
                <para>
                    <b>InitializeRenderingSteps</b> is called when the VirtualRealityProvider is initialized and should add customer rendering steps to the DXScene.RenderingSteps list.
            </para>
                <para>
            Usually the virtual reality rendering provider adds 3 rendering steps to existing rendering step:<br />
            1) <see cref="T:Ab3d.DirectX.BeginVirtualRealityRenderingStep" /> is added before DXScene.DefaultPrepareRenderTargetsRenderingStep (prepares the rendering context for the currently rendered eys)<br />
            2) <see cref="T:Ab3d.DirectX.RenderingStepsLoop" /> is added after DXScene.DefaultResolveBackBufferRenderingStep (this renders the scene again for the other eye - jumps to BeginVirtualRealityRenderingStep)<br />
            3) <see cref="T:Ab3d.DirectX.SimpleResolveStereoscopicImagesRenderingStep" /> or similar step is added after RenderingStepsLoop (to render post-process effects after the VR resolve) or before DXScene.DefaultCompleteRenderingStep (to render post-process effects before the VS resolve).
            </para>
                <para>
            It is recommended that the created rendering steps are protected or public with private setter.
            This way a derived class can override the InitializeRenderingSteps method and add the created rendering steps in some other was to the DXScene.RenderingSteps.
            </para>
            </remarks>
            <param name="dxScene">parent DXScene</param>
        </member>
        <member name="M:Ab3d.DirectX.VirtualRealityProviderBase.CreateVirtualRealityContext(Ab3d.DirectX.RenderingContext)">
            <summary>
            CreateVirtualRealityContext method takes current RenderingContext as parameter and should create the VirtualRealityContext or a class derived from it.
            The returned VirtualRealityContext defines the context in which this virtual reality provider runs.
            </summary>
            <param name="renderingContext">RenderingContext</param>
            <returns>VirtualRealityContext</returns>
        </member>
        <member name="M:Ab3d.DirectX.VirtualRealityProviderBase.UpdateRenderingContext(Ab3d.DirectX.RenderingContext,System.Boolean)">
            <summary>
            UpdateRenderingContext is called from the BeginVirtualRealityRenderingStep and should update the properties in the RenderingContext according to the current eye.
            See remarks for more info about the usual tasks that are preformed in this method.
            </summary>
            <remarks>
                <para>
                    <b>UpdateRenderingContext</b> is called from the BeginVirtualRealityRenderingStep and should update the properties in the RenderingContext according to the current eye.
            </para>
                <para>
            This method is usually called from the <see cref="T:Ab3d.DirectX.BeginVirtualRealityRenderingStep" /> (when the virtual reality provider is enabled).
            </para>
                <para>
            Usually this method does the following:<br />
            - Creates the back buffers and views that are needed for rendering 
            (the back buffers are also recreated if the size of <see cref="P:Ab3d.DirectX.RenderingContext.CurrentBackBufferDescription" /> is different from the size of previously created back buffers).<br />
            - Updates the <see cref="P:Ab3d.DirectX.VirtualRealityContext.CurrentEye" /> property.<br />
            - Sets the <see cref="P:Ab3d.DirectX.RenderingContext.UsedCamera" /> property to a <see cref="T:Ab3d.DirectX.Cameras.StereoscopicCamera" /><br />
            - Calls <see cref="M:Ab3d.DirectX.RenderingContext.SetBackBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView,SharpDX.Direct3D11.DepthStencilView,System.Int32,System.Boolean)" /> method and sets the new back buffers.<br />
            - Calls <see cref="M:Ab3d.DirectX.ResolveBackBufferRenderingStep.SetCustomDestinationBuffer(SharpDX.Direct3D11.Texture2D,SharpDX.Direct3D11.Texture2DDescription,SharpDX.Direct3D11.RenderTargetView)" /> on the <see cref="P:Ab3d.DirectX.DXScene.DefaultResolveBackBufferRenderingStep" />.
            </para>
            </remarks>
            <param name="renderingContext">RenderingContext</param>
            <param name="isNewFrame">true if no eye was yet rendered for the current frame; false if the first eye was already rendered for the current frame and we need to render the second eye</param>
        </member>
        <member name="M:Ab3d.DirectX.VirtualRealityProviderBase.OnIsEnabledChanged(System.Boolean)">
            <summary>
            OnIsEnabledChanged is called when the IsEnabled property is changed.
            </summary>
            <param name="newIsEnabledValue"></param>
        </member>
        <member name="M:Ab3d.DirectX.VirtualRealityProviderBase.NotifyDXSceneChange">
            <summary>
            NotifyDXSceneChange calls NotifyChange on dxScene and sets the VirtualRealitySettingsChanged flag.
            </summary>
        </member>
        <member name="M:Ab3d.DirectX.VirtualRealityProviderBase.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">disposing</param>
        </member>
    </members>
</doc>